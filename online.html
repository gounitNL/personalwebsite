<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>FantasyQuest 3D MORPG - PlayZone v2.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #ecf0f1;
            overflow: auto;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: pan-x pan-y;
        }
        
        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }
        
        #renderCanvas {
            touch-action: none;
            -webkit-touch-callout: none;
        }

        #loginScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            overflow-y: auto;
        }

        #loginScreen.hidden { display: none; }

        .login-box {
            background: white;
            padding: 3rem;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        /* Character Customization Screen */
        #customizationScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            overflow-y: auto;
        }

        #customizationScreen.active { display: flex; }

        .customization-box {
            background: white;
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .customization-box h2 {
            color: #667eea;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .customization-section {
            margin-bottom: 1.5rem;
        }

        .customization-section h3 {
            color: #333;
            margin-bottom: 0.75rem;
            font-size: 1rem;
        }

        .color-options {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.5rem;
        }

        .color-option {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 8px;
            border: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .color-option:hover {
            transform: scale(1.1);
        }

        .color-option.selected {
            border-color: #667eea;
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }

        .color-option.selected::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .style-options {
            display: flex;
            gap: 0.5rem;
        }

        .style-option {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #f5f5f5;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: bold;
        }

        .style-option:hover {
            background: #e0e0e0;
        }

        .style-option.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .character-preview {
            width: 200px;
            height: 250px;
            margin: 1rem auto;
            background: linear-gradient(135deg, #87CEEB 0%, #4682B4 100%);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 3px solid #ddd;
            position: relative;
            overflow: hidden;
        }

        .preview-character {
            position: relative;
            transform: scale(1.5);
        }

        .customize-btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .customize-btn:hover {
            transform: scale(1.05);
        }

        .login-box h1 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 2rem;
        }

        .login-box p {
            color: #666;
            margin-bottom: 2rem;
        }

        .login-box input {
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1rem;
        }

        .login-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .login-box button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .login-box button:hover {
            transform: scale(1.05);
        }

        .home-btn {
            display: inline-block;
            margin-bottom: 1rem;
            padding: 0.5rem 1rem;
            background: #f0f0f0;
            color: #667eea;
            text-decoration: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .home-btn:hover {
            background: #667eea;
            color: white;
            border-color: #667eea;
            transform: translateX(-2px);
        }

        #gameContainer {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #gameContainer.hidden { display: none; }

        /* Left Sidebar */
        #leftSidebar {
            width: 250px;
            background: rgba(44, 62, 80, 0.95);
            padding: 1rem;
            overflow-y: auto;
            border-right: 2px solid #34495e;
        }

        .character-panel {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .character-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        .stat-bar {
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.9rem;
            margin-bottom: 0.2rem;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #34495e;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .hp-bar { background: linear-gradient(90deg, #e74c3c, #c0392b); }
        .xp-bar { background: linear-gradient(90deg, #3498db, #2980b9); }

        .skills-panel {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .skill-name { font-weight: bold; }
        .skill-level { color: #f39c12; }

        /* Center Game Area */
        #gameArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #gameHeader {
            background: rgba(44, 62, 80, 0.95);
            padding: 1rem 2rem;
            border-bottom: 2px solid #34495e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #gameTitle {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #onlineCount {
            font-size: 0.9rem;
            color: #2ecc71;
        }
        
        /* Top-center info panel for logout and online count */
        .top-info-panel {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(44, 62, 80, 0.95);
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            border: 2px solid rgba(52, 73, 94, 0.8);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 100;
        }
        
        .logout-btn {
            padding: 0.5rem 1rem;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s, transform 0.2s;
        }
        
        .logout-btn:hover {
            background: #c0392b;
            transform: scale(1.05);
        }

        #renderCanvas {
            flex: 1;
            background: #87CEEB;
            display: block;
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #ecf0f1;
            text-align: center;
        }

        .camera-controls {
            position: absolute;
            top: 70px;
            right: 330px;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        /* Mini-map */
        .mini-map {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .compass {
            position: absolute;
            top: 230px;
            right: 85px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 0 0 5px #000;
        }

        /* Day/Night Indicator */
        .day-night-indicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        /* Quest Panel */
        .quest-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.98);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1500;
            display: none;
        }

        .quest-panel.active { display: block; }

        .quest-item {
            background: rgba(52, 73, 94, 0.5);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            border-left: 4px solid #f39c12;
        }

        .close-panel-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: #e74c3c;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
        }

        /* Right Sidebar */
        #rightSidebar {
            width: 300px;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            border-left: 2px solid #34495e;
        }

        #chatArea {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .chat-message {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: rgba(52, 73, 94, 0.5);
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .chat-player {
            color: #3498db;
            font-weight: bold;
        }

        .chat-system {
            color: #f39c12;
            font-style: italic;
        }

        #chatInput {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #34495e;
        }

        #chatInput input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #34495e;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
        }

        #chatInput button {
            margin-left: 0.5rem;
            padding: 0.5rem 1rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #chatInput button:hover {
            background: #2980b9;
        }

        .action-buttons {
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            border-top: 1px solid #34495e;
        }

        .action-btn {
            padding: 0.8rem;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .action-btn:hover {
            transform: scale(1.05);
        }

        .action-btn.gather {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .action-btn.craft {
            background: linear-gradient(135deg, #8e44ad, #71368a);
        }

        .action-btn.quest {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .inventory-panel {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #34495e;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            position: relative;
        }

        .inventory-slot.has-item {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .item-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        /* Mobile Virtual Controls */
        #mobileControls {
            display: none;
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 100;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        #mobileActionButtons {
            display: none;
            position: absolute;
            bottom: 80px;
            right: 20px;
            z-index: 100;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-action-btn {
            width: 60px;
            height: 60px;
            background: rgba(231, 76, 60, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            touch-action: none;
        }

        .mobile-action-btn.gather {
            background: rgba(39, 174, 96, 0.8);
        }

        .toggle-sidebar-btn {
            display: none;
            position: absolute;
            top: 70px;
            background: rgba(44, 62, 80, 0.9);
            border: 2px solid #34495e;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            z-index: 150;
            font-size: 1.2rem;
        }

        #toggleLeft {
            left: 10px;
        }

        #toggleRight {
            right: 10px;
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 199;
        }

        @media (max-width: 1024px) {
            #leftSidebar { width: 220px; }
            #rightSidebar { width: 280px; }
            .login-box { padding: 2rem; }
        }

        @media (max-width: 768px) {
            #leftSidebar, #rightSidebar {
                position: fixed;
                top: 0;
                height: 100vh;
                z-index: 200;
                transition: transform 0.3s;
            }

            #leftSidebar {
                left: 0;
                transform: translateX(-100%);
                width: 250px;
            }

            #leftSidebar.open {
                transform: translateX(0);
            }

            #rightSidebar {
                right: 0;
                transform: translateX(100%);
                width: 280px;
            }

            #rightSidebar.open {
                transform: translateX(0);
            }

            .sidebar-overlay.active {
                display: block;
            }

            .toggle-sidebar-btn {
                display: block;
            }

            #mobileControls {
                display: block;
            }

            #mobileActionButtons {
                display: flex;
            }

            .controls-hint {
                display: none;
            }

            .camera-controls {
                display: none;
            }

            #gameHeader {
                padding: 0.75rem 1rem;
            }

            .action-buttons {
                display: none;
            }
            
            .top-info-panel {
                top: 10px;
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 480px) {
            #gameHeader { 
                padding: 0.5rem; 
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            #gameTitle { 
                font-size: 1rem; 
            }

            #onlineCount {
                font-size: 0.8rem;
            }

            .login-box {
                padding: 1.5rem;
                width: 95%;
            }

            .login-box h1 {
                font-size: 1.5rem;
            }

            #leftSidebar, #rightSidebar {
                width: 90vw;
                max-width: 300px;
            }

            .joystick-container {
                width: 100px;
                height: 100px;
            }

            .joystick-knob {
                width: 40px;
                height: 40px;
            }

            .mobile-action-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            #mobileControls {
                bottom: 60px;
                left: 15px;
            }

            #mobileActionButtons {
                bottom: 60px;
                right: 15px;
            }
            
            .top-info-panel {
                top: 5px;
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
                gap: 0.5rem;
            }
            
            .logout-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
            }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 3000;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen">
        <div class="login-box">
            <h1>⚔️ FantasyQuest 3D MORPG</h1>
            
            <!-- Home Button -->
            <a href="index.html" class="home-btn">
                ← Back to Home
            </a>
            
            <!-- Tab Navigation -->
            <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                <button id="loginTab" class="auth-tab active" onclick="showLoginTab()" style="flex: 1; padding: 0.75rem; border: none; background: #667eea; color: white; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Login
                </button>
                <button id="signupTab" class="auth-tab" onclick="showSignupTab()" style="flex: 1; padding: 0.75rem; border: none; background: #ddd; color: #666; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Sign Up
                </button>
            </div>
            
            <!-- Login Form -->
            <div id="loginForm">
                <p style="color: #666; margin-bottom: 1rem;">Login to your account</p>
                <input type="email" id="loginEmail" placeholder="Email address" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="password" id="loginPassword" placeholder="Password" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <button onclick="loginWithEmail()" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; margin-bottom: 0.75rem;">
                    Login
                </button>
                <div style="text-align: center; margin: 1rem 0; color: #999;">or</div>
                <button onclick="loginWithGoogle()" style="width: 100%; padding: 1rem; background: white; color: #333; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                </button>
            </div>
            
            <!-- Signup Form -->
            <div id="signupForm" style="display: none;">
                <p style="color: #666; margin-bottom: 1rem;">Create a new account</p>
                <input type="text" id="signupCharacterName" placeholder="Character name" maxlength="20" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="email" id="signupEmail" placeholder="Email address" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="password" id="signupPassword" placeholder="Password (min 6 characters)" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="password" id="signupPasswordConfirm" placeholder="Confirm password" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <button onclick="signupWithEmail()" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; margin-bottom: 0.75rem;">
                    Create Account
                </button>
                <div style="text-align: center; margin: 1rem 0; color: #999;">or</div>
                <button onclick="loginWithGoogle()" style="width: 100%; padding: 1rem; background: white; color: #333; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Sign up with Google
                </button>
            </div>
            
            <div id="authError" style="margin-top: 1rem; padding: 0.75rem; background: #fee; color: #c00; border-radius: 5px; display: none; font-size: 0.9rem;"></div>
            <div id="authSuccess" style="margin-top: 1rem; padding: 0.75rem; background: #efe; color: #060; border-radius: 5px; display: none; font-size: 0.9rem;"></div>
            
            <p style="margin-top: 1rem; font-size: 0.8rem; color: #999;">Play with other players in real-time 3D!</p>
        </div>
    </div>

    <!-- Character Customization Screen -->
    <div id="customizationScreen">
        <div class="customization-box">
            <h2>🎨 Customize Your Character</h2>
            
            <!-- Character Preview -->
            <div class="character-preview" id="characterPreview">
                <div class="preview-character" id="previewCharacter"></div>
            </div>
            
            <!-- Skin Color -->
            <div class="customization-section">
                <h3>Skin Tone</h3>
                <div class="color-options">
                    <div class="color-option selected" style="background: #ffdbac;" data-color="0xffdbac" onclick="selectSkinColor(this, 0xffdbac)"></div>
                    <div class="color-option" style="background: #f1c27d;" data-color="0xf1c27d" onclick="selectSkinColor(this, 0xf1c27d)"></div>
                    <div class="color-option" style="background: #e0ac69;" data-color="0xe0ac69" onclick="selectSkinColor(this, 0xe0ac69)"></div>
                    <div class="color-option" style="background: #c68642;" data-color="0xc68642" onclick="selectSkinColor(this, 0xc68642)"></div>
                    <div class="color-option" style="background: #8d5524;" data-color="0x8d5524" onclick="selectSkinColor(this, 0x8d5524)"></div>
                </div>
            </div>
            
            <!-- Hair Color -->
            <div class="customization-section">
                <h3>Hair Color</h3>
                <div class="color-options">
                    <div class="color-option selected" style="background: #4a2511;" data-color="0x4a2511" onclick="selectHairColor(this, 0x4a2511)"></div>
                    <div class="color-option" style="background: #2c1608;" data-color="0x2c1608" onclick="selectHairColor(this, 0x2c1608)"></div>
                    <div class="color-option" style="background: #b58143;" data-color="0xb58143" onclick="selectHairColor(this, 0xb58143)"></div>
                    <div class="color-option" style="background: #daa520;" data-color="0xdaa520" onclick="selectHairColor(this, 0xdaa520)"></div>
                    <div class="color-option" style="background: #ff6347;" data-color="0xff6347" onclick="selectHairColor(this, 0xff6347)"></div>
                </div>
            </div>
            
            <!-- Outfit Color -->
            <div class="customization-section">
                <h3>Outfit Color</h3>
                <div class="color-options">
                    <div class="color-option selected" style="background: #3498db;" data-color="0x3498db" onclick="selectBodyColor(this, 0x3498db)"></div>
                    <div class="color-option" style="background: #e74c3c;" data-color="0xe74c3c" onclick="selectBodyColor(this, 0xe74c3c)"></div>
                    <div class="color-option" style="background: #2ecc71;" data-color="0x2ecc71" onclick="selectBodyColor(this, 0x2ecc71)"></div>
                    <div class="color-option" style="background: #f39c12;" data-color="0xf39c12" onclick="selectBodyColor(this, 0xf39c12)"></div>
                    <div class="color-option" style="background: #9b59b6;" data-color="0x9b59b6" onclick="selectBodyColor(this, 0x9b59b6)"></div>
                </div>
            </div>
            
            <!-- Pants Color -->
            <div class="customization-section">
                <h3>Pants Color</h3>
                <div class="color-options">
                    <div class="color-option selected" style="background: #2c3e50;" data-color="0x2c3e50" onclick="selectPantsColor(this, 0x2c3e50)"></div>
                    <div class="color-option" style="background: #34495e;" data-color="0x34495e" onclick="selectPantsColor(this, 0x34495e)"></div>
                    <div class="color-option" style="background: #7f8c8d;" data-color="0x7f8c8d" onclick="selectPantsColor(this, 0x7f8c8d)"></div>
                    <div class="color-option" style="background: #2c2c2c;" data-color="0x2c2c2c" onclick="selectPantsColor(this, 0x2c2c2c)"></div>
                    <div class="color-option" style="background: #16a085;" data-color="0x16a085" onclick="selectPantsColor(this, 0x16a085)"></div>
                </div>
            </div>
            
            <!-- Hair Style -->
            <div class="customization-section">
                <h3>Hair Style</h3>
                <div class="style-options">
                    <div class="style-option selected" data-style="short" onclick="selectHairStyle(this, 'short')">Short</div>
                    <div class="style-option" data-style="long" onclick="selectHairStyle(this, 'long')">Long</div>
                    <div class="style-option" data-style="spiky" onclick="selectHairStyle(this, 'spiky')">Spiky</div>
                </div>
            </div>
            
            <button class="customize-btn" onclick="finishCustomization()">Enter Game</button>
        </div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer" class="hidden">
        <!-- Sidebar Overlay -->
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebars()"></div>

        <!-- Toggle Buttons -->
        <button class="toggle-sidebar-btn" id="toggleLeft" onclick="toggleLeftSidebar()">📊</button>
        <button class="toggle-sidebar-btn" id="toggleRight" onclick="toggleRightSidebar()">💬</button>

        <!-- Left Sidebar -->
        <div id="leftSidebar">
            <div class="character-panel">
                <div class="character-name" id="playerName">Adventurer</div>
                <div class="stat-bar">
                    <div class="stat-label">Level: <span id="combatLevel">1</span> | 💰 <span id="goldCount">0</span></div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">HP</div>
                    <div class="progress-bar">
                        <div class="progress-fill hp-bar" id="hpBar" style="width: 100%">100/100</div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">MP</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="mpBar" style="width: 100%; background: linear-gradient(90deg, #3498db, #2980b9)">100/100</div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">XP</div>
                    <div class="progress-bar">
                        <div class="progress-fill xp-bar" id="xpBar" style="width: 0%">0/100</div>
                    </div>
                </div>
            </div>

            <div class="skills-panel">
                <h3 onclick="toggleStatsPanel()" style="margin-bottom: 0.5rem; color: #f39c12; cursor: pointer; user-select: none;">
                    <span id="statsToggle">▼</span> 📊 Stats
                </h3>
                <div id="statsContent">
                    <div class="skill-item">
                        <span class="skill-name">⚔️ Strength</span>
                        <span class="skill-level" id="strengthStat">10</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">🛡️ Defense</span>
                        <span class="skill-level" id="defenseStat">10</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">✨ Magic</span>
                        <span class="skill-level" id="magicStat">10</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">⚡ Speed</span>
                        <span class="skill-level" id="speedStat">10</span>
                    </div>
                </div>
            </div>

            <div class="skills-panel">
                <h3 onclick="toggleSkillsPanel()" style="margin-bottom: 0.5rem; color: #f39c12; cursor: pointer; user-select: none;">
                    <span id="skillsToggle">▼</span> ⚔️ Skills
                </h3>
                <div id="skillsContent">
                    <div class="skill-item">
                        <span class="skill-name">Combat</span>
                        <span class="skill-level" id="combatSkill">1</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">Mining</span>
                        <span class="skill-level" id="miningSkill">1</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">Woodcutting</span>
                        <span class="skill-level" id="woodcuttingSkill">1</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">Fishing</span>
                        <span class="skill-level" id="fishingSkill">1</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">Crafting</span>
                        <span class="skill-level" id="craftingSkill">1</span>
                    </div>
                    <div class="skill-item">
                        <span class="skill-name">Magic</span>
                        <span class="skill-level" id="magicSkill">1</span>
                    </div>
                </div>
            </div>

            <div class="inventory-panel">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">🎒 Equipment</h3>
                <button onclick="openEquipment()" style="width: 100%; padding: 0.75rem; margin-bottom: 0.5rem; background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    ⚔️ Manage Equipment
                </button>
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">🎒 Inventory</h3>
                <div class="inventory-grid" id="inventoryGrid"></div>
            </div>

            <div class="skills-panel">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">📜 Quests (<span id="questCount">0</span>)</h3>
                <div id="questList" style="max-height: 150px; overflow-y: auto;"></div>
            </div>
        </div>

        <!-- Center Game Area -->
        <div id="gameArea">
            <div id="gameHeader">
                <div>
                    <div id="gameTitle">⚔️ FantasyQuest</div>
                    <a href="index.html" style="color: #95a5a6; text-decoration: none; font-size: 0.9rem;">← Back to Home</a>
                </div>
            </div>
            
            <!-- Top-center info panel with logout and online count -->
            <div class="top-info-panel">
                <div id="onlineCount">🟢 0 players online</div>
                <button onclick="logoutUser()" class="logout-btn">
                    🚪 Logout
                </button>
            </div>
            
            <canvas id="renderCanvas"></canvas>
            <div class="controls-hint" style="display: none;">Click to Move • ← → Rotate Camera • ↑ ↓ Tilt Camera<br>Mouse Drag: Look Around • Scroll: Zoom • 1/2/3: Abilities</div>
            <div class="camera-controls" style="display: none;">
                Camera: ← → to rotate • ↑ ↓ to tilt • Mouse drag to look around
            </div>
            <div class="day-night-indicator">
                <span id="timeIcon">☀️</span>
                <span id="timeText">Day</span>
            </div>
            <canvas class="mini-map" id="miniMapCanvas" width="200" height="200"></canvas>
            <div class="compass" id="compassIndicator">N</div>
            
            <!-- Mobile Virtual Joystick -->
            <div id="mobileControls">
                <div class="joystick-container" id="joystickContainer">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>

            <!-- Mobile Action Buttons -->
            <div id="mobileActionButtons">
                <div class="mobile-action-btn" ontouchstart="attackNearestMonster()">⚔️</div>
                <div class="mobile-action-btn gather" ontouchstart="gatherResource()">⛏️</div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div id="rightSidebar">
            <div class="action-buttons">
                <button class="action-btn craft" onclick="openCraftingPanel()">🔨 Craft</button>
                <button class="action-btn" onclick="openShop()">🏪 Shop</button>
                <button class="action-btn" onclick="openQuestsPanel()">📜 Quests</button>
                <button class="action-btn" style="background: linear-gradient(135deg, #e74c3c, #c0392b);" onclick="openEmoteMenu()">😊 Emote</button>
                <button class="action-btn" style="background: linear-gradient(135deg, #3498db, #2980b9);" onclick="openControlsPanel()">🎮 Controls</button>
            </div>
            
            <div style="padding: 1rem; border-top: 1px solid #34495e; border-bottom: 1px solid #34495e;">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12; font-size: 0.9rem;">⚡ Abilities</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <button class="action-btn" style="padding: 0.5rem; font-size: 0.8rem;" onclick="useAbility('fireball')" id="fireballBtn">
                        🔥 Fireball<br><span style="font-size: 0.7rem;">20 MP</span>
                    </button>
                    <button class="action-btn craft" style="padding: 0.5rem; font-size: 0.8rem;" onclick="useAbility('heal')" id="healBtn">
                        💚 Heal<br><span style="font-size: 0.7rem;">15 MP</span>
                    </button>
                    <button class="action-btn" style="padding: 0.5rem; font-size: 0.8rem; background: linear-gradient(135deg, #9b59b6, #8e44ad);" onclick="useAbility('lightning')" id="lightningBtn">
                        ⚡ Lightning<br><span style="font-size: 0.7rem;">35 MP</span>
                    </button>
                    <button class="action-btn quest" style="padding: 0.5rem; font-size: 0.8rem;" onclick="openAchievements()">
                        🏆 Achievements
                    </button>
                </div>
            </div>
            
            <div id="chatArea"></div>
            
            <div id="chatInput">
                <input type="text" id="messageInput" placeholder="Type a message..." maxlength="200">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <!-- Quest Panel -->
    <div class="quest-panel" id="questPanel">
        <button class="close-panel-btn" onclick="toggleQuestPanel()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">📜 Available Quests</h2>
        <div id="availableQuests"></div>
        <h3 style="color: #2ecc71; margin-top: 1.5rem; margin-bottom: 0.5rem;">✅ Active Quests</h3>
        <div id="activeQuestsPanel"></div>
    </div>

    <!-- Shop Panel -->
    <div class="quest-panel" id="shopPanel">
        <button class="close-panel-btn" onclick="closeShop()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">🏪 Equipment Shop</h2>
        <div style="text-align: center; margin-bottom: 1rem; font-size: 1.2rem;">
            Your Gold: 💰 <span id="shopGold">0</span>
        </div>
        <div id="shopItems"></div>
    </div>

    <!-- Achievements Panel -->
    <div class="quest-panel" id="achievementsPanel">
        <button class="close-panel-btn" onclick="closeAchievements()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">🏆 Achievements</h2>
        <div id="achievementsList"></div>
    </div>

    <!-- Crafting Panel -->
    <div class="quest-panel" id="craftingPanel">
        <button class="close-panel-btn" onclick="closeCraftingPanel()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">🔨 Crafting Station</h2>
        <div style="text-align: center; margin-bottom: 1rem;">
            <span style="color: #3498db;">Crafting Level: <span id="craftingLevel">1</span></span>
        </div>
        <div id="craftingRecipes"></div>
    </div>

    <!-- Pet Shop Panel -->
    <div class="quest-panel" id="petShopPanel">
        <button class="close-panel-btn" onclick="closePetShop()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">🐾 Pet Shop & Management</h2>
        <div style="text-align: center; margin-bottom: 1rem; font-size: 1.2rem;">
            Your Gold: 💰 <span id="petShopGold">0</span>
        </div>
        <div id="currentPet" style="margin-bottom: 1rem; padding: 1rem; background: rgba(46, 204, 113, 0.2); border-radius: 10px; text-align: center;">
            Current Pet: <span id="activePet">None</span>
            <br>
            <button class="action-btn" onclick="respawnPet()" style="margin-top: 0.5rem; padding: 0.4rem 1rem;">🔄 Respawn Pet</button>
        </div>
        <div id="petShopItems"></div>
    </div>

    <!-- Quests Panel -->
    <div class="quest-panel" id="questsPanel" style="max-width: 700px;">
        <button class="close-panel-btn" onclick="closeQuestsPanel()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">📜 Quest Journal</h2>
        
        <div style="margin-bottom: 1.5rem;">
            <h3 style="color: #2ecc71; margin-bottom: 0.5rem;">🔥 Active Quests</h3>
            <div id="activeQuestsList" style="margin-bottom: 1rem;"></div>
        </div>
        
        <div style="margin-bottom: 1.5rem;">
            <h3 style="color: #3498db; margin-bottom: 0.5rem;">📖 Available Quests</h3>
            <div id="availableQuestsList"></div>
        </div>
        
        <div>
            <h3 style="color: #95a5a6; margin-bottom: 0.5rem;">✅ Completed Quests</h3>
            <div id="completedQuestsList"></div>
        </div>
    </div>

    <!-- Quest Details Modal -->
    <div class="quest-panel" id="questDetailsPanel" style="max-width: 600px; display: none;">
        <button class="close-panel-btn" onclick="closeQuestDetails()">×</button>
        <h2 id="questDetailsTitle" style="color: #f39c12; margin-bottom: 1rem;"></h2>
        <div id="questDetailsContent"></div>
    </div>

    <!-- Emote Menu -->
    <div class="quest-panel" id="emotePanel" style="max-width: 400px;">
        <button class="close-panel-btn" onclick="closeEmoteMenu()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">😊 Emotes</h2>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;" id="emoteGrid"></div>
    </div>
    
    <!-- Bank Panel -->
    <div class="quest-panel" id="bankPanel">
        <button class="close-panel-btn" onclick="closeBank()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">🏦 Bank</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>
                <h3 style="color: #3498db; margin-bottom: 0.5rem;">🎒 Inventory</h3>
                <div id="bankInventoryGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; max-height: 400px; overflow-y: auto;"></div>
            </div>
            <div>
                <h3 style="color: #2ecc71; margin-bottom: 0.5rem;">💼 Bank Storage</h3>
                <div id="bankStorageGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; max-height: 400px; overflow-y: auto;"></div>
            </div>
        </div>
    </div>
    
    <!-- Equipment Panel (RuneScape style) -->
    <!-- Controls Panel -->
    <div class="quest-panel" id="controlsPanel">
        <button class="close-panel-btn" onclick="closeControlsPanel()">×</button>
        <h2 style="color: #3498db; margin-bottom: 1rem;">🎮 Controls</h2>
        <div style="background: rgba(0,0,0,0.2); padding: 1.5rem; border-radius: 10px; line-height: 2;">
            <h3 style="color: #f39c12; margin-bottom: 0.5rem;">🖱️ Mouse Controls:</h3>
            <p>• <strong>Click on Ground:</strong> Move to location</p>
            <p>• <strong>Click on NPC/Monster/Resource:</strong> Interact</p>
            <p>• <strong>Mouse Drag:</strong> Rotate camera</p>
            <p>• <strong>Mouse Scroll:</strong> Zoom in/out</p>
            <br>
            <h3 style="color: #f39c12; margin-bottom: 0.5rem;">⌨️ Keyboard Controls:</h3>
            <p>• <strong>W/A/S/D or Arrow Keys:</strong> Move character</p>
            <p>• <strong>← →:</strong> Rotate camera left/right</p>
            <p>• <strong>↑:</strong> Tilt camera down (show more ground)</p>
            <p>• <strong>↓:</strong> Tilt camera up (show more sky)</p>
            <p>• <strong>1/2/3:</strong> Use abilities</p>
            <br>
            <h3 style="color: #f39c12; margin-bottom: 0.5rem;">📱 Mobile Controls:</h3>
            <p>• <strong>Joystick (Bottom Left):</strong> Move character</p>
            <p>• <strong>Tap on Ground:</strong> Move to location</p>
            <p>• <strong>Action Buttons (Bottom Right):</strong> Attack/Gather</p>
        </div>
    </div>

    <div class="quest-panel" id="equipmentPanel">
        <button class="close-panel-btn" onclick="closeEquipment()">×</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">⚔️ Equipment</h2>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
            <div>
                <h3 style="color: #e74c3c; margin-bottom: 0.5rem;">Worn Equipment</h3>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                    <div></div>
                    <div class="equipment-slot" onclick="unequipItem('head')" style="aspect-ratio: 1; background: rgba(0,0,0,0.3); border: 2px solid #555; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 2rem;" id="equipSlotHead">⛑️</div>
                    <div></div>
                    <div class="equipment-slot" onclick="unequipItem('weapon')" style="aspect-ratio: 1; background: rgba(0,0,0,0.3); border: 2px solid #555; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 2rem;" id="equipSlotWeapon">🗡️</div>
                    <div class="equipment-slot" onclick="unequipItem('body')" style="aspect-ratio: 1; background: rgba(0,0,0,0.3); border: 2px solid #555; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 2rem;" id="equipSlotBody">🛡️</div>
                    <div class="equipment-slot" onclick="unequipItem('offhand')" style="aspect-ratio: 1; background: rgba(0,0,0,0.3); border: 2px solid #555; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 2rem;" id="equipSlotOffhand">🛡️</div>
                    <div></div>
                    <div class="equipment-slot" onclick="unequipItem('feet')" style="aspect-ratio: 1; background: rgba(0,0,0,0.3); border: 2px solid #555; border-radius: 5px; display: flex; align-items: center; justify-content: center; cursor: pointer; font-size: 2rem;" id="equipSlotFeet">👢</div>
                    <div></div>
                </div>
                <div style="margin-top: 1rem; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 5px;">
                    <div>⚔️ Damage: <span id="totalDamage">0</span></div>
                    <div>🛡️ Defense: <span id="totalDefense">0</span></div>
                </div>
            </div>
            <div>
                <h3 style="color: #3498db; margin-bottom: 0.5rem;">Inventory</h3>
                <div id="equipmentInventoryGrid" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; max-height: 400px; overflow-y: auto;"></div>
            </div>
        </div>
    </div>

    <!-- Weather Indicator -->
    <div id="weatherIndicator" style="position: fixed; top: 120px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.5); padding: 0.5rem 1rem; border-radius: 20px; display: flex; align-items: center; gap: 0.5rem; z-index: 100;">
        <span id="weatherIcon">☀️</span>
        <span id="weatherText">Clear</span>
    </div>

    <!-- Active Buffs Display -->
    <div id="buffsContainer" style="position: fixed; top: 170px; left: 50%; transform: translateX(-50%); display: flex; gap: 0.5rem; z-index: 100;"></div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCqMqav_HFKid6XdmbnfhG5llgCMZoYQV0",
            authDomain: "fantasyquest-mmorpg.firebaseapp.com",
            databaseURL: "https://fantasyquest-mmorpg-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "fantasyquest-mmorpg",
            storageBucket: "fantasyquest-mmorpg.firebasestorage.app",
            messagingSenderId: "149888279159",
            appId: "1:149888279159:web:48a53797f0c57f3a671c72",
            measurementId: "G-4R4YVKSRSE"
        };

        // Global variables for Firebase (declared early)
        var database = null;
        var auth = null;

        // Initialize Firebase when ready
        function initFirebase() {
            try {
                if (typeof firebase === 'undefined') {
                    console.log('Firebase SDK not loaded yet, retrying...');
                    setTimeout(initFirebase, 100); // Retry after 100ms
                    return;
                }
                
                // Check if already initialized
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                    console.log('Firebase initialized successfully!');
                } else {
                    console.log('Firebase already initialized');
                }
                
                database = firebase.database();
                auth = firebase.auth();
                console.log('Firebase services ready!');
                
                // Setup auth state listener after initialization
                setupAuthListener();
            } catch (error) {
                console.error('Firebase initialization error:', error);
                // Don't alert immediately, retry a few times
                if (!window.firebaseRetryCount) window.firebaseRetryCount = 0;
                window.firebaseRetryCount++;
                
                if (window.firebaseRetryCount < 10) {
                    console.log('Retrying Firebase initialization...');
                    setTimeout(initFirebase, 200);
                } else {
                    alert('Failed to connect to Firebase. Please refresh the page.');
                }
            }
        }

        // Call initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initFirebase);
        } else {
            initFirebase();
        }
        
        // ========== FIREBASE AUTHENTICATION SYSTEM ==========
        
        let currentUser = null; // Firebase user object
        let userProfileRef = null; // Database reference for user profile

        // Three.js variables
        let scene, camera, renderer, canvas;
        let playerMesh, playerMeshes = {};
        let monsterMeshes = [];
        let resourceMeshes = [];
        let groundMesh;
        let raycaster, mouse;
        let cameraAngle = Math.PI / 4; // 45 degrees (horizontal rotation)
        let cameraPitch = 0.5; // Vertical tilt (0 = looking straight ahead, positive = looking down)
        let cameraDistance = 25;
        let cameraHeight = 15;
        let isMouseDown = false;
        let mouseStartX = 0;
        
        // Camera pitch limits (in radians)
        const MIN_PITCH = -0.8; // Looking up (more sky)
        const MAX_PITCH = 1.2; // Looking down (more ground)

        // Game State
        let currentPlayer = {
            id: null,
            name: '',
            x: 0,
            y: 0,
            z: 0,
            rotation: 0,
            moving: false,
            hp: 100,
            maxHp: 100,
            mp: 100, // NEW: Magic points
            maxMp: 100,
            xp: 0,
            level: 1,
            gold: 0, // NEW: Currency
            skills: {
                combat: 1,
                mining: 1,
                woodcutting: 1,
                fishing: 1,
                crafting: 1,
                magic: 1 // NEW: Magic skill
            },
            stats: { // NEW: Character stats
                strength: 10,
                defense: 10,
                magic: 10,
                speed: 10
            },
            equipment: { // NEW: Equipment slots
                weapon: null,
                armor: null,
                helmet: null,
                boots: null
            },
            appearance: { // NEW: Character customization
                skinColor: 0xffdbac,
                hairColor: 0x4a2511,
                bodyColor: 0x3498db,
                pantsColor: 0x2c3e50,
                hairStyle: 'short'
            },
            inventory: {
                'Wooden Sword': 1,
                'Leather Armor': 1,
                'Bronze Axe': 1,
                'Bronze Pickaxe': 1
            },
            quests: { // NEW: Quest tracking
                active: [],
                completed: []
            },
            achievements: [], // NEW: Achievements
            abilities: { // NEW: Combat abilities
                fireball: { cooldown: 0, maxCooldown: 5000, damage: 25, mpCost: 20 },
                heal: { cooldown: 0, maxCooldown: 8000, healing: 30, mpCost: 15 },
                lightning: { cooldown: 0, maxCooldown: 10000, damage: 50, mpCost: 35 }
            },
            pet: null, // NEW: Pet companion
            buffs: [], // NEW: Active buffs
            emote: null, // NEW: Current emote
            craftedItems: 0 // NEW: Crafting counter
        };

        let players = {};
        let monsters = [];
        let resources = [];
        let npcs = []; // NEW: NPCs
        let lootItems = []; // NEW: Dropped loot
        let particles = []; // NEW: Visual effects
        let playersRef, chatRef;
        let keys = {};
        
        // Mobile controls
        let joystickActive = false;
        let joystickDirection = { x: 0, y: 0 };
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // NEW CREATIVE FEATURES
        let playerPet = null; // Pet companion
        let petMesh = null;
        let currentWeather = 'clear'; // Weather system
        let weatherParticles = [];
        let activeBuffs = []; // Buff/debuff system
        let bossMonsters = []; // Special boss spawns
        let chatMessageCount = 0; // For achievements
        let totalDistanceTraveled = 0; // For achievements
        let lastPlayerPos = { x: 0, z: 0 };
        let equippedWeaponMesh = null; // Visual weapon mesh
        let targetMonster = null; // Monster being walked to
        let targetResource = null; // Resource being walked to
        let targetPosition = null; // Position being walked to (click-to-move)
        let pathToTarget = []; // A* pathfinding waypoints
        let isAttacking = false; // Continuous attack state
        let isGathering = false; // Continuous gathering state
        let attackCooldown = 0; // Attack cooldown timer
        let gatheringCooldown = 0; // Gathering cooldown timer
        let playerAnimationState = 'idle'; // Current animation: idle, walking, attacking, gathering
        let animationFrame = 0; // Animation frame counter
        let houses = []; // House structures
        let houseMeshes = []; // House 3D meshes
        let npcData = []; // NPC data
        let npcMeshes = []; // NPC 3D meshes
        let currentQuestStep = {}; // Track progress in multi-step quests
        let playerInsideHouse = false; // Track if player is inside a house
        let bankStorage = {}; // Bank storage for items
        let pvpEnabled = false; // PVP combat enabled
        let targetPlayer = null; // Player being attacked in PVP
        let worldDecorations = []; // Decorative world elements
        
        // PVP Area Definition
        const PVP_AREA = {
            x: 60,
            z: -60,
            width: 40,
            depth: 40,
            name: 'Wilderness'
        };
        
        // Increased interaction radius
        const INTERACTION_RADIUS = {
            npc: 8,        // Increased from 4
            monster: 10,   // Increased from 5
            resource: 6,   // Increased from 3
            player: 10     // For PVP
        };
        
        // House Definitions with door positions (defined first for NPC positioning)
        const HOUSES = [
            { x: -15, z: 5, width: 8, depth: 8, height: 6, color: 0x8b4513, name: 'Elder\'s Home', doorZ: 'front', hasDesk: false },
            { x: 20, z: -20, width: 10, depth: 8, height: 7, color: 0x696969, name: 'Blacksmith', doorZ: 'front', hasDesk: true },
            { x: -25, z: -15, width: 7, depth: 7, height: 5, color: 0xffd700, name: 'Bank', doorZ: 'front', hasDesk: true },
            { x: -20, z: 25, width: 7, depth: 7, height: 5, color: 0x9370db, name: 'Pet Shop', doorZ: 'front', hasDesk: true },
            { x: 30, z: 10, width: 6, depth: 6, height: 5, color: 0x8fbc8f, name: 'Farm House', doorZ: 'front', hasDesk: false },
            { x: -5, z: -35, width: 9, depth: 7, height: 6, color: 0x4682b4, name: 'Guard House', doorZ: 'front', hasDesk: false },
            { x: 35, z: -35, width: 8, depth: 8, height: 7, color: 0x9400d3, name: 'Wizard Tower', doorZ: 'front', hasDesk: false },
            { x: -35, z: -35, width: 7, depth: 7, height: 6, color: 0xcd853f, name: 'Library', doorZ: 'front', hasDesk: false },
            { x: 0, z: 45, width: 15, depth: 12, height: 10, color: 0xffd700, name: 'Royal Palace', doorZ: 'front', hasDesk: false },
            { x: -40, z: 10, width: 6, depth: 6, height: 5, color: 0x20b2aa, name: 'Fishing Hut', doorZ: 'front', hasDesk: false }
        ];
        
        // NPC Definitions - positioned inside houses with desks for functional NPCs
        // Each quest NPC has one unique quest assigned
        const NPCS = [
            { id: 'elder_marcus', name: 'Elder Marcus', x: -15, z: 3, type: 'quest', color: 0x8b4513, dialogue: 'Welcome, young adventurer!', questId: 'welcome_adventurer' },
            { id: 'blacksmith_gareth', name: 'Blacksmith Gareth', x: 20, z: -21, type: 'shop', color: 0x696969, dialogue: 'Looking for quality equipment?', hasDesk: true },
            { id: 'banker', name: 'Banker', x: -25, z: -16, type: 'bank', color: 0xffd700, dialogue: 'Welcome to the bank!', hasDesk: true },
            { id: 'pet_master', name: 'Pet Master Luna', x: -20, z: 24, type: 'pet', color: 0x9370db, dialogue: 'Want a loyal companion?', hasDesk: true },
            { id: 'farmer_jane', name: 'Farmer Jane', x: 30, z: 9, type: 'quest', color: 0xdaa520, dialogue: 'Can you help me with my farm?', questId: 'the_lost_pet' },
            { id: 'guard_captain', name: 'Guard Captain', x: -5, z: -36, type: 'quest', color: 0x4169e1, dialogue: 'The village needs defenders!', questId: 'defend_the_village' },
            { id: 'fisherman_bob', name: 'Fisherman Bob', x: -40, z: 9, type: 'quest', color: 0x20b2aa, dialogue: 'Fish are biting today!', questId: 'fishing_master' },
            { id: 'wizard_aldrin', name: 'Wizard Aldrin', x: 35, z: -36, type: 'quest', color: 0x9400d3, dialogue: 'The arcane arts await...', questId: 'magical_mysteries' },
            { id: 'scholar_elena', name: 'Scholar Elena', x: -35, z: -36, type: 'quest', color: 0xcd853f, dialogue: 'Knowledge is power!', questId: 'lost_knowledge' },
            { id: 'king_aldric', name: 'King Aldric', x: 0, z: 43, type: 'quest', color: 0xffd700, dialogue: 'The kingdom needs a hero!', questId: 'royal_decree' }
        ];

        // Constants
        const PLAYER_SPEED = 0.15;
        const MAP_SIZE = 1000;  // Large explorable world (reduced from 5000 for stability)
        
        // NEW: Equipment Database with icons
        const EQUIPMENT = {
            weapons: {
                'Wooden Sword': { damage: 5, value: 10, level: 1, icon: '🗡️', type: 'weapon', slot: 'weapon' },
                'Iron Sword': { damage: 10, value: 50, level: 5, icon: '⚔️', type: 'weapon', slot: 'weapon' },
                'Steel Sword': { damage: 20, value: 150, level: 10, icon: '🗡️', type: 'weapon', slot: 'weapon' },
                'Dragon Sword': { damage: 40, value: 500, level: 20, icon: '⚔️', type: 'weapon', slot: 'weapon' },
                'Magic Staff': { damage: 15, magic: 25, value: 200, level: 10, icon: '🪄', type: 'weapon', slot: 'weapon' }
            },
            armor: {
                'Leather Armor': { defense: 5, value: 15, level: 1, icon: '🥼', type: 'armor', slot: 'body' },
                'Iron Armor': { defense: 15, value: 80, level: 5, icon: '🛡️', type: 'armor', slot: 'body' },
                'Steel Armor': { defense: 30, value: 250, level: 10, icon: '🦺', type: 'armor', slot: 'body' },
                'Dragon Armor': { defense: 60, value: 800, level: 20, icon: '🛡️', type: 'armor', slot: 'body' }
            },
            helmets: {
                'Leather Cap': { defense: 2, value: 8, level: 1, icon: '🧢', type: 'helmet', slot: 'head' },
                'Iron Helmet': { defense: 8, value: 40, level: 5, icon: '⛑️', type: 'helmet', slot: 'head' },
                'Steel Helmet': { defense: 15, value: 120, level: 10, icon: '⛑️', type: 'helmet', slot: 'head' }
            },
            boots: {
                'Leather Boots': { speed: 2, value: 10, level: 1, icon: '👢', type: 'boots', slot: 'feet' },
                'Iron Boots': { defense: 5, speed: 3, value: 50, level: 5, icon: '🥾', type: 'boots', slot: 'feet' },
                'Dragon Boots': { defense: 10, speed: 5, value: 200, level: 10, icon: '👢', type: 'boots', slot: 'feet' }
            },
            tools: {
                'Bronze Axe': { bonus: 1, value: 5, level: 1, icon: '🪓', type: 'tool', skill: 'woodcutting' },
                'Iron Axe': { bonus: 3, value: 25, level: 5, icon: '🪓', type: 'tool', skill: 'woodcutting' },
                'Steel Axe': { bonus: 5, value: 100, level: 10, icon: '🪓', type: 'tool', skill: 'woodcutting' },
                'Bronze Pickaxe': { bonus: 1, value: 5, level: 1, icon: '⛏️', type: 'tool', skill: 'mining' },
                'Iron Pickaxe': { bonus: 3, value: 25, level: 5, icon: '⛏️', type: 'tool', skill: 'mining' },
                'Steel Pickaxe': { bonus: 5, value: 100, level: 10, icon: '⛏️', type: 'tool', skill: 'mining' }
            }
        };
        
        // NEW: Quest Database with Creative Multi-Step Quests
        const QUESTS = [
            // Beginner Quests
            { 
                id: 'welcome_adventurer',
                name: '🌟 Welcome, Adventurer!',
                description: 'Elder Marcus needs your help getting started. Talk to him to begin your journey!',
                npc: 'Elder Marcus',
                steps: [
                    { type: 'talk', target: 'Elder Marcus', text: 'Learn the basics from Elder Marcus' },
                    { type: 'gather', target: 'Logs', count: 3, text: 'Gather 3 Logs from Normal Trees' },
                    { type: 'kill', target: 'any', count: 2, text: 'Defeat 2 monsters to prove your strength' }
                ],
                reward: { xp: 100, gold: 50, item: 'Iron Sword' },
                level: 1,
                story: "Welcome to FantasyQuest! I'm Elder Marcus, and I'll guide you on your journey. First, let me teach you the basics of survival..."
            },
            {
                id: 'the_lost_pet',
                name: '🐕 The Lost Pet',
                description: 'Farmer Jane lost her beloved pet. Help her find it!',
                npc: 'Farmer Jane',
                steps: [
                    { type: 'talk', target: 'Farmer Jane', text: 'Talk to Farmer Jane about her lost pet' },
                    { type: 'explore', x: 30, z: -20, range: 5, text: 'Search the forest area (30, -20)' },
                    { type: 'kill', target: 'Wolf', count: 3, text: 'Defeat 3 Wolves blocking the way' },
                    { type: 'talk', target: 'Farmer Jane', text: 'Return to Farmer Jane with good news' }
                ],
                reward: { xp: 200, gold: 100, pet: 'Wolf Pup' },
                level: 1,
                story: "My dear pet ran into the forest and wolves have taken over that area! Please help me get him back safely."
            },
            {
                id: 'mysterious_ore',
                name: '⛏️ The Mysterious Ore',
                description: 'Blacksmith Gareth needs rare materials for a special project.',
                npc: 'Blacksmith Gareth',
                steps: [
                    { type: 'talk', target: 'Blacksmith Gareth', text: 'Speak with Blacksmith Gareth' },
                    { type: 'gather', target: 'Ore', count: 10, text: 'Mine 10 Ore from rocks' },
                    { type: 'gather', target: 'Wood', count: 5, text: 'Gather 5 Wood' },
                    { type: 'craft', target: 'Iron Sword', count: 1, text: 'Craft an Iron Sword' }
                ],
                reward: { xp: 250, gold: 150 },
                level: 3,
                story: "I've discovered a technique to forge stronger weapons, but I need your help gathering materials!"
            },
            
            // Intermediate Quests
            {
                id: 'bandits_threat',
                name: '⚔️ Bandit Threat',
                description: 'A group of bandits is terrorizing the village. Clear them out!',
                npc: 'Guard Captain',
                steps: [
                    { type: 'talk', target: 'Guard Captain', text: 'Get briefing from Guard Captain' },
                    { type: 'kill', target: 'Goblin', count: 5, text: 'Defeat 5 Goblins' },
                    { type: 'kill', target: 'Orc', count: 3, text: 'Defeat 3 Orcs' },
                    { type: 'explore', x: -40, z: 30, range: 10, text: 'Clear the bandit camp (-40, 30)' },
                    { type: 'talk', target: 'Guard Captain', text: 'Report back to Guard Captain' }
                ],
                reward: { xp: 500, gold: 300, item: 'Steel Armor' },
                level: 8,
                story: "Bandits have set up camp near the village. We need someone brave enough to deal with them!"
            },
            {
                id: 'fishing_contest',
                name: '🎣 The Great Fishing Contest',
                description: 'Prove you\'re the best fisher in the land!',
                npc: 'Fisherman Bob',
                steps: [
                    { type: 'talk', target: 'Fisherman Bob', text: 'Enter the fishing contest' },
                    { type: 'gather', target: 'Fish', count: 20, text: 'Catch 20 Fish' },
                    { type: 'talk', target: 'Fisherman Bob', text: 'Show your catch to Fisherman Bob' }
                ],
                reward: { xp: 300, gold: 200 },
                level: 5,
                story: "Think you're a good fisher? Prove it! Catch more fish than anyone else and win a prize!"
            },
            {
                id: 'magical_research',
                name: '🔮 Magical Research',
                description: 'Help the wizard with his arcane experiments.',
                npc: 'Wizard Aldrin',
                steps: [
                    { type: 'talk', target: 'Wizard Aldrin', text: 'Speak with Wizard Aldrin' },
                    { type: 'kill', target: 'Slime', count: 10, text: 'Collect essence from 10 Slimes' },
                    { type: 'craft', target: 'Mana Potion', count: 3, text: 'Craft 3 Mana Potions' },
                    { type: 'explore', x: 50, z: 50, range: 5, text: 'Study the magical ley line (50, 50)' }
                ],
                reward: { xp: 400, gold: 250, item: 'Magic Staff' },
                level: 7,
                story: "I'm studying the magical energies of this realm. Your help could lead to groundbreaking discoveries!"
            },
            
            // Advanced Quests
            {
                id: 'dragon_menace',
                name: '🐉 The Dragon Menace',
                description: 'An ancient dragon threatens the entire kingdom!',
                npc: 'King Aldric',
                steps: [
                    { type: 'talk', target: 'King Aldric', text: 'Receive the king\'s quest' },
                    { type: 'gather', target: 'Ore', count: 30, text: 'Gather 30 Ore for dragon-proof armor' },
                    { type: 'craft', target: 'Dragon Armor', count: 1, text: 'Forge Dragon Armor' },
                    { type: 'kill', target: 'Dragon', count: 1, text: 'Slay the Dragon!' },
                    { type: 'talk', target: 'King Aldric', text: 'Report your victory to the king' }
                ],
                reward: { xp: 2000, gold: 1000, item: 'Dragon Sword' },
                level: 15,
                story: "A fearsome dragon has awakened! Only the bravest hero can save our kingdom from destruction."
            },
            {
                id: 'artifact_hunt',
                name: '🏺 The Ancient Artifact',
                description: 'Seek out a legendary artifact hidden in dangerous lands.',
                npc: 'Scholar Elena',
                steps: [
                    { type: 'talk', target: 'Scholar Elena', text: 'Learn about the artifact' },
                    { type: 'explore', x: -60, z: -60, range: 5, text: 'Search the ancient ruins (-60, -60)' },
                    { type: 'kill', target: 'any', count: 15, text: 'Clear 15 guardians' },
                    { type: 'explore', x: 70, z: -50, range: 5, text: 'Find the hidden temple (70, -50)' },
                    { type: 'gather', target: 'Wood', count: 50, text: 'Gather 50 Wood to repair the bridge' }
                ],
                reward: { xp: 1500, gold: 800, pet: 'Phoenix' },
                level: 12,
                story: "Ancient texts speak of a powerful artifact. If we find it, it could change everything!"
            },
            {
                id: 'epic_journey',
                name: '⭐ The Epic Journey',
                description: 'Complete a series of legendary trials to become a hero.',
                npc: 'Elder Marcus',
                steps: [
                    { type: 'talk', target: 'Elder Marcus', text: 'Begin the trials' },
                    { type: 'kill', target: 'any', count: 50, text: 'Trial of Combat: Defeat 50 enemies' },
                    { type: 'gather', target: 'Wood', count: 30, text: 'Trial of Patience: Gather 30 Wood' },
                    { type: 'gather', target: 'Ore', count: 30, text: 'Trial of Strength: Mine 30 Ore' },
                    { type: 'gather', target: 'Fish', count: 30, text: 'Trial of Wisdom: Catch 30 Fish' },
                    { type: 'explore', x: 80, z: 80, range: 10, text: 'Trial of Courage: Reach the far lands (80, 80)' },
                    { type: 'talk', target: 'Elder Marcus', text: 'Complete your journey' }
                ],
                reward: { xp: 3000, gold: 2000, pet: 'Ice Dragon' },
                level: 18,
                story: "Only those who complete all trials can truly call themselves heroes of FantasyQuest!"
            }
        ];
        
        // NEW: Achievement Database
        const ACHIEVEMENTS = [
            { id: 'first_kill', name: 'First Blood', description: 'Defeat your first monster', icon: '⚔️' },
            { id: 'level_10', name: 'Veteran', description: 'Reach level 10', icon: '🎖️' },
            { id: 'rich', name: 'Wealthy', description: 'Collect 1000 gold', icon: '💰' },
            { id: 'master_gatherer', name: 'Master Gatherer', description: 'Gather 100 resources', icon: '🌲' },
            { id: 'dragon_slayer', name: 'Dragon Slayer', description: 'Defeat a Dragon', icon: '🐉' },
            { id: 'social', name: 'Social Butterfly', description: 'Chat 50 messages', icon: '💬' },
            { id: 'explorer', name: 'Explorer', description: 'Travel 1000 units', icon: '🗺️' }
        ];
        
        // NEW: Pet Database
        const PETS = {
            'Wolf Pup': { damage: 5, icon: '🐺', cost: 100, level: 1, description: 'A loyal wolf companion' },
            'Fire Spirit': { damage: 10, icon: '🔥', cost: 300, level: 5, description: 'A magical fire elemental' },
            'Ice Dragon': { damage: 20, icon: '🐉', cost: 1000, level: 15, description: 'A powerful dragon ally' },
            'Phoenix': { damage: 15, healing: 5, icon: '🦅', cost: 800, level: 12, description: 'Heals you in battle' }
        };
        
        // NEW: Crafting Recipes
        const CRAFTING_RECIPES = {
            'Wooden Sword': { materials: { Wood: 5 }, level: 1, craftingXP: 20 },
            'Leather Armor': { materials: { 'Fish': 10 }, level: 1, craftingXP: 25 },
            'Health Potion': { materials: { 'Fish': 3, 'Wood': 2 }, level: 1, craftingXP: 15 },
            'Mana Potion': { materials: { 'Ore': 3, 'Wood': 2 }, level: 3, craftingXP: 20 },
            'Iron Sword': { materials: { 'Ore': 10, 'Wood': 5 }, level: 5, craftingXP: 50 },
            'Steel Armor': { materials: { 'Ore': 20, 'Wood': 10 }, level: 10, craftingXP: 100 }
        };
        
        // NEW: Buff Database
        const BUFFS = {
            'strength': { name: 'Strength Boost', icon: '💪', duration: 30000, effect: { strength: 5 } },
            'defense': { name: 'Iron Skin', icon: '🛡️', duration: 30000, effect: { defense: 5 } },
            'speed': { name: 'Swift Feet', icon: '⚡', duration: 20000, effect: { speed: 5 } },
            'regen': { name: 'Regeneration', icon: '💚', duration: 60000, effect: { hpRegen: 1 } },
            'wisdom': { name: 'Arcane Wisdom', icon: '🔮', duration: 30000, effect: { magic: 10 } }
        };
        
        // NEW: Emotes
        const EMOTES = ['wave', 'dance', 'cheer', 'laugh', 'cry', 'angry', 'sleep', 'think'];
        
        // NEW: Weather types
        const WEATHER_TYPES = ['clear', 'rain', 'snow', 'fog', 'storm'];
        
        // NEW: Day/Night cycle
        let timeOfDay = 0; // 0-24 hours
        let dayNightSpeed = 0.01; // How fast time passes

        // Login
        // ========== AUTHENTICATION UI FUNCTIONS ==========
        
        function showLoginTab() {
            document.getElementById('loginTab').classList.add('active');
            document.getElementById('loginTab').style.background = '#667eea';
            document.getElementById('loginTab').style.color = 'white';
            document.getElementById('signupTab').classList.remove('active');
            document.getElementById('signupTab').style.background = '#ddd';
            document.getElementById('signupTab').style.color = '#666';
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('signupForm').style.display = 'none';
            hideAuthMessages();
        }
        
        function showSignupTab() {
            document.getElementById('signupTab').classList.aentById('signupTab').classList.add('active');
            document.getElementById('signupTab').style.background = '#667eea';
            document.getElementById('signupTab').style.color = 'white';
            document.getElementById('loginTab').classList.remove('active');
            document.getElementById('loginTab').style.background = '#ddd';
            document.getElementById('loginTab').style.color = '#666';
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'block';
            hideAuthMessages();
        }
        
        function showAuthError(message) {
            const errorDiv = document.getElementById('authError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('authSuccess').style.display = 'none';
        }
        
        function showAuthSuccess(message) {
            const successDiv = document.getElementById('authSuccess');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            document.getElementById('authError').style.display = 'none';
        }
        
        function hideAuthMessages() {
            document.getElementById('authError').style.display = 'none';
            document.getElementById('authSuccess').style.display = 'none';
        }
        
        // ========== FIREBASE AUTHENTICATION FUNCTIONS ==========
        
        // Login with Email/Password
        async function loginWithEmail() {
            // Check if Firebase is initialized
            if (!auth || !database) {
                showAuthError('Firebase not initialized yet. Please wait a moment and try again.');
                return;
            }
            
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showAuthError('Please enter both email and password');
                return;
            }
            
            try {
                showAuthSuccess('Logging in...');
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                // Auth state listener will handle the rest
            } catch (error) {
                console.error('Login error:', error);
                let errorMessage = 'Login failed: ';
                switch (error.code) {
                    case 'auth/user-not-found':
                        errorMessage += 'No account found with this email';
                        break;
                    case 'auth/wrong-password':
                        errorMessage += 'Incorrect password';
                        break;
                    case 'auth/invalid-email':
                        errorMessage += 'Invalid email address';
                        break;
                    case 'auth/user-disabled':
                        errorMessage += 'This account has been disabled';
                        break;
                    default:
                        errorMessage += error.message;
                }
                showAuthError(errorMessage);
            }
        }
        
        // Sign up with Email/Password
        async function signupWithEmail() {
            // Check if Firebase is initialized
            if (!auth || !database) {
                showAuthError('Firebase not initialized yet. Please wait a moment and try again.');
                return;
            }
            
            const characterName = document.getElementById('signupCharacterName').value.trim();
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;
            const passwordConfirm = document.getElementById('signupPasswordConfirm').value;
            
            // Validation
            if (!characterName || characterName.length < 3) {
                showAuthError('Character name must be at least 3 characters');
                return;
            }
            
            if (!email) {
                showAuthError('Please enter your email address');
                return;
            }
            
            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters');
                return;
            }
            
            if (password !== passwordConfirm) {
                showAuthError('Passwords do not match');
                return;
            }
            
            try {
                showAuthSuccess('Creating account...');
                
                // Create Firebase account
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Create initial profile in database
                await database.ref('user_profiles/' + user.uid).set({
                    name: characterName,
                    email: email,
                    level: 1,
                    gold: 0,
                    xp: 0,
                    hp: 100,
                    maxHp: 100,
                    mp: 100,
                    maxMp: 100,
                    skills: {
                        combat: 1,
                        mining: 1,
                        woodcutting: 1,
                        fishing: 1,
                        crafting: 1,
                        magic: 1
                    },
                    stats: {
                        strength: 10,
                        defense: 10,
                        magic: 10,
                        speed: 10
                    },
                    equipment: {
                        weapon: null,
                        armor: null,
                        helmet: null,
                        boots: null
                    },
                    inventory: {},
                    pet: null,
                    achievements: [],
                    quests: {
                        active: [],
                        completed: []
                    },
                    craftedItems: 0,
                    createdAt: Date.now()
                });
                
                showAuthSuccess('Account created! Logging in...');
                // Auth state listener will handle the rest
                
            } catch (error) {
                console.error('Signup error:', error);
                let errorMessage = 'Signup failed: ';
                switch (error.code) {
                    case 'auth/email-already-in-use':
                        errorMessage += 'This email is already registered';
                        break;
                    case 'auth/invalid-email':
                        errorMessage += 'Invalid email address';
                        break;
                    case 'auth/weak-password':
                        errorMessage += 'Password is too weak';
                        break;
                    default:
                        errorMessage += error.message;
                }
                showAuthError(errorMessage);
            }
        }
        
        // Login with Google
        async function loginWithGoogle() {
            // Check if Firebase is initialized
            if (!auth || !database) {
                showAuthError('Firebase not initialized yet. Please wait a moment and try again.');
                return;
            }
            
            try {
                showAuthSuccess('Opening Google sign-in...');
                const provider = new firebase.auth.GoogleAuthProvider();
                const result = await auth.signInWithPopup(provider);
                
                // Check if this is a new user
                const user = result.user;
                const profileSnapshot = await database.ref('user_profiles/' + user.uid).once('value');
                
                if (!profileSnapshot.exists()) {
                    // New Google user - create profile
                    const characterName = user.displayName || 'Hero';
                    await database.ref('user_profiles/' + user.uid).set({
                        name: characterName,
                        email: user.email,
                        level: 1,
                        gold: 0,
                        xp: 0,
                        hp: 100,
                        maxHp: 100,
                        mp: 100,
                        maxMp: 100,
                        skills: {
                            combat: 1,
                            mining: 1,
                            woodcutting: 1,
                            fishing: 1,
                            crafting: 1,
                            magic: 1
                        },
                        stats: {
                            strength: 10,
                            defense: 10,
                            magic: 10,
                            speed: 10
                        },
                        equipment: {
                            weapon: null,
                            armor: null,
                            helmet: null,
                            boots: null
                        },
                        inventory: {},
                        pet: null,
                        achievements: [],
                        quests: {
                            active: [],
                            completed: []
                        },
                        craftedItems: 0,
                        createdAt: Date.now()
                    });
                }
                
                // Auth state listener will handle the rest
                
            } catch (error) {
                console.error('Google login error:', error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    showAuthError('Google sign-in failed: ' + error.message);
                }
            }
        }
        
        // Logout
        async function logoutUser() {
            try {
                // Save game before logout
                await saveGameToCloud();
                
                // Remove player from online players
                if (currentPlayer.id && playersRef) {
                    await playersRef.child(currentPlayer.id).remove();
                }
                
                // Sign out
                await auth.signOut();
                
                // Reload page
                window.location.reload();
                
            } catch (error) {
                console.error('Logout error:', error);
                addChatMessage('System', 'Logout failed: ' + error.message, 'system');
            }
        }
        
        // ========== CHARACTER CUSTOMIZATION FUNCTIONS ==========
        
        let tempAppearance = {
            skinColor: 0xffdbac,
            hairColor: 0x4a2511,
            bodyColor: 0x3498db,
            pantsColor: 0x2c3e50,
            hairStyle: 'short'
        };
        
        function showCustomizationScreen() {
            document.getElementById('customizationScreen').classList.add('active');
            updateCharacterPreview();
        }
        
        function selectSkinColor(element, color) {
            document.querySelectorAll('[data-color]').forEach(el => {
                if (el.parentElement.parentElement.querySelector('h3').textContent === 'Skin Tone') {
                    el.classList.remove('selected');
                }
            });
            element.classList.add('selected');
            tempAppearance.skinColor = color;
            updateCharacterPreview();
        }
        
        function selectHairColor(element, color) {
            document.querySelectorAll('[data-color]').forEach(el => {
                if (el.parentElement.parentElement.querySelector('h3').textContent === 'Hair Color') {
                    el.classList.remove('selected');
                }
            });
            element.classList.add('selected');
            tempAppearance.hairColor = color;
            updateCharacterPreview();
        }
        
        function selectBodyColor(element, color) {
            document.querySelectorAll('[data-color]').forEach(el => {
                if (el.parentElement.parentElement.querySelector('h3').textContent === 'Outfit Color') {
                    el.classList.remove('selected');
                }
            });
            element.classList.add('selected');
            tempAppearance.bodyColor = color;
            updateCharacterPreview();
        }
        
        function selectPantsColor(element, color) {
            document.querySelectorAll('[data-color]').forEach(el => {
                if (el.parentElement.parentElement.querySelector('h3').textContent === 'Pants Color') {
                    el.classList.remove('selected');
                }
            });
            element.classList.add('selected');
            tempAppearance.pantsColor = color;
            updateCharacterPreview();
        }
        
        function selectHairStyle(element, style) {
            document.querySelectorAll('.style-option').forEach(el => el.classList.remove('selected'));
            element.classList.add('selected');
            tempAppearance.hairStyle = style;
            updateCharacterPreview();
        }
        
        function updateCharacterPreview() {
            const previewContainer = document.getElementById('previewCharacter');
            previewContainer.innerHTML = '';
            
            // Create mini character preview (simple HTML/CSS version)
            const character = document.createElement('div');
            character.style.position = 'relative';
            character.style.width = '60px';
            character.style.height = '100px';
            
            // Head
            const head = document.createElement('div');
            head.style.width = '25px';
            head.style.height = '25px';
            head.style.backgroundColor = '#' + tempAppearance.skinColor.toString(16).padStart(6, '0');
            head.style.position = 'absolute';
            head.style.top = '5px';
            head.style.left = '17.5px';
            head.style.border = '2px solid rgba(0,0,0,0.2)';
            character.appendChild(head);
            
            // Hair
            const hair = document.createElement('div');
            hair.style.backgroundColor = '#' + tempAppearance.hairColor.toString(16).padStart(6, '0');
            hair.style.position = 'absolute';
            hair.style.left = '16px';
            hair.style.border = '2px solid rgba(0,0,0,0.2)';
            if (tempAppearance.hairStyle === 'short') {
                hair.style.width = '29px';
                hair.style.height = '8px';
                hair.style.top = '3px';
            } else if (tempAppearance.hairStyle === 'long') {
                hair.style.width = '29px';
                hair.style.height = '15px';
                hair.style.top = '3px';
            } else if (tempAppearance.hairStyle === 'spiky') {
                hair.style.width = '29px';
                hair.style.height = '12px';
                hair.style.top = '0px';
                hair.style.clipPath = 'polygon(0% 100%, 10% 0%, 20% 100%, 30% 0%, 40% 100%, 50% 0%, 60% 100%, 70% 0%, 80% 100%, 90% 0%, 100% 100%)';
            }
            character.appendChild(hair);
            
            // Body
            const body = document.createElement('div');
            body.style.width = '30px';
            body.style.height = '35px';
            body.style.backgroundColor = '#' + tempAppearance.bodyColor.toString(16).padStart(6, '0');
            body.style.position = 'absolute';
            body.style.top = '30px';
            body.style.left = '15px';
            body.style.border = '2px solid rgba(0,0,0,0.2)';
            character.appendChild(body);
            
            // Pants
            const pants = document.createElement('div');
            pants.style.width = '30px';
            pants.style.height = '30px';
            pants.style.backgroundColor = '#' + tempAppearance.pantsColor.toString(16).padStart(6, '0');
            pants.style.position = 'absolute';
            pants.style.top = '65px';
            pants.style.left = '15px';
            pants.style.border = '2px solid rgba(0,0,0,0.2)';
            character.appendChild(pants);
            
            previewContainer.appendChild(character);
        }
        
        async function finishCustomization() {
            try {
                // Save appearance to current player
                currentPlayer.appearance = { ...tempAppearance };
                
                // Save appearance to Firebase
                const user = auth.currentUser;
                if (user) {
                    await database.ref('user_profiles/' + user.uid + '/appearance').set(tempAppearance);
                }
                
                // Hide customization screen and start game
                document.getElementById('customizationScreen').classList.remove('active');
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('gameContainer').classList.remove('hidden');
                
                // Initialize game
                initGame();
                
                // Start auto-save interval (only if not already started)
                if (!window.autoSaveInterval) {
                    window.autoSaveInterval = setInterval(saveGameToCloud, 30000); // Save every 30 seconds
                }
            } catch (error) {
                console.error('Failed to save customization:', error);
                alert('Failed to save customization. Starting game with default appearance.');
                document.getElementById('customizationScreen').classList.remove('active');
                document.getElementById('loginScreen').classList.add('hidden');
                document.getElementById('gameContainer').classList.remove('hidden');
                initGame();
            }
        }
        
        // ========== EQUIPMENT MANAGEMENT FUNCTIONS ==========
        
        function equipItem(itemName, itemType) {
            try {
                // Validate item exists in equipment database
                let itemData = null;
                if (itemType === 'weapon' && EQUIPMENT.weapons[itemName]) {
                    itemData = EQUIPMENT.weapons[itemName];
                } else if (itemType === 'armor' && EQUIPMENT.armor[itemName]) {
                    itemData = EQUIPMENT.armor[itemName];
                } else if (itemType === 'helmet' && EQUIPMENT.helmets[itemName]) {
                    itemData = EQUIPMENT.helmets[itemName];
                } else if (itemType === 'boots' && EQUIPMENT.boots[itemName]) {
                    itemData = EQUIPMENT.boots[itemName];
                }
                
                if (!itemData) {
                    addChatMessage('System', `Cannot equip ${itemName}: item not found`, 'system');
                    return false;
                }
                
                // Check level requirement
                if (itemData.level > currentPlayer.level) {
                    addChatMessage('System', `You need level ${itemData.level} to equip ${itemName}`, 'system');
                    return false;
                }
                
                // Equip the item
                const oldItem = currentPlayer.equipment[itemType];
                currentPlayer.equipment[itemType] = itemName;
                
                // Update visual equipment (for weapons)
                if (itemType === 'weapon' && playerMesh) {
                    addWeaponToPlayer(playerMesh, itemName);
                }
                
                // Update equipment display
                updateEquipmentDisplay();
                
                // Show message
                addChatMessage('System', `✨ Equipped ${itemName}!`, 'system');
                if (oldItem) {
                    addChatMessage('System', `Unequipped ${oldItem}`, 'system');
                }
                
                // Save to cloud
                saveGameToCloud();
                
                return true;
            } catch (error) {
                console.error('Error equipping item:', error);
                return false;
            }
        }
        
        function unequipItem(itemType) {
            try {
                const item = currentPlayer.equipment[itemType];
                if (!item) {
                    addChatMessage('System', `No ${itemType} equipped`, 'system');
                    return false;
                }
                
                currentPlayer.equipment[itemType] = null;
                
                // Remove visual equipment (for weapons)
                if (itemType === 'weapon' && playerMesh && equippedWeaponMesh) {
                    playerMesh.remove(equippedWeaponMesh);
                    equippedWeaponMesh = null;
                }
                
                // Update equipment display
                updateEquipmentDisplay();
                
                addChatMessage('System', `Unequipped ${item}`, 'system');
                
                // Save to cloud
                saveGameToCloud();
                
                return true;
            } catch (error) {
                console.error('Error unequipping item:', error);
                return false;
            }
        }
        
        function updateEquipmentDisplay() {
            // Update equipment slots display
            const weaponSlot = document.getElementById('weaponSlot');
            const armorSlot = document.getElementById('armorSlot');
            const helmetSlot = document.getElementById('helmetSlot');
            const bootsSlot = document.getElementById('bootsSlot');
            
            if (weaponSlot) {
                weaponSlot.innerHTML = currentPlayer.equipment.weapon 
                    ? `🗡️ ${currentPlayer.equipment.weapon}` 
                    : '🗡️ Weapon';
                weaponSlot.style.cursor = currentPlayer.equipment.weapon ? 'pointer' : 'default';
                weaponSlot.onclick = currentPlayer.equipment.weapon 
                    ? () => unequipItem('weapon') 
                    : null;
            }
            
            if (armorSlot) {
                armorSlot.innerHTML = currentPlayer.equipment.armor 
                    ? `🛡️ ${currentPlayer.equipment.armor}` 
                    : '🛡️ Armor';
                armorSlot.style.cursor = currentPlayer.equipment.armor ? 'pointer' : 'default';
                armorSlot.onclick = currentPlayer.equipment.armor 
                    ? () => unequipItem('armor') 
                    : null;
            }
            
            if (helmetSlot) {
                helmetSlot.innerHTML = currentPlayer.equipment.helmet 
                    ? `⛑️ ${currentPlayer.equipment.helmet}` 
                    : '⛑️ Helmet';
                helmetSlot.style.cursor = currentPlayer.equipment.helmet ? 'pointer' : 'default';
                helmetSlot.onclick = currentPlayer.equipment.helmet 
                    ? () => unequipItem('helmet') 
                    : null;
            }
            
            if (bootsSlot) {
                bootsSlot.innerHTML = currentPlayer.equipment.boots 
                    ? `👢 ${currentPlayer.equipment.boots}` 
                    : '👢 Boots';
                bootsSlot.style.cursor = currentPlayer.equipment.boots ? 'pointer' : 'default';
                bootsSlot.onclick = currentPlayer.equipment.boots 
                    ? () => unequipItem('boots') 
                    : null;
            }
        }
        
        // Give player a starting weapon for testing
        function giveStarterWeapon() {
            if (!currentPlayer.equipment.weapon && currentPlayer.level === 1) {
                currentPlayer.equipment.weapon = 'Wooden Sword';
                equipItem('Wooden Sword', 'weapon');
                addChatMessage('System', '🎁 You received a Wooden Sword to start your adventure!', 'system');
            }
        }
        
        // ========== AUTH STATE LISTENER ==========
        
        function setupAuthListener() {
            if (!auth) {
                console.error('Auth not initialized yet!');
                return;
            }
            
            auth.onAuthStateChanged(async (user) => {
            if (user) {
                // User is logged in
                currentUser = user;
                console.log('User authenticated:', user.email);
                
                try {
                    // Load user profile from Firebase
                    const profileSnapshot = await database.ref('user_profiles/' + user.uid).once('value');
                    const profileData = profileSnapshot.val();
                    
                    if (profileData) {
                        // Load saved data into currentPlayer
                        currentPlayer.name = profileData.name;
                        currentPlayer.id = user.uid;
                        currentPlayer.level = profileData.level || 1;
                        currentPlayer.gold = profileData.gold || 0;
                        currentPlayer.xp = profileData.xp || 0;
                        currentPlayer.hp = profileData.hp || 100;
                        currentPlayer.maxHp = profileData.maxHp || 100;
                        currentPlayer.mp = profileData.mp || 100;
                        currentPlayer.maxMp = profileData.maxMp || 100;
                        currentPlayer.skills = profileData.skills || currentPlayer.skills;
                        currentPlayer.stats = profileData.stats || currentPlayer.stats;
                        currentPlayer.equipment = profileData.equipment || {};
                        currentPlayer.inventory = profileData.inventory || {};
                        currentPlayer.pet = profileData.pet || null;
                        currentPlayer.achievements = profileData.achievements || [];
                        currentPlayer.quests = profileData.quests || { active: [], completed: [] };
                        currentPlayer.craftedItems = profileData.craftedItems || 0;
                        
                        // Load appearance or show customization if not set
                        if (profileData.appearance) {
                            currentPlayer.appearance = profileData.appearance;
                            tempAppearance = { ...profileData.appearance };
                        }
                        
                        // Set up profile reference for auto-save
                        userProfileRef = database.ref('user_profiles/' + user.uid);
                        
                        // Check if appearance exists - if not, show customization screen
                        if (!profileData.appearance) {
                            // New user - show customization
                            document.getElementById('loginScreen').classList.add('hidden');
                            showCustomizationScreen();
                        } else {
                            // Existing user - go straight to game
                            document.getElementById('loginScreen').classList.add('hidden');
                            document.getElementById('gameContainer').classList.remove('hidden');
                            
                            // Initialize game
                            initGame();
                            
                            // Start auto-save interval (only if not already started)
                            if (!window.autoSaveInterval) {
                                window.autoSaveInterval = setInterval(saveGameToCloud, 30000); // Save every 30 seconds
                            }
                        }
                        
                        console.log('Profile loaded successfully');
                    }
                    
                } catch (error) {
                    console.error('Error loading profile:', error);
                    showAuthError('Failed to load profile: ' + error.message);
                }
                
            } else {
                // User is logged out
                currentUser = null;
                console.log('No user authenticated');
                
                // Show login screen
                document.getElementById('loginScreen').classList.remove('hidden');
                document.getElementById('gameContainer').classList.add('hidden');
            }
            });
        }
        
        // ========== CLOUD SAVE FUNCTIONS ==========
        
        async function saveGameToCloud() {
            if (!currentUser || !userProfileRef) return;
            
            try {
                await userProfileRef.update({
                    name: currentPlayer.name,
                    level: currentPlayer.level,
                    gold: currentPlayer.gold,
                    xp: currentPlayer.xp,
                    hp: currentPlayer.hp,
                    maxHp: currentPlayer.maxHp,
                    mp: currentPlayer.mp,
                    maxMp: currentPlayer.maxMp,
                    skills: currentPlayer.skills,
                    stats: currentPlayer.stats,
                    equipment: currentPlayer.equipment,
                    inventory: currentPlayer.inventory,
                    pet: currentPlayer.pet,
                    achievements: currentPlayer.achievements,
                    appearance: currentPlayer.appearance,
                    quests: currentPlayer.quests,
                    craftedItems: currentPlayer.craftedItems,
                    lastSaved: Date.now()
                });
                
                console.log('Game saved to cloud');
                
            } catch (error) {
                console.error('Cloud save error:', error);
            }
        }

        // Initialize 3D Game
        function initGame() {
            canvas = document.getElementById('renderCanvas');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 500, 2000);  // Adjusted for massive world

            // Camera setup (isometric-like view)
            // Use window size if canvas dimensions are not available yet
            const canvasWidth = canvas.offsetWidth || window.innerWidth;
            const canvasHeight = canvas.offsetHeight || window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, canvasWidth / canvasHeight, 0.1, 10000);
            updateCameraPosition();

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvasWidth, canvasHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Force canvas to take full available space
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            
            console.log('Renderer initialized with size:', canvasWidth, 'x', canvasHeight);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 40, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Create terrain
            createTerrain();

            // Create player
            createPlayer();

            // Raycaster for clicking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Update UI
            document.getElementById('playerName').textContent = currentPlayer.name;
            updateStats();
            renderInventory();
            updateEquipmentDisplay();
            
            // Give starter weapon if new player
            giveStarterWeapon();

            // Firebase references with error handling
            try {
                playersRef = database.ref('players');
                chatRef = database.ref('chat');

                // Add player to database
                const playerRef = playersRef.child(currentPlayer.id);
                playerRef.set({
                    name: currentPlayer.name,
                    x: currentPlayer.x,
                    y: currentPlayer.y,
                    z: currentPlayer.z,
                    rotation: currentPlayer.rotation,
                    level: currentPlayer.level,
                    lastActive: Date.now()
                }).catch(err => console.error('Failed to set player data:', err));

                // Remove player on disconnect
                playerRef.onDisconnect().remove();

                // Listen for other players
                playersRef.on('value', (snapshot) => {
                    try {
                        players = {};
                        let onlineCount = 0;
                        snapshot.forEach((child) => {
                            try {
                                const player = child.val();
                                if (child.key !== currentPlayer.id) {
                                    players[child.key] = player;
                                    updatePlayerMesh(child.key, player);
                                }
                                onlineCount++;
                            } catch (e) {
                                console.warn('Error processing player:', e);
                            }
                        });
                        
                        const onlineElement = document.getElementById('onlineCount');
                        if (onlineElement) {
                            onlineElement.textContent = `🟢 ${onlineCount} players online`;
                        }
                        
                        // Remove disconnected players
                        Object.keys(playerMeshes).forEach(id => {
                            if (!players[id] && id !== currentPlayer.id) {
                                if (playerMeshes[id] && scene) {
                                    scene.remove(playerMeshes[id]);
                                }
                                delete playerMeshes[id];
                            }
                        });
                    } catch (err) {
                        console.error('Error in players listener:', err);
                    }
                }, (error) => {
                    console.error('Failed to listen for players:', error);
                });

                // Listen for chat messages
                chatRef.limitToLast(20).on('child_added', (snapshot) => {
                    try {
                        const msg = snapshot.val();
                        if (msg && msg.player && msg.message) {
                            addChatMessage(msg.player, msg.message, msg.type || 'player');
                        }
                    } catch (err) {
                        console.warn('Error processing chat message:', err);
                    }
                }, (error) => {
                    console.error('Failed to listen for chat:', error);
                });
            } catch (error) {
                console.error('Firebase initialization error:', error);
                addChatMessage('System', 'Multiplayer connection failed. Playing in offline mode.', 'system');
            }

            // Initialize game entities
            createHouses();
            createNPCs();
            initMonsters();
            initResources();

            // Controls
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('touchend', handleCanvasTouchEnd);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            // Minimap click-to-move
            const miniMapCanvas = document.getElementById('miniMapCanvas');
            if (miniMapCanvas) {
                miniMapCanvas.addEventListener('click', handleMinimapClick);
                miniMapCanvas.addEventListener('touchend', handleMinimapTouchEnd);
                miniMapCanvas.style.cursor = 'pointer';
            }
            
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            // Initialize mobile controls
            initMobileControls();
            
            // Create world decorations
            // Temporarily simplified for stability
            // createWorldDecorations();
            
            // Create massive world content (themed areas and props)
            // Temporarily disabled to test base game
            // createMassiveWorldContent();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Ensure proper sizing after layout
            setTimeout(() => {
                onWindowResize();
                console.log('Canvas resized to:', canvas.offsetWidth, 'x', canvas.offsetHeight);
            }, 100);

            // Game loop
            animate();
            setInterval(updatePlayerPosition, 100);

            // Add system message
            addChatMessage('System', `${currentPlayer.name} joined the 3D adventure!`, 'system');
        }

        function createTerrain() {
            // Create ground plane with texture-like appearance
            const groundGeometry = new THREE.PlaneGeometry(MAP_SIZE * 2, MAP_SIZE * 2, 100, 100);
            
            // Add variation to terrain height
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 0.5; // Random height variation
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a7d44,
                roughness: 0.8,
                metalness: 0.2
            });
            
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Add some water patches
            for (let i = 0; i < 5; i++) {
                const waterGeometry = new THREE.CircleGeometry(3 + Math.random() * 2, 32);
                const waterMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1e90ff,
                    roughness: 0.1,
                    metalness: 0.5
                });
                const water = new THREE.Mesh(waterGeometry, waterMaterial);
                water.rotation.x = -Math.PI / 2;
                water.position.x = (Math.random() - 0.5) * MAP_SIZE;
                water.position.z = (Math.random() - 0.5) * MAP_SIZE;
                water.position.y = 0.05;
                water.receiveShadow = true;
                scene.add(water);
            }

            // Add some dirt paths
            for (let i = 0; i < 8; i++) {
                const pathGeometry = new THREE.PlaneGeometry(2, 5);
                const pathMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const path = new THREE.Mesh(pathGeometry, pathMaterial);
                path.rotation.x = -Math.PI / 2;
                path.position.x = (Math.random() - 0.5) * MAP_SIZE;
                path.position.z = (Math.random() - 0.5) * MAP_SIZE;
                path.position.y = 0.02;
                path.receiveShadow = true;
                scene.add(path);
            }
        }
        
        function createWorldDecorations() {
            // Create realistic water bodies
            const riverGeometry = new THREE.PlaneGeometry(8, 80);
            const riverMaterial = new THREE.MeshStandardMaterial({
                color: 0x1e90ff,
                roughness: 0.1,
                metalness: 0.8,
                transparent: true,
                opacity: 0.7
            });
            const river = new THREE.Mesh(riverGeometry, riverMaterial);
            river.rotation.x = -Math.PI / 2;
            river.position.set(-45, 0.1, 0);
            scene.add(river);
            
            // Create a bridge over the river
            const bridgeGeometry = new THREE.BoxGeometry(10, 0.5, 4);
            const bridgeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8B4513,
                roughness: 0.9
            });
            const bridge = new THREE.Mesh(bridgeGeometry, bridgeMaterial);
            bridge.position.set(-45, 0.25, 0);
            bridge.castShadow = true;
            bridge.receiveShadow = true;
            scene.add(bridge);
            
            // Add bridge railings
            const railingGeometry = new THREE.BoxGeometry(10, 1, 0.2);
            const railingMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
            const railing1 = new THREE.Mesh(railingGeometry, railingMaterial);
            railing1.position.set(-45, 0.75, 2);
            scene.add(railing1);
            const railing2 = new THREE.Mesh(railingGeometry, railingMaterial);
            railing2.position.set(-45, 0.75, -2);
            scene.add(railing2);
            
            // Create grass patches
            for (let i = 0; i < 20; i++) {
                const grassGeometry = new THREE.CircleGeometry(2 + Math.random() * 3, 32);
                const grassMaterial = new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    roughness: 0.9
                });
                const grass = new THREE.Mesh(grassGeometry, grassMaterial);
                grass.rotation.x = -Math.PI / 2;
                grass.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                grass.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                grass.position.y = 0.01;
                scene.add(grass);
            }
            
            // Create PVP Area (Wilderness)
            const pvpGeometry = new THREE.PlaneGeometry(PVP_AREA.width, PVP_AREA.depth);
            const pvpMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B0000,
                roughness: 0.8,
                transparent: true,
                opacity: 0.3
            });
            const pvpArea = new THREE.Mesh(pvpGeometry, pvpMaterial);
            pvpArea.rotation.x = -Math.PI / 2;
            pvpArea.position.set(PVP_AREA.x, 0.05, PVP_AREA.z);
            scene.add(pvpArea);
            
            // Add PVP warning sign
            const signGeometry = new THREE.BoxGeometry(3, 2, 0.2);
            const signMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(PVP_AREA.x - PVP_AREA.width/2 - 3, 1, PVP_AREA.z);
            scene.add(sign);
            
            // Create stone paths connecting areas
            const pathPositions = [
                { x: 0, z: 0, length: 30, angle: 0 },
                { x: 0, z: 0, length: 30, angle: Math.PI/2 },
                { x: -20, z: -20, length: 20, angle: Math.PI/4 }
            ];
            
            pathPositions.forEach(path => {
                const pathGeometry = new THREE.PlaneGeometry(3, path.length);
                const pathMaterial = new THREE.MeshStandardMaterial({
                    color: 0x808080,
                    roughness: 0.8
                });
                const pathMesh = new THREE.Mesh(pathGeometry, pathMaterial);
                pathMesh.rotation.x = -Math.PI / 2;
                pathMesh.rotation.z = path.angle;
                pathMesh.position.set(path.x, 0.02, path.z);
                scene.add(pathMesh);
            });
            
            // Environment assets and props moved to createEnvironmentAssets()
            createEnvironmentAssets();
        }
        
        function createEnvironmentAssets() {
            // === BIOME DEFINITIONS ===
            const biomes = [
                { name: 'forest', centerX: -400, centerZ: -400, radius: 200, color: 0x2d5016 },
                { name: 'desert', centerX: 400, centerZ: -400, radius: 180, color: 0xc2b280 },
                { name: 'snow', centerX: -400, centerZ: 400, radius: 150, color: 0xf0f8ff },
                { name: 'swamp', centerX: 0, centerZ: -400, radius: 120, color: 0x4a5d23 },
                { name: 'volcanic', centerX: 400, centerZ: 400, radius: 140, color: 0x3d0c02 }
            ];
            
            // Draw biome ground patches
            biomes.forEach(biome => {
                const biomeGeo = new THREE.CircleGeometry(biome.radius, 32);
                const biomeMat = new THREE.MeshStandardMaterial({ 
                    color: biome.color, 
                    roughness: 0.9 
                });
                const biomeMesh = new THREE.Mesh(biomeGeo, biomeMat);
                biomeMesh.rotation.x = -Math.PI / 2;
                biomeMesh.position.set(biome.centerX, 0.01, biome.centerZ);
                scene.add(biomeMesh);
            });
            
            // === DECORATIVE BOULDERS (100 varied rocks) ===
            for (let i = 0; i < 100; i++) {
                const size = 0.4 + Math.random() * 1.2;
                const rockTypes = [
                    new THREE.DodecahedronGeometry(size),
                    new THREE.IcosahedronGeometry(size),
                    new THREE.OctahedronGeometry(size * 1.2),
                    new THREE.TetrahedronGeometry(size * 1.3)
                ];
                const rockGeo = rockTypes[Math.floor(Math.random() * rockTypes.length)];
                const rockMat = new THREE.MeshStandardMaterial({ 
                    color: [0x696969, 0x808080, 0x556B2F, 0x8B7355][Math.floor(Math.random() * 4)],
                    roughness: 0.95
                });
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                rock.position.y = size * 0.5;
                rock.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                rock.rotation.y = Math.random() * Math.PI * 2;
                rock.castShadow = true;
                scene.add(rock);
            }
            
            // === MUSHROOM CIRCLES (20 clusters) ===
            for (let i = 0; i < 20; i++) {
                const centerX = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                const centerZ = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                const numMushrooms = 5 + Math.floor(Math.random() * 8);
                
                for (let j = 0; j < numMushrooms; j++) {
                    const angle = (j / numMushrooms) * Math.PI * 2;
                    const radius = 2 + Math.random();
                    
                    // Mushroom stem
                    const stemGeo = new THREE.CylinderGeometry(0.1, 0.12, 0.3, 8);
                    const stemMat = new THREE.MeshStandardMaterial({ color: 0xFFF8DC });
                    const stem = new THREE.Mesh(stemGeo, stemMat);
                    
                    // Mushroom cap
                    const capGeo = new THREE.ConeGeometry(0.25, 0.2, 8);
                    const capMat = new THREE.MeshStandardMaterial({ 
                        color: [0xFF4500, 0xFF6347, 0x8B0000][Math.floor(Math.random() * 3)]
                    });
                    const cap = new THREE.Mesh(capGeo, capMat);
                    cap.position.y = 0.25;
                    
                    const mushroom = new THREE.Group();
                    mushroom.add(stem);
                    mushroom.add(cap);
                    mushroom.position.set(
                        centerX + Math.cos(angle) * radius,
                        0.15,
                        centerZ + Math.sin(angle) * radius
                    );
                    mushroom.castShadow = true;
                    scene.add(mushroom);
                }
            }
            
            // === WOODEN BENCHES (30) ===
            for (let i = 0; i < 30; i++) {
                const bench = new THREE.Group();
                
                // Seat
                const seatGeo = new THREE.BoxGeometry(1.5, 0.1, 0.5);
                const seatMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const seat = new THREE.Mesh(seatGeo, seatMat);
                seat.position.y = 0.4;
                
                // Back
                const backGeo = new THREE.BoxGeometry(1.5, 0.6, 0.1);
                const back = new THREE.Mesh(backGeo, seatMat);
                back.position.set(0, 0.7, -0.2);
                
                // Legs
                const legGeo = new THREE.BoxGeometry(0.1, 0.4, 0.1);
                for (let x of [-0.6, 0.6]) {
                    for (let z of [-0.2, 0.2]) {
                        const leg = new THREE.Mesh(legGeo, seatMat);
                        leg.position.set(x, 0.2, z);
                        bench.add(leg);
                    }
                }
                
                bench.add(seat);
                bench.add(back);
                bench.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                bench.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                bench.rotation.y = Math.random() * Math.PI * 2;
                bench.castShadow = true;
                scene.add(bench);
            }
            
            // === STONE FOUNTAINS (15) ===
            for (let i = 0; i < 15; i++) {
                const fountain = new THREE.Group();
                
                // Base
                const baseGeo = new THREE.CylinderGeometry(1.5, 1.8, 0.3, 8);
                const baseMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                
                // Pool
                const poolGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.5, 8);
                const poolMat = new THREE.MeshStandardMaterial({ 
                    color: 0x4682B4, 
                    transparent: true, 
                    opacity: 0.7 
                });
                const pool = new THREE.Mesh(poolGeo, poolMat);
                pool.position.y = 0.4;
                
                // Central pillar
                const pillarGeo = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8);
                const pillar = new THREE.Mesh(pillarGeo, baseMat);
                pillar.position.y = 1.1;
                
                // Top sphere
                const topGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const top = new THREE.Mesh(topGeo, baseMat);
                top.position.y = 1.9;
                
                fountain.add(base, pool, pillar, top);
                fountain.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.6;
                fountain.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.6;
                fountain.castShadow = true;
                scene.add(fountain);
            }
            
            // === ANCIENT STATUES (25) ===
            for (let i = 0; i < 25; i++) {
                const statue = new THREE.Group();
                const stoneMat = new THREE.MeshStandardMaterial({ color: 0x696969, roughness: 0.9 });
                
                // Pedestal
                const pedestalGeo = new THREE.CylinderGeometry(0.6, 0.7, 0.8, 8);
                const pedestal = new THREE.Mesh(pedestalGeo, stoneMat);
                
                // Body
                const bodyGeo = new THREE.CylinderGeometry(0.4, 0.5, 1.5, 8);
                const body = new THREE.Mesh(bodyGeo, stoneMat);
                body.position.y = 1.55;
                
                // Head
                const headGeo = new THREE.SphereGeometry(0.35, 8, 8);
                const head = new THREE.Mesh(headGeo, stoneMat);
                head.position.y = 2.5;
                
                // Arms
                const armGeo = new THREE.BoxGeometry(0.2, 0.8, 0.2);
                const leftArm = new THREE.Mesh(armGeo, stoneMat);
                leftArm.position.set(-0.5, 1.8, 0);
                leftArm.rotation.z = 0.3;
                const rightArm = new THREE.Mesh(armGeo, stoneMat);
                rightArm.position.set(0.5, 1.8, 0);
                rightArm.rotation.z = -0.3;
                
                statue.add(pedestal, body, head, leftArm, rightArm);
                statue.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                statue.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                statue.rotation.y = Math.random() * Math.PI * 2;
                statue.castShadow = true;
                scene.add(statue);
            }
            
            // === TRAINING DUMMIES (20) ===
            for (let i = 0; i < 20; i++) {
                const dummy = new THREE.Group();
                const dummyMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
                
                // Post
                const postGeo = new THREE.CylinderGeometry(0.15, 0.15, 2, 8);
                const post = new THREE.Mesh(postGeo, dummyMat);
                post.position.y = 1;
                
                // Body (barrel shape)
                const bodyGeo = new THREE.CylinderGeometry(0.5, 0.45, 1, 8);
                const body = new THREE.Mesh(bodyGeo, dummyMat);
                body.position.y = 1.5;
                
                // Head (sphere)
                const headGeo = new THREE.SphereGeometry(0.3, 8, 8);
                const head = new THREE.Mesh(headGeo, dummyMat);
                head.position.y = 2.3;
                
                // Crossbar for arms
                const crossGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.2, 8);
                const cross = new THREE.Mesh(crossGeo, dummyMat);
                cross.rotation.z = Math.PI / 2;
                cross.position.y = 1.8;
                
                dummy.add(post, body, head, cross);
                dummy.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                dummy.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                dummy.castShadow = true;
                scene.add(dummy);
            }
            
            // === STONE WELLS (12) ===
            for (let i = 0; i < 12; i++) {
                const well = new THREE.Group();
                const stoneMat = new THREE.MeshStandardMaterial({ color: 0x696969 });
                
                // Well base
                const baseGeo = new THREE.CylinderGeometry(1, 1.1, 1.5, 16);
                const base = new THREE.Mesh(baseGeo, stoneMat);
                base.position.y = 0.75;
                
                // Roof supports
                const supportGeo = new THREE.CylinderGeometry(0.1, 0.1, 2, 8);
                const support1 = new THREE.Mesh(supportGeo, new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                support1.position.set(-0.8, 2, 0);
                const support2 = support1.clone();
                support2.position.set(0.8, 2, 0);
                
                // Roof
                const roofGeo = new THREE.ConeGeometry(1.2, 1, 4);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0xDC143C });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 3.5;
                roof.rotation.y = Math.PI / 4;
                
                well.add(base, support1, support2, roof);
                well.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.6;
                well.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.6;
                well.castShadow = true;
                scene.add(well);
            }
            
            // === CAMPFIRES (40) ===
            for (let i = 0; i < 40; i++) {
                const campfire = new THREE.Group();
                
                // Stone circle
                const stoneGeo = new THREE.BoxGeometry(0.3, 0.2, 0.3);
                const stoneMat = new THREE.MeshStandardMaterial({ color: 0x696969 });
                for (let j = 0; j < 8; j++) {
                    const angle = (j / 8) * Math.PI * 2;
                    const stone = new THREE.Mesh(stoneGeo, stoneMat);
                    stone.position.set(Math.cos(angle) * 0.6, 0.1, Math.sin(angle) * 0.6);
                    campfire.add(stone);
                }
                
                // Logs
                const logGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
                const logMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                for (let j = 0; j < 4; j++) {
                    const log = new THREE.Mesh(logGeo, logMat);
                    log.rotation.z = (j * Math.PI / 2) + 0.3;
                    log.position.y = 0.2;
                    campfire.add(log);
                }
                
                // Fire (glowing cone)
                const fireGeo = new THREE.ConeGeometry(0.3, 0.8, 4);
                const fireMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF4500, 
                    emissive: 0xFF4500,
                    emissiveIntensity: 0.8
                });
                const fire = new THREE.Mesh(fireGeo, fireMat);
                fire.position.y = 0.5;
                campfire.add(fire);
                
                campfire.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                campfire.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                scene.add(campfire);
            }
            
            // === STONE MONUMENTS/OBELISKS (15) ===
            for (let i = 0; i < 15; i++) {
                const obelisk = new THREE.Group();
                const stoneMat = new THREE.MeshStandardMaterial({ color: 0x556B2F, roughness: 0.95 });
                
                // Base platform
                const platformGeo = new THREE.CylinderGeometry(2, 2.2, 0.5, 8);
                const platform = new THREE.Mesh(platformGeo, stoneMat);
                
                // Main obelisk
                const obeliskGeo = new THREE.CylinderGeometry(0.4, 0.6, 6, 4);
                const obeliskMesh = new THREE.Mesh(obeliskGeo, stoneMat);
                obeliskMesh.position.y = 3.25;
                
                // Pyramid top
                const topGeo = new THREE.ConeGeometry(0.5, 1, 4);
                const top = new THREE.Mesh(topGeo, stoneMat);
                top.position.y = 6.5;
                
                obelisk.add(platform, obeliskMesh, top);
                obelisk.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                obelisk.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                obelisk.castShadow = true;
                scene.add(obelisk);
            }
            
            // === ANCIENT SHRINES (10) ===
            for (let i = 0; i < 10; i++) {
                const shrine = new THREE.Group();
                
                // Platform with steps
                for (let step = 0; step < 3; step++) {
                    const stepGeo = new THREE.BoxGeometry(3 - step * 0.4, 0.3, 3 - step * 0.4);
                    const stepMat = new THREE.MeshStandardMaterial({ color: 0x8B8878 });
                    const stepMesh = new THREE.Mesh(stepGeo, stepMat);
                    stepMesh.position.y = step * 0.3;
                    shrine.add(stepMesh);
                }
                
                // Pillars
                const pillarGeo = new THREE.CylinderGeometry(0.2, 0.25, 2.5, 8);
                const pillarMat = new THREE.MeshStandardMaterial({ color: 0xF5F5DC });
                const positions = [[-0.8, 0, -0.8], [0.8, 0, -0.8], [-0.8, 0, 0.8], [0.8, 0, 0.8]];
                positions.forEach(pos => {
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(pos[0], 2.15, pos[2]);
                    shrine.add(pillar);
                });
                
                // Roof
                const roofGeo = new THREE.BoxGeometry(2.5, 0.3, 2.5);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 3.5;
                shrine.add(roof);
                
                // Crystal orb on top
                const orbGeo = new THREE.SphereGeometry(0.3, 16, 16);
                const orbMat = new THREE.MeshStandardMaterial({ 
                    color: 0x9370DB,
                    emissive: 0x9370DB,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                const orb = new THREE.Mesh(orbGeo, orbMat);
                orb.position.y = 4;
                shrine.add(orb);
                
                shrine.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                shrine.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                shrine.castShadow = true;
                scene.add(shrine);
            }
            
            // === RUINED WALLS (30) ===
            for (let i = 0; i < 30; i++) {
                const wallGeo = new THREE.BoxGeometry(
                    3 + Math.random() * 4,
                    1.5 + Math.random() * 2,
                    0.5
                );
                const wallMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8B8878,
                    roughness: 1.0
                });
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                wall.position.y = wallGeo.parameters.height / 2;
                wall.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                wall.rotation.y = Math.random() * Math.PI * 2;
                wall.castShadow = true;
                scene.add(wall);
            }
            
            // === WOODEN BRIDGES (8) ===
            for (let i = 0; i < 8; i++) {
                const bridge = new THREE.Group();
                const woodMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                
                // Deck
                const deckGeo = new THREE.BoxGeometry(12, 0.3, 3);
                const deck = new THREE.Mesh(deckGeo, woodMat);
                deck.position.y = 0.5;
                
                // Support beams
                for (let x = -5; x <= 5; x += 2.5) {
                    const beamGeo = new THREE.BoxGeometry(0.3, 1, 0.3);
                    const beam = new THREE.Mesh(beamGeo, woodMat);
                    beam.position.set(x, 0, 1.2);
                    bridge.add(beam);
                    const beam2 = beam.clone();
                    beam2.position.z = -1.2;
                    bridge.add(beam2);
                }
                
                // Railings
                const railGeo = new THREE.BoxGeometry(12, 0.2, 0.2);
                const rail1 = new THREE.Mesh(railGeo, woodMat);
                rail1.position.set(0, 1, 1.5);
                const rail2 = rail1.clone();
                rail2.position.z = -1.5;
                
                bridge.add(deck, rail1, rail2);
                bridge.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                bridge.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                bridge.rotation.y = Math.random() * Math.PI * 2;
                bridge.castShadow = true;
                scene.add(bridge);
            }
            
            // === DECORATIVE TREES (not harvestable, just scenery) (200) ===
            const treeTypes = [
                { color: 0x228B22, height: 4, foliageType: 'sphere' },
                { color: 0x006400, height: 5, foliageType: 'cone' },
                { color: 0x8FBC8F, height: 3, foliageType: 'sphere' },
                { color: 0x2F4F4F, height: 6, foliageType: 'cone' }
            ];
            
            for (let i = 0; i < 200; i++) {
                const treeType = treeTypes[Math.floor(Math.random() * treeTypes.length)];
                const tree = new THREE.Group();
                
                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, treeType.height, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = treeType.height / 2;
                
                // Foliage
                let foliageGeo;
                if (treeType.foliageType === 'cone') {
                    foliageGeo = new THREE.ConeGeometry(1.5, 2.5, 8);
                } else {
                    foliageGeo = new THREE.SphereGeometry(1.8, 8, 8);
                }
                const foliageMat = new THREE.MeshStandardMaterial({ color: treeType.color });
                const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                foliage.position.y = treeType.height + 1.5;
                
                tree.add(trunk, foliage);
                tree.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.95;
                tree.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.95;
                tree.castShadow = true;
                scene.add(tree);
            }
            
            // === CAVE ENTRANCES (8) ===
            for (let i = 0; i < 8; i++) {
                const cave = new THREE.Group();
                
                // Cave mouth (dark archway)
                const archGeo = new THREE.TorusGeometry(2, 0.5, 8, 16, Math.PI);
                const archMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
                const arch = new THREE.Mesh(archGeo, archMat);
                arch.rotation.x = Math.PI / 2;
                arch.position.y = 2;
                
                // Dark interior
                const interiorGeo = new THREE.PlaneGeometry(4, 4);
                const interiorMat = new THREE.MeshStandardMaterial({ color: 0x0A0A0A });
                const interior = new THREE.Mesh(interiorGeo, interiorMat);
                interior.position.set(0, 2, -0.1);
                
                // Rocks around entrance
                for (let j = 0; j < 6; j++) {
                    const rockGeo = new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.8);
                    const rockMat = new THREE.MeshStandardMaterial({ color: 0x696969 });
                    const rock = new THREE.Mesh(rockGeo, rockMat);
                    const angle = (j / 6) * Math.PI;
                    rock.position.set(
                        Math.cos(angle) * 3,
                        0.5,
                        Math.sin(angle) * 1.5
                    );
                    cave.add(rock);
                }
                
                cave.add(arch, interior);
                cave.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                cave.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                cave.rotation.y = Math.random() * Math.PI * 2;
                cave.castShadow = true;
                scene.add(cave);
            }
            
            // === FLOWER GARDENS (25 patches) ===
            for (let i = 0; i < 25; i++) {
                const gardenX = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                const gardenZ = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                
                // Create 10-20 flowers per garden
                const flowerCount = 10 + Math.floor(Math.random() * 10);
                for (let j = 0; j < flowerCount; j++) {
                    const flower = new THREE.Group();
                    
                    // Stem
                    const stemGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 4);
                    const stemMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
                    const stem = new THREE.Mesh(stemGeo, stemMat);
                    stem.position.y = 0.2;
                    
                    // Flower petals (simple sphere)
                    const petalGeo = new THREE.SphereGeometry(0.1, 6, 6);
                    const colors = [0xFF1493, 0xFFFF00, 0xFF4500, 0x9370DB, 0xFFFFFF];
                    const petalMat = new THREE.MeshStandardMaterial({ 
                        color: colors[Math.floor(Math.random() * colors.length)]
                    });
                    const petals = new THREE.Mesh(petalGeo, petalMat);
                    petals.position.y = 0.42;
                    
                    flower.add(stem, petals);
                    flower.position.set(
                        gardenX + (Math.random() - 0.5) * 3,
                        0,
                        gardenZ + (Math.random() - 0.5) * 3
                    );
                    scene.add(flower);
                }
            }
            
            // === LANTERN POSTS (35) ===
            for (let i = 0; i < 35; i++) {
                const lanternPost = new THREE.Group();
                
                // Post
                const postGeo = new THREE.CylinderGeometry(0.1, 0.12, 3, 8);
                const postMat = new THREE.MeshStandardMaterial({ color: 0x2F4F4F });
                const post = new THREE.Mesh(postGeo, postMat);
                post.position.y = 1.5;
                
                // Lantern box
                const lanternGeo = new THREE.BoxGeometry(0.4, 0.6, 0.4);
                const lanternMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    emissive: 0xFFA500,
                    emissiveIntensity: 0.6
                });
                const lantern = new THREE.Mesh(lanternGeo, lanternMat);
                lantern.position.y = 3.3;
                
                // Small roof
                const roofGeo = new THREE.ConeGeometry(0.3, 0.3, 4);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x2F4F4F });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 3.75;
                
                lanternPost.add(post, lantern, roof);
                lanternPost.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                lanternPost.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                lanternPost.castShadow = true;
                scene.add(lanternPost);
            }
            
            // === FALLEN LOGS (50) ===
            for (let i = 0; i < 50; i++) {
                const logGeo = new THREE.CylinderGeometry(0.4, 0.5, 4 + Math.random() * 3, 8);
                const logMat = new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.95 });
                const log = new THREE.Mesh(logGeo, logMat);
                log.rotation.z = Math.PI / 2;
                log.rotation.y = Math.random() * Math.PI * 2;
                log.position.set(
                    (Math.random() - 0.5) * MAP_SIZE * 0.9,
                    0.4,
                    (Math.random() - 0.5) * MAP_SIZE * 0.9
                );
                log.castShadow = true;
                scene.add(log);
            }
            
            // === DESERT CACTI (in desert biome) (30) ===
            for (let i = 0; i < 30; i++) {
                const cactus = new THREE.Group();
                const cactusMat = new THREE.MeshStandardMaterial({ color: 0x3CB371 });
                
                // Main trunk
                const trunkGeo = new THREE.CylinderGeometry(0.3, 0.35, 2.5, 8);
                const trunk = new THREE.Mesh(trunkGeo, cactusMat);
                trunk.position.y = 1.25;
                
                // Arms
                if (Math.random() > 0.5) {
                    const armGeo = new THREE.CylinderGeometry(0.2, 0.22, 1.2, 8);
                    const arm = new THREE.Mesh(armGeo, cactusMat);
                    arm.position.set(0.4, 1.5, 0);
                    arm.rotation.z = Math.PI / 3;
                    cactus.add(arm);
                }
                
                cactus.add(trunk);
                const desertBiome = biomes.find(b => b.name === 'desert');
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * desertBiome.radius * 0.8;
                cactus.position.set(
                    desertBiome.centerX + Math.cos(angle) * dist,
                    0,
                    desertBiome.centerZ + Math.sin(angle) * dist
                );
                cactus.castShadow = true;
                scene.add(cactus);
            }
            
            // === SNOW-COVERED PINES (in snow biome) (25) ===
            const snowBiome = biomes.find(b => b.name === 'snow');
            for (let i = 0; i < 25; i++) {
                const pine = new THREE.Group();
                
                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(0.2, 0.25, 4, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3D2817 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 2;
                
                // Three layers of snow-covered branches
                for (let layer = 0; layer < 3; layer++) {
                    const branchGeo = new THREE.ConeGeometry(1.5 - layer * 0.3, 1.5, 8);
                    const branchMat = new THREE.MeshStandardMaterial({ color: 0xF0F8FF });
                    const branch = new THREE.Mesh(branchGeo, branchMat);
                    branch.position.y = 3 + layer * 1.2;
                    pine.add(branch);
                }
                
                pine.add(trunk);
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * snowBiome.radius * 0.8;
                pine.position.set(
                    snowBiome.centerX + Math.cos(angle) * dist,
                    0,
                    snowBiome.centerZ + Math.sin(angle) * dist
                );
                pine.castShadow = true;
                scene.add(pine);
            }
            
            // === LAVA ROCKS (in volcanic biome) (20) ===
            const volcanicBiome = biomes.find(b => b.name === 'volcanic');
            for (let i = 0; i < 20; i++) {
                const lavaRockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.6);
                const lavaRockMat = new THREE.MeshStandardMaterial({ 
                    color: 0x8B0000,
                    emissive: 0xFF4500,
                    emissiveIntensity: 0.3,
                    roughness: 0.9
                });
                const lavaRock = new THREE.Mesh(lavaRockGeo, lavaRockMat);
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * volcanicBiome.radius * 0.9;
                lavaRock.position.set(
                    volcanicBiome.centerX + Math.cos(angle) * dist,
                    0.5,
                    volcanicBiome.centerZ + Math.sin(angle) * dist
                );
                lavaRock.castShadow = true;
                scene.add(lavaRock);
            }
        }
        
        function handleMinimapTouchEnd(e) {
            e.preventDefault();
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                const rect = e.target.getBoundingClientRect();
                const fakeEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    target: e.target
                };
                handleMinimapClick(fakeEvent);
            }
        }

        function handleMinimapClick(e) {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Convert minimap click to world position
            const miniMapSize = 200;
            const scale = (MAP_SIZE * 2) / miniMapSize;
            
            // Calculate relative position from center
            const relativeX = (x - miniMapSize / 2) * scale;
            const relativeZ = (y - miniMapSize / 2) * scale;
            
            // Calculate world position
            const worldX = currentPlayer.x + relativeX;
            const worldZ = currentPlayer.z + relativeZ;
            
            // Set target position
            targetPosition = { x: worldX, z: worldZ };
            pathToTarget = []; // Clear old path
            targetMonster = null;
            targetResource = null;
            
            addChatMessage('System', 'Walking to map location...', 'system');
        }

        function createMassiveWorldContent() {
            // Define themed biome areas
            const themedAreas = [
                { name: 'Crystal Cavern', x: -2000, z: -2000, radius: 400, color: 0x9370DB },
                { name: 'Autumn Forest', x: 2000, z: -2000, radius: 400, color: 0xFF8C00 },
                { name: 'Frozen Tundra', x: -2000, z: 2000, radius: 400, color: 0xE0FFFF },
                { name: 'Volcanic Wasteland', x: 2000, z: 2000, radius: 400, color: 0xFF4500 },
                { name: 'Mystic Swamp', x: 0, z: -2200, radius: 350, color: 0x556B2F }
            ];
            
            // === CRYSTAL FORMATIONS (50 clusters in Crystal Cavern) ===
            for (let i = 0; i < 50; i++) {
                const cluster = new THREE.Group();
                const crystalColors = [0x9370DB, 0x00CED1, 0xFF69B4, 0x7FFF00];
                const numCrystals = 3 + Math.floor(Math.random() * 5);
                
                for (let j = 0; j < numCrystals; j++) {
                    const height = 1 + Math.random() * 3;
                    const crystalGeo = new THREE.ConeGeometry(0.2 + Math.random() * 0.3, height, 6);
                    const crystalMat = new THREE.MeshStandardMaterial({ 
                        color: crystalColors[Math.floor(Math.random() * crystalColors.length)],
                        emissive: crystalColors[Math.floor(Math.random() * crystalColors.length)],
                        emissiveIntensity: 0.3,
                        transparent: true,
                        opacity: 0.8
                    });
                    const crystal = new THREE.Mesh(crystalGeo, crystalMat);
                    crystal.position.set(
                        (Math.random() - 0.5) * 2,
                        height / 2,
                        (Math.random() - 0.5) * 2
                    );
                    crystal.rotation.z = (Math.random() - 0.5) * 0.5;
                    cluster.add(crystal);
                }
                
                cluster.position.x = themedAreas[0].x + (Math.random() - 0.5) * themedAreas[0].radius * 2;
                cluster.position.z = themedAreas[0].z + (Math.random() - 0.5) * themedAreas[0].radius * 2;
                scene.add(cluster);
            }
            
            // === ANCIENT RUINS (20 structures) ===
            for (let i = 0; i < 20; i++) {
                const ruin = new THREE.Group();
                
                // Broken pillars
                for (let j = 0; j < 4; j++) {
                    const pillarHeight = 2 + Math.random() * 4;
                    const pillarGeo = new THREE.CylinderGeometry(0.4, 0.5, pillarHeight, 8);
                    const pillarMat = new THREE.MeshStandardMaterial({ color: 0xD3D3D3, roughness: 0.9 });
                    const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                    pillar.position.set(
                        (j % 2) * 4 - 2,
                        pillarHeight / 2,
                        Math.floor(j / 2) * 4 - 2
                    );
                    pillar.rotation.z = (Math.random() - 0.5) * 0.3;
                    pillar.castShadow = true;
                    ruin.add(pillar);
                }
                
                // Broken archway
                const archGeo = new THREE.TorusGeometry(2.5, 0.4, 8, 16, Math.PI);
                const archMat = new THREE.MeshStandardMaterial({ color: 0xA9A9A9 });
                const arch = new THREE.Mesh(archGeo, archMat);
                arch.rotation.x = Math.PI / 2;
                arch.position.y = 3;
                ruin.add(arch);
                
                ruin.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                ruin.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                ruin.rotation.y = Math.random() * Math.PI * 2;
                scene.add(ruin);
            }
            
            // === MAGICAL PORTALS (10) ===
            for (let i = 0; i < 10; i++) {
                const portal = new THREE.Group();
                
                // Portal frame
                const frameGeo = new THREE.TorusGeometry(2, 0.3, 8, 16);
                const frameMat = new THREE.MeshStandardMaterial({ 
                    color: 0x4B0082,
                    emissive: 0x8A2BE2,
                    emissiveIntensity: 0.5
                });
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.rotation.y = Math.PI / 2;
                
                // Portal energy
                const portalGeo = new THREE.CircleGeometry(1.8, 32);
                const portalMat = new THREE.MeshBasicMaterial({ 
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.5,
                    side: THREE.DoubleSide
                });
                const portalEnergy = new THREE.Mesh(portalGeo, portalMat);
                portalEnergy.rotation.y = Math.PI / 2;
                
                portal.add(frame, portalEnergy);
                portal.position.set(
                    (Math.random() - 0.5) * MAP_SIZE * 0.8,
                    2,
                    (Math.random() - 0.5) * MAP_SIZE * 0.8
                );
                scene.add(portal);
            }
            
            // === WINDMILLS (8) ===
            for (let i = 0; i < 8; i++) {
                const windmill = new THREE.Group();
                
                // Tower
                const towerGeo = new THREE.CylinderGeometry(1.5, 2, 8, 8);
                const towerMat = new THREE.MeshStandardMaterial({ color: 0xF5DEB3 });
                const tower = new THREE.Mesh(towerGeo, towerMat);
                tower.position.y = 4;
                tower.castShadow = true;
                
                // Blades
                const bladeGroup = new THREE.Group();
                for (let j = 0; j < 4; j++) {
                    const bladeGeo = new THREE.BoxGeometry(0.3, 4, 0.1);
                    const bladeMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const blade = new THREE.Mesh(bladeGeo, bladeMat);
                    blade.position.y = 2;
                    blade.rotation.z = (j * Math.PI / 2);
                    bladeGroup.add(blade);
                }
                bladeGroup.position.set(0, 8, 2);
                
                windmill.add(tower, bladeGroup);
                windmill.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                windmill.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.7;
                windmill.castShadow = true;
                scene.add(windmill);
            }
            
            // === WATCHTOWERS (15) ===
            for (let i = 0; i < 15; i++) {
                const tower = new THREE.Group();
                
                // Base
                const baseGeo = new THREE.CylinderGeometry(2, 2.5, 10, 8);
                const baseMat = new THREE.MeshStandardMaterial({ color: 0x696969 });
                const base = new THREE.Mesh(baseGeo, baseMat);
                base.position.y = 5;
                base.castShadow = true;
                
                // Platform
                const platformGeo = new THREE.CylinderGeometry(3, 2.5, 0.5, 8);
                const platform = new THREE.Mesh(platformGeo, baseMat);
                platform.position.y = 10.25;
                
                // Roof
                const roofGeo = new THREE.ConeGeometry(3.5, 2, 8);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 11.5;
                
                tower.add(base, platform, roof);
                tower.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                tower.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                scene.add(tower);
            }
            
            // === GIANT MUSHROOMS (Mystic Swamp - 40) ===
            for (let i = 0; i < 40; i++) {
                const mushroom = new THREE.Group();
                const height = 3 + Math.random() * 4;
                
                // Stem
                const stemGeo = new THREE.CylinderGeometry(0.6, 0.8, height, 12);
                const stemMat = new THREE.MeshStandardMaterial({ color: 0xF5F5DC });
                const stem = new THREE.Mesh(stemGeo, stemMat);
                stem.position.y = height / 2;
                
                // Cap
                const capGeo = new THREE.SphereGeometry(2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const capMat = new THREE.MeshStandardMaterial({ 
                    color: [0xFF0000, 0xFF69B4, 0x9370DB, 0x00CED1][Math.floor(Math.random() * 4)]
                });
                const cap = new THREE.Mesh(capGeo, capMat);
                cap.position.y = height + 0.5;
                
                // Spots on cap
                for (let j = 0; j < 8; j++) {
                    const spotGeo = new THREE.SphereGeometry(0.3, 8, 8);
                    const spotMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                    const spot = new THREE.Mesh(spotGeo, spotMat);
                    const angle = (j / 8) * Math.PI * 2;
                    spot.position.set(
                        Math.cos(angle) * 1.5,
                        height + 1.5,
                        Math.sin(angle) * 1.5
                    );
                    mushroom.add(spot);
                }
                
                mushroom.add(stem, cap);
                mushroom.position.x = themedAreas[4].x + (Math.random() - 0.5) * themedAreas[4].radius * 2;
                mushroom.position.z = themedAreas[4].z + (Math.random() - 0.5) * themedAreas[4].radius * 2;
                scene.add(mushroom);
            }
            
            // === ICE SPIKES (Frozen Tundra - 60) ===
            for (let i = 0; i < 60; i++) {
                const height = 2 + Math.random() * 5;
                const spikeGeo = new THREE.ConeGeometry(0.5, height, 6);
                const spikeMat = new THREE.MeshStandardMaterial({ 
                    color: 0xE0FFFF,
                    transparent: true,
                    opacity: 0.8,
                    emissive: 0xADD8E6,
                    emissiveIntensity: 0.2
                });
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                spike.position.set(
                    themedAreas[2].x + (Math.random() - 0.5) * themedAreas[2].radius * 2,
                    height / 2,
                    themedAreas[2].z + (Math.random() - 0.5) * themedAreas[2].radius * 2
                );
                spike.castShadow = true;
                scene.add(spike);
            }
            
            // === LAVA POOLS (Volcanic Wasteland - 20) ===
            for (let i = 0; i < 20; i++) {
                const pool = new THREE.Group();
                const radius = 2 + Math.random() * 3;
                
                // Lava surface
                const lavaGeo = new THREE.CircleGeometry(radius, 32);
                const lavaMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFF4500,
                    emissive: 0xFF6347,
                    emissiveIntensity: 0.8
                });
                const lava = new THREE.Mesh(lavaGeo, lavaMat);
                lava.rotation.x = -Math.PI / 2;
                lava.position.y = 0.1;
                
                // Rock rim
                const rimGeo = new THREE.TorusGeometry(radius, 0.3, 8, 32);
                const rimMat = new THREE.MeshStandardMaterial({ color: 0x2F4F4F });
                const rim = new THREE.Mesh(rimGeo, rimMat);
                rim.rotation.x = Math.PI / 2;
                rim.position.y = 0.1;
                
                pool.add(lava, rim);
                pool.position.x = themedAreas[3].x + (Math.random() - 0.5) * themedAreas[3].radius * 2;
                pool.position.z = themedAreas[3].z + (Math.random() - 0.5) * themedAreas[3].radius * 2;
                scene.add(pool);
            }
            
            // === AUTUMN TREES (Autumn Forest - 100) ===
            const autumnColors = [0xFF8C00, 0xFF4500, 0xFFD700, 0xDC143C];
            for (let i = 0; i < 100; i++) {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkGeo = new THREE.CylinderGeometry(0.4, 0.5, 5, 8);
                const trunkMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = 2.5;
                
                // Foliage
                const foliageGeo = new THREE.SphereGeometry(2, 8, 8);
                const foliageMat = new THREE.MeshStandardMaterial({ 
                    color: autumnColors[Math.floor(Math.random() * autumnColors.length)]
                });
                const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                foliage.position.y = 6;
                
                tree.add(trunk, foliage);
                tree.position.x = themedAreas[1].x + (Math.random() - 0.5) * themedAreas[1].radius * 2;
                tree.position.z = themedAreas[1].z + (Math.random() - 0.5) * themedAreas[1].radius * 2;
                tree.castShadow = true;
                scene.add(tree);
            }
            
            // === OBELISKS (25) ===
            for (let i = 0; i < 25; i++) {
                const obelisk = new THREE.Group();
                const height = 6 + Math.random() * 4;
                
                // Main pillar
                const pillarGeo = new THREE.BoxGeometry(1, height, 1);
                const pillarMat = new THREE.MeshStandardMaterial({ 
                    color: 0x2F4F4F,
                    emissive: 0x00CED1,
                    emissiveIntensity: 0.3
                });
                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                pillar.position.y = height / 2;
                
                // Pyramid top
                const topGeo = new THREE.ConeGeometry(0.7, 1, 4);
                const top = new THREE.Mesh(topGeo, pillarMat);
                top.position.y = height + 0.5;
                top.rotation.y = Math.PI / 4;
                
                obelisk.add(pillar, top);
                obelisk.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                obelisk.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                obelisk.castShadow = true;
                scene.add(obelisk);
            }
            
            // === STONE CIRCLES (Mystical Sites - 12) ===
            for (let i = 0; i < 12; i++) {
                const circle = new THREE.Group();
                const radius = 5 + Math.random() * 3;
                const numStones = 8 + Math.floor(Math.random() * 4);
                
                for (let j = 0; j < numStones; j++) {
                    const angle = (j / numStones) * Math.PI * 2;
                    const stoneHeight = 3 + Math.random() * 2;
                    const stoneGeo = new THREE.BoxGeometry(1, stoneHeight, 0.8);
                    const stoneMat = new THREE.MeshStandardMaterial({ color: 0x696969 });
                    const stone = new THREE.Mesh(stoneGeo, stoneMat);
                    stone.position.set(
                        Math.cos(angle) * radius,
                        stoneHeight / 2,
                        Math.sin(angle) * radius
                    );
                    stone.rotation.y = angle;
                    stone.castShadow = true;
                    circle.add(stone);
                }
                
                circle.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                circle.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.85;
                scene.add(circle);
            }
            
            // === ROPE BRIDGES (15) ===
            for (let i = 0; i < 15; i++) {
                const bridge = new THREE.Group();
                const length = 15 + Math.random() * 10;
                
                // Wooden planks
                for (let j = 0; j < length; j++) {
                    const plankGeo = new THREE.BoxGeometry(2, 0.2, 1);
                    const plankMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const plank = new THREE.Mesh(plankGeo, plankMat);
                    plank.position.z = j;
                    plank.rotation.x = Math.sin(j * 0.5) * 0.1;
                    bridge.add(plank);
                }
                
                // Rope sides
                const ropeGeo = new THREE.CylinderGeometry(0.05, 0.05, length, 8);
                const ropeMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
                const rope1 = new THREE.Mesh(ropeGeo, ropeMat);
                rope1.rotation.x = Math.PI / 2;
                rope1.position.set(1, 0.5, length / 2);
                const rope2 = rope1.clone();
                rope2.position.x = -1;
                bridge.add(rope1, rope2);
                
                bridge.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                bridge.position.y = 2;
                bridge.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.8;
                bridge.rotation.y = Math.random() * Math.PI * 2;
                scene.add(bridge);
            }
            
            // === GLOWING ORB GARDENS (30 clusters) ===
            for (let i = 0; i < 30; i++) {
                const cluster = new THREE.Group();
                const numOrbs = 5 + Math.floor(Math.random() * 10);
                
                for (let j = 0; j < numOrbs; j++) {
                    const orbSize = 0.2 + Math.random() * 0.4;
                    const orbGeo = new THREE.SphereGeometry(orbSize, 16, 16);
                    const orbColor = [0x00FF00, 0x00FFFF, 0xFF00FF, 0xFFFF00][Math.floor(Math.random() * 4)];
                    const orbMat = new THREE.MeshStandardMaterial({ 
                        color: orbColor,
                        emissive: orbColor,
                        emissiveIntensity: 0.8
                    });
                    const orb = new THREE.Mesh(orbGeo, orbMat);
                    orb.position.set(
                        (Math.random() - 0.5) * 5,
                        0.5 + Math.random() * 2,
                        (Math.random() - 0.5) * 5
                    );
                    cluster.add(orb);
                }
                
                cluster.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                cluster.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.9;
                scene.add(cluster);
            }
            
            // === DECORATIVE WELLS (20) ===
            for (let i = 0; i < 20; i++) {
                const well = new THREE.Group();
                
                // Stone wall
                const wallGeo = new THREE.CylinderGeometry(1.2, 1.2, 1.5, 12);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
                const wall = new THREE.Mesh(wallGeo, wallMat);
                wall.position.y = 0.75;
                
                // Roof supports
                const post1Geo = new THREE.CylinderGeometry(0.1, 0.1, 2.5, 8);
                const postMat = new THREE.MeshStandardMaterial({ color: 0x654321 });
                const post1 = new THREE.Mesh(post1Geo, postMat);
                post1.position.set(-1.2, 2, 0);
                const post2 = post1.clone();
                post2.position.x = 1.2;
                
                // Roof
                const roofGeo = new THREE.ConeGeometry(1.5, 1, 8);
                const roofMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.y = 4;
                
                // Bucket
                const bucketGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.4, 8);
                const bucketMat = new THREE.MeshStandardMaterial({ color: 0x8B7355 });
                const bucket = new THREE.Mesh(bucketGeo, bucketMat);
                bucket.position.set(0, 1, 0.8);
                
                well.add(wall, post1, post2, roof, bucket);
                well.position.x = (Math.random() - 0.5) * MAP_SIZE * 0.75;
                well.position.z = (Math.random() - 0.5) * MAP_SIZE * 0.75;
                well.castShadow = true;
                scene.add(well);
            }
            
            console.log('Massive world content created with themed areas!');
        }
        function createPlayer() {
            // Create more realistic player character with customizable appearance
            const playerGroup = new THREE.Group();
            const appearance = currentPlayer.appearance || {
                skinColor: 0xffdbac,
                hairColor: 0x4a2511,
                bodyColor: 0x3498db,
                pantsColor: 0x2c3e50,
                hairStyle: 'short'
            };

            // Body - more realistic torso with custom color
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.0, 0.5);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: appearance.bodyColor,
                roughness: 0.7,
                metalness: 0.1
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 1.0;
            body.castShadow = true;
            body.receiveShadow = true;
            body.name = 'body';
            playerGroup.add(body);

            // Head - more realistic size and shape with custom skin color
            const headGeometry = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: appearance.skinColor,
                roughness: 0.8
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.73;
            head.castShadow = true;
            head.receiveShadow = true;
            head.name = 'head';
            playerGroup.add(head);

            // Hair/helmet detail with custom style
            if (appearance.hairStyle === 'short') {
                const hairGeometry = new THREE.BoxGeometry(0.48, 0.2, 0.48);
                const hairMaterial = new THREE.MeshStandardMaterial({ color: appearance.hairColor });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 1.95;
                hair.castShadow = true;
                hair.name = 'hair';
                playerGroup.add(hair);
            } else if (appearance.hairStyle === 'long') {
                const hairGeometry = new THREE.BoxGeometry(0.48, 0.35, 0.48);
                const hairMaterial = new THREE.MeshStandardMaterial({ color: appearance.hairColor });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 2.0;
                hair.castShadow = true;
                hair.name = 'hair';
                playerGroup.add(hair);
            } else if (appearance.hairStyle === 'spiky') {
                // Create spiky hair with multiple boxes
                const spikeGeometry = new THREE.BoxGeometry(0.15, 0.25, 0.15);
                const hairMaterial = new THREE.MeshStandardMaterial({ color: appearance.hairColor });
                for (let i = 0; i < 5; i++) {
                    const spike = new THREE.Mesh(spikeGeometry, hairMaterial);
                    const angle = (i / 5) * Math.PI * 2;
                    spike.position.x = Math.cos(angle) * 0.15;
                    spike.position.y = 2.05;
                    spike.position.z = Math.sin(angle) * 0.15;
                    spike.castShadow = true;
                    spike.name = 'hair';
                    playerGroup.add(spike);
                }
            }

            // Arms - better proportions with custom color
            const armGeometry = new THREE.BoxGeometry(0.25, 0.9, 0.25);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: appearance.bodyColor,
                roughness: 0.7,
                metalness: 0.1
            });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.55, 1.0, 0);
            leftArm.castShadow = true;
            leftArm.receiveShadow = true;
            leftArm.name = 'leftArm';
            playerGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.55, 1.0, 0);
            rightArm.castShadow = true;
            rightArm.receiveShadow = true;
            rightArm.name = 'rightArm';
            playerGroup.add(rightArm);

            // Hands with custom skin color
            const handGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.2);
            const handMaterial = new THREE.MeshStandardMaterial({ color: appearance.skinColor });
            
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.55, 0.5, 0);
            leftHand.castShadow = true;
            leftHand.name = 'leftHand';
            playerGroup.add(leftHand);

            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.55, 0.5, 0);
            rightHand.castShadow = true;
            rightHand.name = 'rightHand';
            playerGroup.add(rightHand);

            // Legs - more realistic proportions with custom pants color
            const legGeometry = new THREE.BoxGeometry(0.3, 0.9, 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: appearance.pantsColor,
                roughness: 0.9
            });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.25, 0.45, 0);
            leftLeg.castShadow = true;
            leftLeg.receiveShadow = true;
            leftLeg.name = 'leftLeg';
            playerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.25, 0.45, 0);
            rightLeg.castShadow = true;
            rightLeg.receiveShadow = true;
            rightLeg.name = 'rightLeg';
            playerGroup.add(rightLeg);

            // Boots/feet
            const bootGeometry = new THREE.BoxGeometry(0.32, 0.15, 0.4);
            const bootMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
            
            const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            leftBoot.position.set(-0.25, 0.08, 0.05);
            leftBoot.castShadow = true;
            leftBoot.name = 'leftBoot';
            playerGroup.add(leftBoot);

            const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
            rightBoot.position.set(0.25, 0.08, 0.05);
            rightBoot.castShadow = true;
            rightBoot.name = 'rightBoot';
            playerGroup.add(rightBoot);

            // Belt detail
            const beltGeometry = new THREE.BoxGeometry(0.82, 0.1, 0.52);
            const beltMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 0.5;
            belt.castShadow = true;
            belt.name = 'belt';
            playerGroup.add(belt);

            playerGroup.position.set(currentPlayer.x, currentPlayer.y, currentPlayer.z);
            playerMesh = playerGroup;
            scene.add(playerMesh);

            // Add equipped weapon if any
            if (currentPlayer.equipment.weapon) {
                addWeaponToPlayer(playerMesh, currentPlayer.equipment.weapon);
            }

            // Add name label
            createNameLabel(playerGroup, currentPlayer.name, 0xf39c12);
        }
        
        function addWeaponToPlayer(playerGroup, weaponName) {
            // Remove existing weapon if any
            if (equippedWeaponMesh) {
                playerGroup.remove(equippedWeaponMesh);
                equippedWeaponMesh = null;
            }
            
            if (!weaponName) return;
            
            // Create weapon mesh based on weapon type
            const weaponGroup = new THREE.Group();
            weaponGroup.name = 'weapon';
            
            if (weaponName.includes('Sword')) {
                // Create sword - larger and more visible
                // Handle/grip
                const handleGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
                const handleMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x654321,
                    roughness: 0.7
                });
                const handle = new THREE.Mesh(handleGeometry, handleMaterial);
                handle.castShadow = true;
                weaponGroup.add(handle);
                
                // Guard
                const guardGeometry = new THREE.BoxGeometry(0.4, 0.08, 0.12);
                const guardMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x888888, 
                    metalness: 0.9,
                    roughness: 0.3
                });
                const guard = new THREE.Mesh(guardGeometry, guardMaterial);
                guard.position.y = 0.25;
                guard.castShadow = true;
                weaponGroup.add(guard);
                
                // Blade - wider and more prominent
                const bladeGeometry = new THREE.BoxGeometry(0.15, 1.0, 0.04);
                const bladeColor = weaponName.includes('Dragon') ? 0xff4444 : 
                                  weaponName.includes('Steel') ? 0xcccccc : 
                                  weaponName.includes('Iron') ? 0x999999 : 0xaaaaaa;
                const bladeMaterial = new THREE.MeshStandardMaterial({ 
                    color: bladeColor,
                    metalness: 0.95,
                    roughness: 0.1,
                    emissive: bladeColor,
                    emissiveIntensity: 0.1
                });
                const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
                blade.position.y = 0.75;
                blade.castShadow = true;
                weaponGroup.add(blade);
                
                // Blade tip
                const tipGeometry = new THREE.ConeGeometry(0.08, 0.2, 4);
                const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
                tip.position.y = 1.35;
                tip.castShadow = true;
                weaponGroup.add(tip);
                
                // Pommel
                const pommelGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const pommel = new THREE.Mesh(pommelGeometry, guardMaterial);
                pommel.position.y = -0.25;
                pommel.castShadow = true;
                weaponGroup.add(pommel);
                
                // Position sword in right hand - more visible
                weaponGroup.position.set(0.6, 0.5, 0.15);
                weaponGroup.rotation.z = Math.PI / 6; // Less angle for better visibility
                
            } else if (weaponName.includes('Staff')) {
                // Create magic staff
                const staffGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8);
                const staffMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                const staff = new THREE.Mesh(staffGeometry, staffMaterial);
                staff.castShadow = true;
                weaponGroup.add(staff);
                
                // Magical orb on top
                const orbGeometry = new THREE.SphereGeometry(0.12, 16, 16);
                const orbMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x9966ff,
                    emissive: 0x6633cc,
                    emissiveIntensity: 0.5
                });
                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                orb.position.y = 0.7;
                orb.castShadow = true;
                weaponGroup.add(orb);
                
                // Position staff in right hand
                weaponGroup.position.set(0.55, 0.4, 0);
            }
            
            playerGroup.add(weaponGroup);
            equippedWeaponMesh = weaponGroup;
        }
        
        function createHouses() {
            HOUSES.forEach(houseData => {
                // Store door position for collision detection
                const doorX = houseData.x;
                const doorZ = houseData.z + houseData.depth / 2;
                const doorWidth = houseData.width * 0.3;
                
                const house = {
                    x: houseData.x,
                    z: houseData.z,
                    width: houseData.width,
                    depth: houseData.depth,
                    height: houseData.height,
                    name: houseData.name,
                    doorX: doorX,
                    doorZ: doorZ,
                    doorWidth: doorWidth
                };
                
                const houseGroup = new THREE.Group();
                
                // Foundation
                const foundationGeometry = new THREE.BoxGeometry(houseData.width + 0.4, 0.3, houseData.depth + 0.4);
                const foundationMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x696969,
                    roughness: 0.95
                });
                const foundation = new THREE.Mesh(foundationGeometry, foundationMaterial);
                foundation.position.y = 0.15;
                foundation.receiveShadow = true;
                houseGroup.add(foundation);
                
                // Walls with texture-like appearance
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: houseData.color,
                    roughness: 0.85,
                    metalness: 0.1
                });
                const wallGeometry = new THREE.BoxGeometry(houseData.width, houseData.height, houseData.depth);
                const walls = new THREE.Mesh(wallGeometry, wallMaterial);
                walls.position.y = houseData.height / 2 + 0.3;
                walls.castShadow = true;
                walls.receiveShadow = true;
                walls.name = 'walls';
                houseGroup.add(walls);
                
                // Wall trim/borders
                const trimMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7
                });
                
                // Bottom trim
                const bottomTrimGeo = new THREE.BoxGeometry(houseData.width + 0.1, 0.1, houseData.depth + 0.1);
                const bottomTrim = new THREE.Mesh(bottomTrimGeo, trimMaterial);
                bottomTrim.position.y = 0.35;
                houseGroup.add(bottomTrim);
                
                // Roof (pyramid shape with better proportions)
                const roofGeometry = new THREE.ConeGeometry(
                    Math.max(houseData.width, houseData.depth) * 0.75, 
                    houseData.height * 0.5, 
                    4
                );
                const roofMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b0000,
                    roughness: 0.85,
                    metalness: 0.05
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.y = houseData.height + houseData.height * 0.25 + 0.3;
                roof.rotation.y = Math.PI / 4;
                roof.castShadow = true;
                roof.receiveShadow = true;
                roof.name = 'roof';
                houseGroup.add(roof);
                
                // Chimney (for some houses)
                if (Math.random() > 0.5) {
                    const chimneyGeo = new THREE.BoxGeometry(0.4, houseData.height * 0.6, 0.4);
                    const chimneyMat = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.9
                    });
                    const chimney = new THREE.Mesh(chimneyGeo, chimneyMat);
                    chimney.position.set(houseData.width * 0.3, houseData.height + houseData.height * 0.3 + 0.3, -housseData.height * 0.3 + 0.3, -houseData.depth * 0.3);
                    chimney.castShadow = true;
                    houseGroup.add(chimney);
                }
                
                // Enhanced Door with frame
                const doorFrameGeo = new THREE.BoxGeometry(houseData.width * 0.35, houseData.height * 0.55, 0.15);
                const doorFrameMat = new THREE.MeshStandardMaterial({ color: 0x4A4A4A });
                const doorFrame = new THREE.Mesh(doorFrameGeo, doorFrameMat);
                doorFrame.position.set(0, houseData.height * 0.275 + 0.3, houseData.depth / 2 + 0.08);
                doorFrame.castShadow = true;
                houseGroup.add(doorFrame);
                
                const doorGeometry = new THREE.BoxGeometry(houseData.width * 0.3, houseData.height * 0.5, 0.12);
                const doorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x654321,
                    roughness: 0.6
                });
                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.set(0, houseData.height * 0.25 + 0.3, houseData.depth / 2 + 0.1);
                door.castShadow = true;
                door.name = 'door';
                houseGroup.add(door);
                
                // Door handle
                const handleGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const handleMat = new THREE.MeshStandardMaterial({ 
                    color: 0xFFD700,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const handle = new THREE.Mesh(handleGeo, handleMat);
                handle.position.set(houseData.width * 0.12, houseData.height * 0.25 + 0.3, houseData.depth / 2 + 0.17);
                houseGroup.add(handle);
                
                // Enhanced Windows with frames
                const windowFrameGeo = new THREE.BoxGeometry(houseData.width * 0.18, houseData.height * 0.23, 0.15);
                const windowFrameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                // Left window frame
                const leftWindowFrame = new THREE.Mesh(windowFrameGeo, windowFrameMat);
                leftWindowFrame.position.set(-houseData.width * 0.3, houseData.height * 0.6 + 0.3, houseData.depth / 2 + 0.08);
                houseGroup.add(leftWindowFrame);
                
                // Left window pane
                const windowGeometry = new THREE.BoxGeometry(houseData.width * 0.15, houseData.height * 0.2, 0.12);
                const windowMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.7,
                    metalness: 0.3,
                    roughness: 0.1
                });
                const leftWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                leftWindow.position.set(-houseData.width * 0.3, houseData.height * 0.6 + 0.3, houseData.depth / 2 + 0.1);
                houseGroup.add(leftWindow);
                
                // Right window frame
                const rightWindowFrame = new THREE.Mesh(windowFrameGeo, windowFrameMat);
                rightWindowFrame.position.set(houseData.width * 0.3, houseData.height * 0.6 + 0.3, houseData.depth / 2 + 0.08);
                houseGroup.add(rightWindowFrame);
                
                // Right window pane
                const rightWindow = new THREE.Mesh(windowGeometry, windowMaterial);
                rightWindow.position.set(houseData.width * 0.3, houseData.height * 0.6 + 0.3, houseData.depth / 2 + 0.1);
                houseGroup.add(rightWindow);
                
                // Window cross dividers
                const dividerGeo = new THREE.BoxGeometry(houseData.width * 0.15, 0.05, 0.05);
                const dividerMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
                
                const leftDivider = new THREE.Mesh(dividerGeo, dividerMat);
                leftDivider.position.set(-houseData.width * 0.3, houseData.height * 0.6 + 0.3, houseData.depth / 2 + 0.15);
                houseGroup.add(leftDivider);
                
                const rightDivider = new THREE.Mesh(dividerGeo, dividerMat);
                rightDivider.position.set(houseData.width * 0.3, houseData.height * 0.6 + 0.3, houseData.depth / 2 + 0.15);
                houseGroup.add(rightDivider);
                
                // Add desk for functional NPCs (bank, shop, pet shop)
                if (houseData.hasDesk) {
                    // Desk top
                    const deskTopGeo = new THREE.BoxGeometry(houseData.width * 0.5, 0.1, houseData.depth * 0.25);
                    const deskMat = new THREE.MeshStandardMaterial({ 
                        color: 0x8B4513,
                        roughness: 0.7
                    });
                    const deskTop = new THREE.Mesh(deskTopGeo, deskMat);
                    deskTop.position.set(0, 0.9, -houseData.depth * 0.25);
                    deskTop.castShadow = true;
                    houseGroup.add(deskTop);
                    
                    // Desk legs
                    const legGeo = new THREE.BoxGeometry(0.1, 0.8, 0.1);
                    const positions = [
                        [-houseData.width * 0.2, 0.4, -houseData.depth * 0.15],
                        [houseData.width * 0.2, 0.4, -houseData.depth * 0.15],
                        [-houseData.width * 0.2, 0.4, -houseData.depth * 0.35],
                        [houseData.width * 0.2, 0.4, -houseData.depth * 0.35]
                    ];
                    
                    positions.forEach(pos => {
                        const leg = new THREE.Mesh(legGeo, deskMat);
                        leg.position.set(...pos);
                        leg.castShadow = true;
                        houseGroup.add(leg);
                    });
                    
                    // Chair
                    const chairSeatGeo = new THREE.BoxGeometry(0.4, 0.1, 0.4);
                    const chairSeat = new THREE.Mesh(chairSeatGeo, deskMat);
                    chairSeat.position.set(0, 0.5, -houseData.depth * 0.25 - 0.5);
                    chairSeat.castShadow = true;
                    houseGroup.add(chairSeat);
                    
                    const chairBackGeo = new THREE.BoxGeometry(0.4, 0.5, 0.1);
                    const chairBack = new THREE.Mesh(chairBackGeo, deskMat);
                    chairBack.position.set(0, 0.75, -houseData.depth * 0.25 - 0.7);
                    chairBack.castShadow = true;
                    houseGroup.add(chairBack);
                }
                
                houseGroup.position.set(houseData.x, 0, houseData.z);
                houseGroup.userData = house;
                houseMeshes.push(houseGroup);
                scene.add(houseGroup);
                houses.push(house);
            });
        }
        
        function updateHouseVisibility() {
            // Check if player is inside any house and make roof/walls transparent
            let insideHouse = false;
            houseMeshes.forEach(houseGroup => {
                const house = houseGroup.userData;
                
                // Check if player is near the door (entry point)
                const atDoor = 
                    Math.abs(currentPlayer.x - house.doorX) < house.doorWidth / 2 + 1 &&
                    Math.abs(currentPlayer.z - house.doorZ) < 1.5;
                
                const playerInHouse = 
                    currentPlayer.x > house.x - house.width/2 &&
                    currentPlayer.x < house.x + house.width/2 &&
                    currentPlayer.z > house.z - house.depth/2 &&
                    currentPlayer.z < house.z + house.depth/2;
                
                // Only allow entry through the door
                if (playerInHouse && !atDoor && !playerInsideHouse) {
                    // Block entry - push player back to nearest edge
                    const distToFront = Math.abs(currentPlayer.z - (house.z + house.depth/2));
                    const distToBack = Math.abs(currentPlayer.z - (house.z - house.depth/2));
                    const distToLeft = Math.abs(currentPlayer.x - (house.x - house.width/2));
                    const distToRight = Math.abs(currentPlayer.x - (house.x + house.width/2));
                    
                    const minDist = Math.min(distToFront, distToBack, distToLeft, distToRight);
                    
                    if (minDist === distToFront) currentPlayer.z = house.z + house.depth/2 + 0.5;
                    else if (minDist === distToBack) currentPlayer.z = house.z - house.depth/2 - 0.5;
                    else if (minDist === distToLeft) currentPlayer.x = house.x - house.width/2 - 0.5;
                    else currentPlayer.x = house.x + house.width/2 + 0.5;
                } else if (playerInHouse) {
                    insideHouse = true;
                }
                
                // Make roof and walls semi-transparent when inside
                houseGroup.children.forEach(child => {
                    if (child.name === 'roof') {
                        child.visible = !playerInHouse;
                    }
                    if (child.name === 'walls' && playerInHouse) {
                        child.material.transparent = true;
                        child.material.opacity = 0.3;
                    } else if (child.name === 'walls') {
                        child.material.transparent = false;
                        child.material.opacity = 1.0;
                    }
                });
            });
            
            playerInsideHouse = insideHouse;
            
            // Make player always visible (remove any opacity changes)
            if (playerMesh) {
                playerMesh.traverse(child => {
                    if (child.material) {
                        child.material.transparent = false;
                        child.material.opacity = 1.0;
                    }
                });
            }
        }
        
        function createNPCs() {
            NPCS.forEach(npcData => {
                const npc = {
                    npcId: npcData.id,
                    name: npcData.name,
                    x: npcData.x,
                    z: npcData.z,
                    type: npcData.type,
                    dialogue: npcData.dialogue
                };
                
                const npcGroup = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(0.6, 1.0, 0.4);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: npcData.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                body.castShadow = true;
                npcGroup.add(body);
                
                // Head
                const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                head.castShadow = true;
                npcGroup.add(head);
                
                // Quest indicator
                if (npcData.type === 'quest') {
                    const indicatorGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                    const indicatorMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffff00,
                        emissive: 0xffff00,
                        emissiveIntensity: 0.5
                    });
                    const indicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                    indicator.position.y = 2.2;
                    npcGroup.add(indicator);
                }
                
                npcGroup.position.set(npcData.x, 0, npcData.z);
                npcGroup.userData = npc;
                npcMeshes.push(npcGroup);
                scene.add(npcGroup);
                npcData.mesh = npcGroup;
                
                // Add name label
                createNameLabel(npcGroup, npcData.name, 0x00ff00);
            });
        }
        
        function interactWithNPC(npc) {
            addChatMessage(npc.name, npc.dialogue, 'npc');
            
            // Update quest progress for talking to this NPC
            updateQuestProgress('talk', npc.name);
            
            if (npc.type === 'shop') {
                openShop();
            } else if (npc.type === 'pet') {
                openPetShop();
            } else if (npc.type === 'bank') {
                openBank();
            } else if (npc.type === 'quest') {
                openQuestDialogue(npc);
            }
        }
        
        function openPetShop() {
            // Create pet shop UI
            const panel = document.getElementById('shopPanel');
            if (!panel) return;
            
            panel.classList.add('active');
            const shopDiv = document.getElementById('shopItems');
            document.getElementById('shopGold').textContent = currentPlayer.gold;
            shopDiv.innerHTML = '<h3 style=\"color: #9370db; margin-bottom: 1rem;\">🐾 Pet Shop</h3>';
            
            Object.entries(PETS).forEach(([petName, petData]) => {
                const itemEl = document.createElement('div');
                itemEl.style.background = 'rgba(147, 112, 219, 0.2)';
                itemEl.style.padding = '1rem';
                itemEl.style.borderRadius = '5px';
                itemEl.style.marginBottom = '0.5rem';
                itemEl.style.border = currentPlayer.pet === petName ? '2px solid #9370db' : 'none';
                
                itemEl.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${petData.icon} ${petName}</strong> (Lv.${petData.level})
                            <div style="font-size: 0.8rem; color: #95a5a6;">${petData.description}</div>
                            <div style="font-size: 0.8rem; color: #95a5a6;">Damage: +${petData.damage}${petData.healing ? `, Healing: +${petData.healing}` : ''}</div>
                        </div>
                        <button class="action-btn" style="padding: 0.5rem 1rem; font-size: 0.9rem;" 
                                onclick="buyPet('${petName}')" ${currentPlayer.pet === petName ? 'disabled' : ''}>
                            ${currentPlayer.pet === petName ? '✓ Owned' : `💰 ${petData.cost}`}
                        </button>
                    </div>
                `;
                shopDiv.appendChild(itemEl);
            });
        }
        
        function buyPet(petName) {
            const pet = PETS[petName];
            
            if (currentPlayer.level < pet.level) {
                addChatMessage('Pet Shop', `You need to be level ${pet.level} to buy this pet!`, 'system');
                return;
            }
            
            if (currentPlayer.gold < pet.cost) {
                addChatMessage('Pet Shop', 'Not enough gold!', 'system');
                return;
            }
            
            currentPlayer.gold -= pet.cost;
            currentPlayer.pet = petName;
            
            addChatMessage('Pet Shop', `You adopted ${petName}! 🎉`, 'system');
            
            // Remove old pet mesh
            if (petMesh) {
                scene.remove(petMesh);
                petMesh = null;
            }
            
            // Create new pet mesh
            createPetMesh();
            
            updateStats();
            openPetShop(); // Refresh
            saveGameToCloud();
        }
        
        function openQuestDialogue(npc) {
            // Find quests from this NPC
            const npcQuests = QUESTS.filter(q => 
                q.npc && (q.npc === npc.name || q.npc.replace(/\s+/g, '_').toLowerCase() === npc.npcId)
            );
            
            if (npcQuests.length === 0) {
                addChatMessage(npc.name, 'I have no quests for you right now.', 'npc');
                return;
            }
            
            // Open quest panel with this NPC's quests
            toggleQuestPanel();
        }

        function createNameLabel(parentMesh, name, color) {
            // Create canvas for name
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'Bold 32px Arial';
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.textAlign = 'center';
            context.fillText(name, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.y = 2.5;
            sprite.scale.set(2, 0.5, 1);
            parentMesh.add(sprite);
        }

        function updatePlayerMesh(playerId, playerData) {
            if (!playerMeshes[playerId]) {
                // Create new player mesh
                const playerGroup = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.4);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                body.castShadow = true;
                playerGroup.add(body);

                // Head
                const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.65;
                head.castShadow = true;
                playerGroup.add(head);

                // Arms
                const armGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.5, 0.8, 0);
                leftArm.castShadow = true;
                playerGroup.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.5, 0.8, 0);
                rightArm.castShadow = true;
                playerGroup.add(rightArm);

                // Legs
                const legGeometry = new THREE.BoxGeometry(0.25, 0.6, 0.3);
                const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.2, 0.3, 0);
                leftLeg.castShadow = true;
                playerGroup.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.2, 0.3, 0);
                rightLeg.castShadow = true;
                playerGroup.add(rightLeg);

                createNameLabel(playerGroup, playerData.name, 0x3498db);
                
                playerMeshes[playerId] = playerGroup;
                scene.add(playerGroup);
            }

            // Update position
            playerMeshes[playerId].position.set(playerData.x, playerData.y, playerData.z);
            playerMeshes[playerId].rotation.y = playerData.rotation || 0;
        }

        function initMonsters() {
            const monsterTypes = [
                { name: 'Goblin', color: 0x8B4513, hp: 30, xp: 20, level: 1, scale: 0.8 },
                { name: 'Skeleton', color: 0xD3D3D3, hp: 50, xp: 35, level: 2, scale: 0.9 },
                { name: 'Orc', color: 0x556B2F, hp: 80, xp: 50, level: 3, scale: 1.0 },
                { name: 'Dragon', color: 0x8B0000, hp: 200, xp: 150, level: 5, scale: 1.5 }
            ];

            for (let i = 0; i < 75; i++) {  // Increased from 15 for 5x bigger map
                const type = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
                const monster = {
                    id: 'monster_' + i,
                    ...type,
                    x: (Math.random() - 0.5) * MAP_SIZE,
                    y: 0,
                    z: (Math.random() - 0.5) * MAP_SIZE,
                    currentHp: type.hp,
                    maxHp: type.hp,
                    direction: Math.random() * Math.PI * 2,
                    speed: 0.02
                };
                monsters.push(monster);
                
                // Create 3D monster
                const monsterGroup = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(0.6 * type.scale, 1.0 * type.scale, 0.6 * type.scale);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: type.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5 * type.scale;
                body.castShadow = true;
                monsterGroup.add(body);

                // Head
                const headGeometry = new THREE.BoxGeometry(0.4 * type.scale, 0.4 * type.scale, 0.4 * type.scale);
                const headMaterial = new THREE.MeshStandardMaterial({ color: type.color });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.2 * type.scale;
                head.castShadow = true;
                monsterGroup.add(head);

                // Eyes (red)
                const eyeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1 * type.scale, 1.25 * type.scale, 0.2 * type.scale);
                monsterGroup.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1 * type.scale, 1.25 * type.scale, 0.2 * type.scale);
                monsterGroup.add(rightEye);

                monsterGroup.position.set(monster.x, monster.y, monster.z);
                monsterGroup.userData = monster;
                monsterMeshes.push(monsterGroup);
                scene.add(monsterGroup);

                createNameLabel(monsterGroup, `${type.name} Lv.${type.level}`, 0xff0000);
            }
        }

        function initResources() {
            const resourceTypes = [
                // Trees - Woodcutting
                { name: 'Normal Tree', color: 0x228B22, skill: 'woodcutting', item: 'Logs', height: 3, levelRequired: 1, xp: 25 },
                { name: 'Oak Tree', color: 0x8B7355, skill: 'woodcutting', item: 'Oak Logs', height: 3, levelRequired: 15, xp: 37 },
                { name: 'Willow Tree', color: 0x9ACD32, skill: 'woodcutting', item: 'Willow Logs', height: 3, levelRequired: 30, xp: 67 },
                { name: 'Maple Tree', color: 0xD2691E, skill: 'woodcutting', item: 'Maple Logs', height: 3, levelRequired: 45, xp: 100 },
                { name: 'Yew Tree', color: 0x2F4F2F, skill: 'woodcutting', item: 'Yew Logs', height: 3, levelRequired: 60, xp: 175 },
                { name: 'Magic Tree', color: 0x9370DB, skill: 'woodcutting', item: 'Magic Logs', height: 3, levelRequired: 75, xp: 250 },
                
                // Rocks - Mining
                { name: 'Copper Rock', color: 0xB87333, skill: 'mining', item: 'Copper Ore', height: 1.5, levelRequired: 1, xp: 17 },
                { name: 'Tin Rock', color: 0xC0C0C0, skill: 'mining', item: 'Tin Ore', height: 1.5, levelRequired: 1, xp: 17 },
                { name: 'Iron Rock', color: 0x696969, skill: 'mining', item: 'Iron Ore', height: 1.5, levelRequired: 15, xp: 35 },
                { name: 'Coal Rock', color: 0x1C1C1C, skill: 'mining', item: 'Coal', height: 1.5, levelRequired: 30, xp: 50 },
                { name: 'Mithril Rock', color: 0x4169E1, skill: 'mining', item: 'Mithril Ore', height: 1.5, levelRequired: 55, xp: 80 },
                { name: 'Adamant Rock', color: 0x228B22, skill: 'mining', item: 'Adamant Ore', height: 1.5, levelRequired: 70, xp: 95 },
                { name: 'Runite Rock', color: 0x00CED1, skill: 'mining', item: 'Runite Ore', height: 1.5, levelRequired: 85, xp: 125 },
                
                // Fish - Fishing
                { name: 'Shrimp Spot', color: 0xFFC0CB, skill: 'fishing', item: 'Raw Shrimp', height: 0.3, levelRequired: 1, xp: 10 },
                { name: 'Sardine Spot', color: 0xC0C0C0, skill: 'fishing', item: 'Raw Sardine', height: 0.3, levelRequired: 5, xp: 20 },
                { name: 'Trout Spot', color: 0x4169E1, skill: 'fishing', item: 'Raw Trout', height: 0.3, levelRequired: 20, xp: 50 },
                { name: 'Salmon Spot', color: 0xFF6347, skill: 'fishing', item: 'Raw Salmon', height: 0.3, levelRequired: 30, xp: 70 },
                { name: 'Tuna Spot', color: 0x191970, skill: 'fishing', item: 'Raw Tuna', height: 0.3, levelRequired: 35, xp: 80 },
                { name: 'Lobster Spot', color: 0xDC143C, skill: 'fishing', item: 'Raw Lobster', height: 0.3, levelRequired: 40, xp: 90 },
                { name: 'Swordfish Spot', color: 0x000080, skill: 'fishing', item: 'Raw Swordfish', height: 0.3, levelRequired: 50, xp: 100 },
                { name: 'Shark Spot', color: 0x2F4F4F, skill: 'fishing', item: 'Raw Shark', height: 0.3, levelRequired: 76, xp: 110 }
            ];

            for (let i = 0; i < 300; i++) {  // Increased resource count for larger map
                const type = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                const resource = {
                    id: 'resource_' + i,
                    ...type,
                    x: (Math.random() - 0.5) * MAP_SIZE,
                    y: 0,
                    z: (Math.random() - 0.5) * MAP_SIZE,
                    available: true
                };
                resources.push(resource);

                // Create 3D resource
                let resourceMesh;
                
                if (type.skill === 'woodcutting') {  // Trees
                    const treeGroup = new THREE.Group();
                    
                    // Different trunk colors and sizes for tree types
                    let trunkColor = 0x8B4513;  // Default brown
                    let trunkRadius = 0.2;
                    let trunkHeight = 1.5;
                    let leavesShape = 'sphere';  // Default shape
                    let leavesSize = 1;
                    
                    if (type.name.includes('Oak')) {
                        trunkColor = 0x654321;
                        trunkRadius = 0.25;
                        trunkHeight = 2;
                        leavesSize = 1.2;
                        leavesShape = 'sphere';
                    } else if (type.name.includes('Willow')) {
                        trunkColor = 0x8B7355;
                        trunkRadius = 0.18;
                        trunkHeight = 2.5;
                        leavesSize = 1.3;
                        leavesShape = 'cone';
                    } else if (type.name.includes('Maple')) {
                        trunkColor = 0x5C4033;
                        trunkRadius = 0.22;
                        trunkHeight = 2.2;
                        leavesSize = 1.4;
                        leavesShape = 'sphere';
                    } else if (type.name.includes('Yew')) {
                        trunkColor = 0x3D2817;
                        trunkRadius = 0.28;
                        trunkHeight = 2.5;
                        leavesSize = 1.5;
                        leavesShape = 'cone';
                    } else if (type.name.includes('Magic')) {
                        trunkColor = 0x6A0DAD;
                        trunkRadius = 0.3;
                        trunkHeight = 3;
                        leavesSize = 1.6;
                        leavesShape = 'octahedron';
                    }
                    
                    // Trunk
                    const trunkGeometry = new THREE.CylinderGeometry(trunkRadius, trunkRadius + 0.05, trunkHeight, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: trunkColor, roughness: 0.9 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = trunkHeight / 2;
                    trunk.castShadow = true;
                    treeGroup.add(trunk);

                    // Leaves with different shapes
                    let leavesGeometry;
                    if (leavesShape === 'cone') {
                        leavesGeometry = new THREE.ConeGeometry(leavesSize, leavesSize * 2, 8);
                    } else if (leavesShape === 'octahedron') {
                        leavesGeometry = new THREE.OctahedronGeometry(leavesSize, 0);
                    } else {
                        leavesGeometry = new THREE.SphereGeometry(leavesSize, 8, 8);
                    }
                    const leavesMaterial = new THREE.MeshStandardMaterial({ color: type.color });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.y = trunkHeight + leavesSize;
                    leaves.castShadow = true;
                    treeGroup.add(leaves);

                    resourceMesh = treeGroup;
                } else if (type.skill === 'mining') {  // Rocks
                    // Different shapes for rock types
                    let rockGeometry;
                    let rockSize = 0.8;
                    
                    if (type.name.includes('Copper') || type.name.includes('Tin')) {
                        rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
                    } else if (type.name.includes('Iron') || type.name.includes('Coal')) {
                        rockGeometry = new THREE.IcosahedronGeometry(rockSize, 0);
                        rockSize = 0.9;
                    } else if (type.name.includes('Mithril')) {
                        rockGeometry = new THREE.OctahedronGeometry(rockSize, 0);
                        rockSize = 1.0;
                    } else if (type.name.includes('Adamant')) {
                        rockGeometry = new THREE.TetrahedronGeometry(rockSize, 0);
                        rockSize = 1.1;
                    } else if (type.name.includes('Runite')) {
                        rockGeometry = new THREE.DodecahedronGeometry(rockSize, 1);
                        rockSize = 1.2;
                    } else {
                        rockGeometry = new THREE.DodecahedronGeometry(rockSize, 0);
                    }
                    
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: type.color, roughness: 0.9 });
                    resourceMesh = new THREE.Mesh(rockGeometry, rockMaterial);
                    resourceMesh.position.y = rockSize * 0.5;
                    resourceMesh.castShadow = true;
                } else { // Fish Spot
                    const waterGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 16);
                    const waterMaterial = new THREE.MeshStandardMaterial({ 
                        color: type.color, 
                        transparent: true, 
                        opacity: 0.7,
                        roughness: 0.1
                    });
                    resourceMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                    resourceMesh.position.y = 0.1;
                    resourceMesh.receiveShadow = true;
                }

                resourceMesh.position.x = resource.x;
                resourceMesh.position.z = resource.z;
                resourceMesh.userData = resource;
                resourceMeshes.push(resourceMesh);
                scene.add(resourceMesh);
            }
        }

        // === A* PATHFINDING SYSTEM ===
        function isObstacle(x, z) {
            // Check if position collides with houses (except at doors)
            for (let house of houses) {
                const inHouseBounds = 
                    x > house.x - house.width/2 &&
                    x < house.x + house.width/2 &&
                    z > house.z - house.depth/2 &&
                    z < house.z + house.depth/2;
                
                if (inHouseBounds) {
                    // Check if at door
                    const atDoor = 
                        Math.abs(x - house.doorX) < house.doorWidth / 2 + 0.5 &&
                        Math.abs(z - house.doorZ) < 1.5;
                    
                    if (!atDoor) return true; // Blocked by house
                }
            }
            
            // Check if position is near monsters (optional obstacle avoidance)
            for (let monster of monsters) {
                if (monster.currentHp > 0) {
                    const distToMonster = Math.hypot(x - monster.x, z - monster.z);
                    if (distToMonster < 1.5) return true; // Too close to monster
                }
            }
            
            return false;
        }

        function findPath(startX, startZ, endX, endZ) {
            // Simple A* pathfinding implementation
            const gridSize = 2; // Grid cell size
            const maxIterations = 500; // Prevent infinite loops
            
            // Convert world coordinates to grid coordinates
            const startNode = {
                x: Math.round(startX / gridSize),
                z: Math.round(startZ / gridSize),
                g: 0,
                h: 0,
                f: 0,
                parent: null
            };
            
            const endNode = {
                x: Math.round(endX / gridSize),
                z: Math.round(endZ / gridSize)
            };
            
            // Calculate heuristic (Manhattan distance)
            function heuristic(node) {
                return Math.abs(node.x - endNode.x) + Math.abs(node.z - endNode.z);
            }
            
            const openList = [startNode];
            const closedList = [];
            const closedSet = new Set();
            let iterations = 0;
            
            while (openList.length > 0 && iterations < maxIterations) {
                iterations++;
                
                // Get node with lowest f cost
                openList.sort((a, b) => a.f - b.f);
                const currentNode = openList.shift();
                closedList.push(currentNode);
                closedSet.add(`${currentNode.x},${currentNode.z}`);
                
                // Check if reached destination
                if (currentNode.x === endNode.x && currentNode.z === endNode.z) {
                    // Reconstruct path
                    const path = [];
                    let current = currentNode;
                    while (current.parent) {
                        path.unshift({ 
                            x: current.x * gridSize, 
                            z: current.z * gridSize 
                        });
                        current = current.parent;
                    }
                    return path;
                }
                
                // Check all 8 neighbors
                const neighbors = [
                    { x: 0, z: -1 },  // North
                    { x: 1, z: -1 },  // Northeast
                    { x: 1, z: 0 },   // East
                    { x: 1, z: 1 },   // Southeast
                    { x: 0, z: 1 },   // South
                    { x: -1, z: 1 },  // Southwest
                    { x: -1, z: 0 },  // West
                    { x: -1, z: -1 }  // Northwest
                ];
                
                for (let offset of neighbors) {
                    const neighborX = currentNode.x + offset.x;
                    const neighborZ = currentNode.z + offset.z;
                    const neighborKey = `${neighborX},${neighborZ}`;
                    
                    // Skip if already checked
                    if (closedSet.has(neighborKey)) continue;
                    
                    // Convert grid to world coords and check for obstacles
                    const worldX = neighborX * gridSize;
                    const worldZ = neighborZ * gridSize;
                    
                    // Skip if out of bounds
                    if (Math.abs(worldX) > MAP_SIZE/2 || Math.abs(worldZ) > MAP_SIZE/2) continue;
                    
                    // Skip if obstacle (unless it's the destination)
                    if (neighborX !== endNode.x || neighborZ !== endNode.z) {
                        if (isObstacle(worldX, worldZ)) continue;
                    }
                    
                    // Calculate costs
                    const isDiagonal = offset.x !== 0 && offset.z !== 0;
                    const moveCost = isDiagonal ? 1.414 : 1; // Diagonal costs more
                    const g = currentNode.g + moveCost;
                    const h = heuristic({ x: neighborX, z: neighborZ });
                    const f = g + h;
                    
                    // Check if this neighbor is already in open list with better path
                    const existingOpen = openList.find(n => n.x === neighborX && n.z === neighborZ);
                    if (existingOpen && existingOpen.g <= g) continue;
                    
                    // Add to open list
                    if (existingOpen) {
                        existingOpen.g = g;
                        existingOpen.h = h;
                        existingOpen.f = f;
                        existingOpen.parent = currentNode;
                    } else {
                        openList.push({
                            x: neighborX,
                            z: neighborZ,
                            g: g,
                            h: h,
                            f: f,
                            parent: currentNode
                        });
                    }
                }
            }
            
            // No path found - return straight line
            return [{ x: endX, z: endZ }];
        }

        let animateFrameCount = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            // Debug: Log first few frames
            if (animateFrameCount < 3) {
                console.log('Animate frame:', animateFrameCount, 'Scene:', scene, 'Camera:', camera, 'Renderer:', renderer);
                animateFrameCount++;
            }

            // Handle movement
            let moved = false;
            const moveSpeed = PLAYER_SPEED;

            // WASD removed - only click-to-move now
            // Camera rotation with Arrow Keys
            if (keys['arrowleft']) {
                cameraAngle -= 0.02; // Rotate camera left (horizontal)
            }
            if (keys['arrowright']) {
                cameraAngle += 0.02; // Rotate camera right (horizontal)
            }
            if (keys['arrowdown']) {
                cameraPitch -= 0.02; // Down arrow: Tilt camera up (show more sky)
                cameraPitch = Math.max(MIN_PITCH, cameraPitch); // Clamp
            }
            if (keys['arrowup']) {
                cameraPitch += 0.02; // Up arrow: Tilt camera down (show more ground)
                cameraPitch = Math.max(MIN_PITCH, Math.min(MAX_PITCH, cameraPitch)); // Clamp
            }

            // Mobile joystick controls
            if (joystickActive) {
                const threshold = 0.2;
                if (Math.abs(joystickDirection.x) > threshold || Math.abs(joystickDirection.y) > threshold) {
                    const angle = cameraAngle;
                    const dx = joystickDirection.x * Math.cos(angle) - joystickDirection.y * Math.sin(angle);
                    const dz = joystickDirection.x * Math.sin(angle) + joystickDirection.y * Math.cos(angle);
                    
                    currentPlayer.x += dx * moveSpeed;
                    currentPlayer.z += dz * moveSpeed;
                    currentPlayer.rotation = Math.atan2(dx, dz);
                    moved = true;
                }
            }

            // Click-to-move: Walk to clicked position
            if (targetPosition) {
                // If no path exists or path was completed, calculate new path
                if (pathToTarget.length === 0) {
                    pathToTarget = findPath(currentPlayer.x, currentPlayer.z, targetPosition.x, targetPosition.z);
                }
                
                // Follow the path
                if (pathToTarget.length > 0) {
                    const nextWaypoint = pathToTarget[0];
                    const dist = Math.hypot(currentPlayer.x - nextWaypoint.x, currentPlayer.z - nextWaypoint.z);
                    
                    if (dist > 0.5) {
                        // Walk towards next waypoint
                        const angle = Math.atan2(nextWaypoint.x - currentPlayer.x, nextWaypoint.z - currentPlayer.z);
                        currentPlayer.x += Math.sin(angle) * moveSpeed;
                        currentPlayer.z += Math.cos(angle) * moveSpeed;
                        currentPlayer.rotation = angle;
                        moved = true;
                    } else {
                        // Reached waypoint, move to next one
                        pathToTarget.shift();
                        
                        // If no more waypoints, destination reached
                        if (pathToTarget.length === 0) {
                            const finalDist = Math.hypot(currentPlayer.x - targetPosition.x, currentPlayer.z - targetPosition.z);
                            if (finalDist <= 1.0) {
                                targetPosition = null;
                            }
                        }
                    }
                } else {
                    // No valid path found, try direct movement
                    const dist = Math.hypot(currentPlayer.x - targetPosition.x, currentPlayer.z - targetPosition.z);
                    if (dist > 0.5) {
                        const angle = Math.atan2(targetPosition.x - currentPlayer.x, targetPosition.z - currentPlayer.z);
                        currentPlayer.x += Math.sin(angle) * moveSpeed;
                        currentPlayer.z += Math.cos(angle) * moveSpeed;
                        currentPlayer.rotation = angle;
                        moved = true;
                    } else {
                        targetPosition = null;
                    }
                }
            }
            
            // Auto-walk to target monster and continuous attack
            if (targetMonster && targetMonster.monster.currentHp > 0) {
                const dist = Math.hypot(currentPlayer.x - targetMonster.monster.x, currentPlayer.z - targetMonster.monster.z);
                if (dist > 4) {
                    // Walk towards monster
                    const angle = Math.atan2(targetMonster.monster.x - currentPlayer.x, targetMonster.monster.z - currentPlayer.z);
                    currentPlayer.x += Math.sin(angle) * moveSpeed;
                    currentPlayer.z += Math.cos(angle) * moveSpeed;
                    currentPlayer.rotation = angle;
                    moved = true;
                    isAttacking = false;
                } else {
                    // Close enough - keep attacking until dead
                    isAttacking = true;
                    attackCooldown--;
                    if (attackCooldown <= 0) {
                        attackMonster(targetMonster.monster, targetMonster.mesh);
                        attackCooldown = 30; // Attack every 30 frames (~0.5 seconds)
                        // Apply attack animation
                        playerAnimationState = 'attacking';
                        animationFrame = 0;
                    }
                    // Cancel target if monster is dead
                    if (targetMonster.monster.currentHp <= 0) {
                        targetMonster = null;
                        isAttacking = false;
                    }
                }
            } else {
                isAttacking = false;
            }
            
            // Auto-walk to target resource and gathering animation
            if (targetResource && targetResource.resource.available) {
                const dist = Math.hypot(currentPlayer.x - targetResource.resource.x, currentPlayer.z - targetResource.resource.z);
                if (dist > 2.5) {
                    // Walk towards resource
                    const angle = Math.atan2(targetResource.resource.x - currentPlayer.x, targetResource.resource.z - currentPlayer.z);
                    currentPlayer.x += Math.sin(angle) * moveSpeed;
                    currentPlayer.z += Math.cos(angle) * moveSpeed;
                    currentPlayer.rotation = angle;
                    moved = true;
                    isGathering = false;
                } else {
                    // Close enough - gather with animation!
                    isGathering = true;
                    gatheringCooldown--;
                    if (gatheringCooldown <= 0) {
                        harvestResource(targetResource.resource, targetResource.mesh);
                        gatheringCooldown = 45; // Gather every 45 frames (~0.75 seconds)
                        targetResource = null; // Stop after gathering
                        isGathering = false;
                    }
                    // Apply gathering animation based on resource type
                    playerAnimationState = targetResource.resource.name.includes('Tree') ? 'chopping' : 
                                         targetResource.resource.name.includes('Rock') ? 'mining' : 'gathering';
                    animationFrame = 0;
                }
            } else {
                isGathering = false;
            }

            // Keep player in bounds
            currentPlayer.x = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, currentPlayer.x));
            currentPlayer.z = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, currentPlayer.z));

            currentPlayer.moving = moved;
            
            // Check PVP area
            checkPVPArea();

            // Update player mesh position and animation
            if (playerMesh) {
                playerMesh.position.set(currentPlayer.x, currentPlayer.y, currentPlayer.z);
                playerMesh.rotation.y = currentPlayer.rotation;
                
                // Apply player animations
                animationFrame++;
                if (isAttacking && playerAnimationState === 'attacking') {
                    // Swinging motion for attacking
                    const swingCycle = animationFrame % 30;
                    const swingAngle = Math.sin(swingCycle / 5) * 0.5;
                    // Rotate player's right arm for sword swing
                    const rightArm = playerMesh.children.find(c => c.name === 'rightArm');
                    if (rightArm) {
                        rightArm.rotation.x = swingAngle;
                        rightArm.position.y = 1.0 + Math.abs(swingAngle) * 0.2;
                    }
                } else if (isGathering) {
                    // Chopping or mining motion
                    const gatherCycle = animationFrame % 45;
                    if (playerAnimationState === 'chopping') {
                        // Axe chopping motion
                        const chopAngle = Math.sin(gatherCycle / 7) * 0.8;
                        const rightArm = playerMesh.children.find(c => c.name === 'rightArm');
                        if (rightArm) {
                            rightArm.rotation.x = -chopAngle - 0.5;
                        }
                    } else if (playerAnimationState === 'mining') {
                        // Pickaxe mining motion
                        const mineAngle = Math.sin(gatherCycle / 8) * 0.6;
                        const rightArm = playerMesh.children.find(c => c.name === 'rightArm');
                        if (rightArm) {
                            rightArm.rotation.x = -mineAngle - 0.3;
                            rightArm.rotation.z = mineAngle * 0.3;
                        }
                    }
                } else {
                    // Reset arm position to idle
                    const rightArm = playerMesh.children.find(c => c.name === 'rightArm');
                    const leftArm = playerMesh.children.find(c => c.name === 'leftArm');
                    if (rightArm) {
                        rightArm.rotation.x = 0;
                        rightArm.rotation.z = 0;
                        rightArm.position.y = 1.0;
                    }
                    if (leftArm) {
                        leftArm.rotation.x = 0;
                    }
                }
            }
            
            // Check exploration quests
            if (moved) {
                updateQuestProgress('explore', null, { x: currentPlayer.x, z: currentPlayer.z });
            }
            
            // Check if player entered PVP area
            const inPvpArea = 
                currentPlayer.x > PVP_AREA.x - PVP_AREA.width/2 &&
                currentPlayer.x < PVP_AREA.x + PVP_AREA.width/2 &&
                currentPlayer.z > PVP_AREA.z - PVP_AREA.depth/2 &&
                currentPlayer.z < PVP_AREA.z + PVP_AREA.depth/2;
            
            if (inPvpArea && !pvpEnabled) {
                pvpEnabled = true;
                addChatMessage('System', '⚠️ You entered the WILDERNESS! PVP is enabled!', 'system');
            } else if (!inPvpArea && pvpEnabled) {
                pvpEnabled = false;
                addChatMessage('System', '✅ You left the Wilderness. PVP is disabled.', 'system');
            }

            // Move monsters randomly - with null checks
            if (monsters && monsters.length > 0 && monsterMeshes && monsterMeshes.length > 0) {
                monsters.forEach((monster, index) => {
                    if (!monster || !monsterMeshes[index]) return;  // Safety check
                    
                    if (monster.currentHp > 0 && Math.random() < 0.01) {
                        monster.direction = Math.random() * Math.PI * 2;
                    }
                    
                    if (monster.currentHp > 0) {
                        monster.x += Math.sin(monster.direction) * (monster.speed || 0.05);
                        monster.z += Math.cos(monster.direction) * (monster.speed || 0.05);
                        
                        // Keep in bounds
                        monster.x = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, monster.x));
                        monster.z = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, monster.z));

                        try {
                            monsterMeshes[index].position.x = monster.x;
                            monsterMeshes[index].position.z = monster.z;
                            monsterMeshes[index].rotation.y = monster.direction;
                        } catch (e) {
                            console.warn('Monster mesh update error:', e);
                        }
                    }
                });
            }

            // Animate resources - with null checks
            if (resources && resources.length > 0 && resourceMeshes && resourceMeshes.length > 0) {
                resourceMeshes.forEach((mesh, index) => {
                    if (!mesh || !resources[index]) return;  // Safety check
                    
                    try {
                        if (resources[index].name === 'Fish Spot' && resources[index].available) {
                            mesh.rotation.y += 0.01;
                        }
                    } catch (e) {
                        console.warn('Resource animation error:', e);
                    }
                });
            }

            // Update house visibility (roof becomes invisible when inside)
            updateHouseVisibility();
            
            // Update camera position
            updateCameraPosition();

            // Render scene
            renderer.render(scene, camera);
        }

        function updateCameraPosition() {
            if (!camera || !currentPlayer) return;  // Safety check
            
            // Calculate camera position using both horizontal angle and vertical pitch
            // Horizontal distance from player based on pitch
            const horizontalDistance = cameraDistance * Math.cos(cameraPitch);
            const verticalOffset = cameraDistance * Math.sin(cameraPitch);
            
            const offset = {
                x: Math.sin(cameraAngle) * horizontalDistance,
                y: cameraHeight + verticalOffset,
                z: Math.cos(cameraAngle) * horizontalDistance
            };

            // Calculate camera position
            camera.position.x = currentPlayer.x - offset.x;
            camera.position.y = currentPlayer.y + offset.y;
            camera.position.z = currentPlayer.z - offset.z;
            
            // Ensure camera stays within reasonable bounds relative to map
            camera.position.x = Math.max(-MAP_SIZE, Math.min(MAP_SIZE, camera.position.x));
            camera.position.z = Math.max(-MAP_SIZE, Math.min(MAP_SIZE, camera.position.z));
            
            // Look at player position
            camera.lookAt(currentPlayer.x, currentPlayer.y, currentPlayer.z);
        }

        function handleMouseDown(e) {
            isMouseDown = true;
            mouseStartX = e.clientX;
        }

        function handleMouseMove(e) {
            if (isMouseDown) {
                const deltaX = e.clientX - mouseStartX;
                cameraAngle += deltaX * 0.005;
                mouseStartX = e.clientX;
            }
        }

        function handleMouseUp(e) {
            isMouseDown = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(10, Math.min(40, cameraDistance));
        }

        function handleCanvasTouchEnd(e) {
            e.preventDefault();
            if (e.changedTouches && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const fakeEvent = {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                };
                handleCanvasClick(fakeEvent);
            }
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check NPCs first
            const npcIntersects = raycaster.intersectObjects(npcMeshes, true);
            if (npcIntersects.length > 0) {
                let npcGroup = npcIntersects[0].object;
                while (npcGroup.parent && !npcGroup.userData.npcId) {
                    npcGroup = npcGroup.parent;
                }
                const npc = npcGroup.userData;
                if (npc && npc.npcId) {
                    const dist = Math.hypot(currentPlayer.x - npc.x, currentPlayer.z - npc.z);
                    if (dist < INTERACTION_RADIUS.npc) {
                        interactWithNPC(npc);
                        return;
                    } else {
                        targetPosition = { x: npc.x, z: npc.z };
                        targetMonster = null;
                        targetResource = null;
                        addChatMessage('System', `Walking to ${npc.name}...`, 'system');
                        return;
                    }
                }
            }

            // Check monsters
            const monsterIntersects = raycaster.intersectObjects(monsterMeshes, true);
            if (monsterIntersects.length > 0) {
                let monsterGroup = monsterIntersects[0].object;
                while (monsterGroup.parent && !monsterGroup.userData.id) {
                    monsterGroup = monsterGroup.parent;
                }
                const monster = monsterGroup.userData;
                if (monster && monster.currentHp > 0) {
                    const dist = Math.hypot(currentPlayer.x - monster.x, currentPlayer.z - monster.z);
                    if (dist < INTERACTION_RADIUS.monster) {
                        attackMonster(monster, monsterGroup);
                        return;
                    } else {
                        // Too far - walk towards monster
                        targetMonster = { monster: monster, mesh: monsterGroup };
                        targetResource = null;
                        targetPosition = null;
                        addChatMessage('System', `Walking to ${monster.name}...`, 'system');
                        return;
                    }
                }
            }

            // Check resources
            const resourceIntersects = raycaster.intersectObjects(resourceMeshes, true);
            if (resourceIntersects.length > 0) {
                let resourceMesh = resourceIntersects[0].object;
                while (resourceMesh.parent && !resourceMesh.userData.id) {
                    resourceMesh = resourceMesh.parent;
                }
                const resource = resourceMesh.userData;
                if (resource && resource.available) {
                    const dist = Math.hypot(currentPlayer.x - resource.x, currentPlayer.z - resource.z);
                    if (dist < INTERACTION_RADIUS.resource) {
                        harvestResource(resource, resourceMesh);
                        return;
                    } else {
                        // Too far - walk towards resource
                        targetResource = { resource: resource, mesh: resourceMesh };
                        targetMonster = null;
                        targetPosition = null;
                        addChatMessage('System', `Walking to ${resource.name}...`, 'system');
                        return;
                    }
                }
            }
            
            // Check ground - click to move
            if (groundMesh) {
                const groundIntersects = raycaster.intersectObject(groundMesh);
                if (groundIntersects.length > 0) {
                    const point = groundIntersects[0].point;
                    targetPosition = { x: point.x, z: point.z };
                    pathToTarget = []; // Clear old path
                    targetMonster = null;
                    targetResource = null;
                }
            }
        }

        function attackMonster(monster, monsterMesh) {
            const damage = 10 + currentPlayer.skills.combat * 2;
            monster.currentHp -= damage;
            addChatMessage('Combat', `You hit ${monster.name} for ${damage} damage!`, 'system');
            
            // Visual feedback
            monsterMesh.position.y += 0.2;
            setTimeout(() => {
                monsterMesh.position.y = monster.y;
            }, 200);

            if (monster.currentHp <= 0) {
                currentPlayer.xp += monster.xp;
                currentPlayer.skills.combat++;
                addChatMessage('Victory', `You defeated ${monster.name}! +${monster.xp} XP`, 'system');
                
                // Hide monster
                monsterMesh.visible = false;
                
                // Check level up
                const xpNeeded = currentPlayer.level * 100;
                if (currentPlayer.xp >= xpNeeded) {
                    currentPlayer.level++;
                    currentPlayer.xp = 0;
                    currentPlayer.maxHp += 10;
                    currentPlayer.hp = currentPlayer.maxHp;
                    addChatMessage('Level Up!', `You are now level ${currentPlayer.level}!`, 'system');
                }
                
                // Respawn monster
                setTimeout(() => {
                    monster.currentHp = monster.maxHp;
                    monster.x = (Math.random() - 0.5) * MAP_SIZE;
                    monster.z = (Math.random() - 0.5) * MAP_SIZE;
                    monsterMesh.position.x = monster.x;
                    monsterMesh.position.z = monster.z;
                    monsterMesh.visible = true;
                }, 5000);
            }
            
            updateStats();
        }

        function harvestResource(resource, resourceMesh) {
            // Check level requirement
            const requiredLevel = resource.levelRequired || 1;
            if (currentPlayer.skills[resource.skill] < requiredLevel) {
                addChatMessage('System', `You need level ${requiredLevel} ${resource.skill} to gather from this ${resource.name}.`, 'error');
                return;
            }
            
            resource.available = false;
            const xpGained = resource.xp || 25;
            currentPlayer.skills[resource.skill] += xpGained;
            
            if (!currentPlayer.inventory[resource.item]) {
                currentPlayer.inventory[resource.item] = 0;
            }
            currentPlayer.inventory[resource.item]++;
            
            addChatMessage('Gathering', `You gathered ${resource.item} from ${resource.name}! +${xpGained} ${resource.skill} XP`, 'system');
            updateQuestProgress('gather', resource.item);
            
            // Check gathering achievement
            const totalGathered = Object.values(currentPlayer.inventory).reduce((a, b) => a + b, 0);
            if (totalGathered >= 100) checkAchievement('master_gatherer');
            
            // Rare buff drop from gathering
            if (Math.random() < 0.1) {
                applyBuff(['strength', 'speed', 'defense'][Math.floor(Math.random() * 3)]);
            }
            
            // Visual feedback
            resourceMesh.visible = false;
            createParticle(resource.x, resource.y, resource.z, 0x2ecc71, '✨');
            
            renderInventory();
            updateStats();
            
            // Respawn resource
            setTimeout(() => {
                resource.available = true;
                resourceMesh.visible = true;
            }, 10000);
        }

        function updatePlayerPosition() {
            if (currentPlayer.id && playersRef) {
                try {
                    playersRef.child(currentPlayer.id).update({
                        x: currentPlayer.x,
                        y: currentPlayer.y,
                        z: currentPlayer.z,
                        rotation: currentPlayer.rotation,
                        lastActive: Date.now()
                    }).catch(err => {
                        console.warn('Failed to update player position:', err);
                    });
                } catch (error) {
                    console.warn('Position update error:', error);
                }
            }
        }

        function attackNearestMonster() {
            let nearest = null;
            let nearestMesh = null;
            let minDist = Infinity;
            
            monsters.forEach((monster, index) => {
                if (monster.currentHp > 0) {
                    const dist = Math.hypot(monster.x - currentPlayer.x, monster.z - currentPlayer.z);
                    if (dist < minDist && dist < 5) {
                        minDist = dist;
                        nearest = monster;
                        nearestMesh = monsterMeshes[index];
                    }
                }
            });
            
            if (nearest) {
                attackMonster(nearest, nearestMesh);
            } else {
                addChatMessage('Combat', 'No monsters nearby!', 'system');
            }
        }

        function gatherResource() {
            let nearest = null;
            let nearestMesh = null;
            let minDist = Infinity;
            
            resources.forEach((resource, index) => {
                if (resource.available) {
                    const dist = Math.hypot(resource.x - currentPlayer.x, resource.z - currentPlayer.z);
                    if (dist < minDist && dist < 3) {
                        minDist = dist;
                        nearest = resource;
                        nearestMesh = resourceMeshes[index];
                    }
                }
            });
            
            if (nearest) {
                harvestResource(nearest, nearestMesh);
            } else {
                addChatMessage('Gathering', 'No resources nearby!', 'system');
            }
        }

        function openCrafting() {
            addChatMessage('Crafting', 'Crafting system coming soon! Collect resources to craft items.', 'system');
        }

        function openQuests() {
            addChatMessage('Quests', 'Quest system coming soon! Complete quests for rewards and XP.', 'system');
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message) {
                chatRef.push({
                    player: currentPlayer.name,
                    message: message,
                    type: 'player',
                    timestamp: Date.now()
                });
                input.value = '';
                chatMessageCount++;
                if (chatMessageCount >= 50) checkAchievement('social');
            }
        }

        function addChatMessage(player, message, type = 'player') {
            const chatArea = document.getElementById('chatArea');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'chat-message';
            
            if (type === 'system') {
                msgDiv.innerHTML = `<span class="chat-system">[${player}] ${message}</span>`;
            } else {
                msgDiv.innerHTML = `<span class="chat-player">${player}:</span> ${message}`;
            }
            
            chatArea.appendChild(msgDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            
            // Limit messages
            while (chatArea.children.length > 50) {
                chatArea.removeChild(chatArea.firstChild);
            }
        }

        function updateStats() {
            document.getElementById('combatLevel').textContent = currentPlayer.level;
            document.getElementById('goldCount').textContent = currentPlayer.gold;
            
            document.getElementById('hpBar').style.width = (currentPlayer.hp / currentPlayer.maxHp * 100) + '%';
            document.getElementById('hpBar').textContent = `${Math.floor(currentPlayer.hp)}/${currentPlayer.maxHp}`;
            
            document.getElementById('mpBar').style.width = (currentPlayer.mp / currentPlayer.maxMp * 100) + '%';
            document.getElementById('mpBar').textContent = `${Math.floor(currentPlayer.mp)}/${currentPlayer.maxMp}`;
            
            const xpNeeded = currentPlayer.level * 100;
            document.getElementById('xpBar').style.width = (currentPlayer.xp / xpNeeded * 100) + '%';
            document.getElementById('xpBar').textContent = `${currentPlayer.xp}/${xpNeeded}`;

            // Update stats
            document.getElementById('strengthStat').textContent = currentPlayer.stats.strength;
            document.getElementById('defenseStat').textContent = currentPlayer.stats.defense;
            document.getElementById('magicStat').textContent = currentPlayer.stats.magic;
            document.getElementById('speedStat').textContent = currentPlayer.stats.speed;

            // Update skills
            document.getElementById('combatSkill').textContent = currentPlayer.skills.combat;
            document.getElementById('miningSkill').textContent = currentPlayer.skills.mining;
            document.getElementById('woodcuttingSkill').textContent = currentPlayer.skills.woodcutting;
            document.getElementById('fishingSkill').textContent = currentPlayer.skills.fishing;
            document.getElementById('craftingSkill').textContent = currentPlayer.skills.crafting;
            document.getElementById('magicSkill').textContent = currentPlayer.skills.magic;
            
            // Update equipment slots
            document.getElementById('weaponSlot').textContent = currentPlayer.equipment.weapon || '🗡️ Weapon';
            document.getElementById('armorSlot').textContent = currentPlayer.equipment.armor || '🛡️ Armor';
            document.getElementById('helmetSlot').textContent = currentPlayer.equipment.helmet || '⛑️ Helmet';
            document.getElementById('bootsSlot').textContent = currentPlayer.equipment.boots || '👢 Boots';
            
            // Update quest count
            document.getElementById('questCount').textContent = currentPlayer.quests.active.length;
            
            // Update ability cooldowns
            updateAbilityButtons();
        }

        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');
            if (!grid) return;
            grid.innerHTML = '';
            
            const allItems = [];
            
            // Add regular items
            Object.entries(currentPlayer.inventory).forEach(([name, count]) => {
                if (count > 0) {
                    allItems.push({ name, count, isEquipment: isEquipmentItem(name) });
                }
            });
            
            for (let i = 0; i < 16; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                if (allItems[i]) {
                    const item = allItems[i];
                    slot.classList.add('has-item');
                    
                    const icon = getItemIcon(item.name);
                    slot.innerHTML = icon;
                    
                    const count = document.createElement('div');
                    count.className = 'item-count';
                    count.textContent = item.count;
                    slot.appendChild(count);
                    
                    // Add click handler for equipment items
                    if (item.isEquipment) {
                        slot.style.cursor = 'pointer';
                        slot.onclick = () => equipItem(item.name);
                        slot.title = `Click to equip ${item.name}`;
                    }
                }
                
                grid.appendChild(slot);
            }
        }
        
        function isEquipmentItem(itemName) {
            return Object.values(EQUIPMENT).some(category => 
                Object.keys(category).includes(itemName)
            );
        }
        
        function getItemIcon(itemName) {
            // Check equipment database
            for (const category of Object.values(EQUIPMENT)) {
                if (category[itemName]) {
                    return category[itemName].icon || '📦';
                }
            }
            
            // Default icons for resources
            const resourceIcons = {
                // Wood types
                'Logs': '🪵',
                'Oak Logs': '🪵',
                'Willow Logs': '🪵',
                'Maple Logs': '🪵',
                'Yew Logs': '🪵',
                'Magic Logs': '🪵',
                'Wood': '🪵',
                
                // Ore types
                'Copper Ore': '🪨',
                'Tin Ore': '🪨',
                'Iron Ore': '🪨',
                'Coal': '⚫',
                'Mithril Ore': '🔵',
                'Adamant Ore': '🟢',
                'Runite Ore': '💎',
                'Ore': '🪨',
                
                // Fish types
                'Raw Shrimp': '🦐',
                'Raw Sardine': '🐟',
                'Raw Trout': '🐟',
                'Raw Salmon': '🐟',
                'Raw Tuna': '🐟',
                'Raw Lobster': '🦞',
                'Raw Swordfish': '🐟',
                'Raw Shark': '🦈',
                'Fish': '🐟',
                
                'Gem': '💎'
            };
            
            return resourceIcons[itemName] || '📦';
        }
        
        function equipItem(itemName) {
            // Find item category and stats
            let itemData = null;
            let slot = null;
            
            for (const [category, items] of Object.entries(EQUIPMENT)) {
                if (items[itemName]) {
                    itemData = items[itemName];
                    slot = itemData.slot;
                    break;
                }
            }
            
            if (!itemData || !slot) return;
            
            // Remove from inventory
            if (currentPlayer.inventory[itemName]) {
                currentPlayer.inventory[itemName]--;
                if (currentPlayer.inventory[itemName] <= 0) {
                    delete currentPlayer.inventory[itemName];
                }
            }
            
            // Unequip current item in slot if any
            const currentEquip = currentPlayer.equipment[slot];
            if (currentEquip) {
                currentPlayer.inventory[currentEquip] = (currentPlayer.inventory[currentEquip] || 0) + 1;
            }
            
            // Equip new item
            currentPlayer.equipment[slot] = itemName;
            
            addChatMessage('Equipment', `Equipped ${itemName}`, 'system');
            updateEquipmentDisplay();
            renderInventory();
            updateStats();
        }
        
        function unequipItem(slot) {
            const itemName = currentPlayer.equipment[slot];
            if (!itemName) return;
            
            // Add to inventory
            currentPlayer.inventory[itemName] = (currentPlayer.inventory[itemName] || 0) + 1;
            
            // Remove from equipment
            currentPlayer.equipment[slot] = null;
            
            addChatMessage('Equipment', `Unequipped ${itemName}`, 'system');
            updateEquipmentDisplay();
            renderInventory();
            updateStats();
        }
        
        function updateEquipmentDisplay() {
            const slots = ['weapon', 'body', 'head', 'feet'];
            const slotElements = {
                'weapon': 'weaponSlot',
                'body': 'armorSlot',
                'head': 'helmetSlot',
                'feet': 'bootsSlot'
            };
            
            slots.forEach(slot => {
                const element = document.getElementById(slotElements[slot]);
                if (!element) return;
                
                const equippedItem = currentPlayer.equipment[slot];
                if (equippedItem) {
                    const icon = getItemIcon(equippedItem);
                    element.innerHTML = `${icon}<br><small style="font-size:0.7rem;">${equippedItem}</small>`;
                    element.style.cursor = 'pointer';
                    element.onclick = () => unequipItem(slot);
                    element.title = `Click to unequip`;
                    element.style.opacity = '1';
                } else {
                    const defaultIcons = {
                        'weapon': '🗡️',
                        'body': '🛡️',
                        'head': '⛑️',
                        'feet': '👢'
                    };
                    element.innerHTML = `<span style="font-size: 3rem; opacity: 0.3;">❌</span><br><small style="font-size:0.7rem; opacity: 0.5;">${defaultIcons[slot]} Empty</small>`;
                    element.style.cursor = 'default';
                    element.onclick = null;
                    element.title = 'No item equipped';
                    element.style.opacity = '0.5';
                }
            });
        }

        function onWindowResize() {
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        }

        // Mobile Controls
        function initMobileControls() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickKnob = document.getElementById('joystickKnob');

            function handleJoystickStart(e) {
                e.preventDefault();
                joystickActive = true;
                updateJoystick(e);
            }

            function handleJoystickMove(e) {
                e.preventDefault();
                if (joystickActive) {
                    updateJoystick(e);
                }
            }

            function handleJoystickEnd(e) {
                e.preventDefault();
                joystickActive = false;
                joystickDirection = { x: 0, y: 0 };
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }

            function updateJoystick(e) {
                const touch = e.touches ? e.touches[0] : e;
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }
                
                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                // Normalize direction
                joystickDirection.x = deltaX / maxDistance;
                joystickDirection.y = deltaY / maxDistance;
            }

            // Touch events
            joystickContainer.addEventListener('touchstart', handleJoystickStart);
            joystickContainer.addEventListener('touchmove', handleJoystickMove);
            joystickContainer.addEventListener('touchend', handleJoystickEnd);
            
            // Mouse events for testing
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            joystickContainer.addEventListener('mousemove', handleJoystickMove);
            joystickContainer.addEventListener('mouseup', handleJoystickEnd);
            joystickContainer.addEventListener('mouseleave', handleJoystickEnd);
        }

        function toggleLeftSidebar() {
            const sidebar = document.getElementById('leftSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const rightSidebar = document.getElementById('rightSidebar');
            
            rightSidebar.classList.remove('open');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        }

        function toggleRightSidebar() {
            const sidebar = document.getElementById('rightSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const leftSidebar = document.getElementById('leftSidebar');
            
            leftSidebar.classList.remove('open');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        }

        function closeSidebars() {
            document.getElementById('leftSidebar').classList.remove('open');
            document.getElementById('rightSidebar').classList.remove('open');
            document.getElementById('sidebarOverlay').classList.remove('active');
        }

        // ========== NEW GAMEPLAY SYSTEMS ==========
        
        // Ability System
        function useAbility(abilityName) {
            const ability = currentPlayer.abilities[abilityName];
            
            if (ability.cooldown > 0) {
                addChatMessage('System', `Ability on cooldown! Wait ${Math.ceil(ability.cooldown/1000)}s`, 'system');
                return;
            }
            
            if (currentPlayer.mp < ability.mpCost) {
                addChatMessage('System', 'Not enough MP!', 'system');
                return;
            }
            
            currentPlayer.mp -= ability.mpCost;
            ability.cooldown = ability.maxCooldown;
            
            if (abilityName === 'fireball') {
                castFireball();
            } else if (abilityName === 'heal') {
                castHeal();
            } else if (abilityName === 'lightning') {
                castLightning();
            }
            
            updateStats();
        }
        
        function castFireball() {
            const nearest = findNearestMonster(10);
            if (nearest) {
                const damage = 25 + currentPlayer.stats.magic * 2;
                nearest.currentHp -= damage;
                createParticle(nearest.x, nearest.y, nearest.z, 0xff4500, '🔥');
                addChatMessage('Combat', `Fireball hit ${nearest.name} for ${damage} damage!`, 'system');
                if (nearest.currentHp <= 0) handleMonsterDeath(nearest);
            } else {
                addChatMessage('System', 'No targets in range!', 'system');
            }
        }
        
        function castHeal() {
            const healing = 30 + currentPlayer.stats.magic;
            currentPlayer.hp = Math.min(currentPlayer.maxHp, currentPlayer.hp + healing);
            createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0x00ff00, '💚');
            addChatMessage('System', `Healed for ${healing} HP!`, 'system');
        }
        
        function castLightning() {
            const monstersInRange = monsters.filter(m => 
                m.currentHp > 0 && Math.hypot(m.x - currentPlayer.x, m.z - currentPlayer.z) < 15
            );
            
            const damage = 50 + currentPlayer.stats.magic * 3;
            monstersInRange.forEach(monster => {
                monster.currentHp -= damage;
                createParticle(monster.x, monster.y, monster.z, 0xffff00, '⚡');
                if (monster.currentHp <= 0) handleMonsterDeath(monster);
            });
            
            addChatMessage('Combat', `Lightning struck ${monstersInRange.length} enemies for ${damage} damage each!`, 'system');
        }
        
        function updateAbilityButtons() {
            Object.keys(currentPlayer.abilities).forEach(name => {
                const ability = currentPlayer.abilities[name];
                const btn = document.getElementById(name + 'Btn');
                if (btn) {
                    if (ability.cooldown > 0) {
                        btn.style.opacity = '0.5';
                        btn.style.pointerEvents = 'none';
                    } else {
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                    }
                }
            });
        }
        
        function findNearestMonster(maxDistance) {
            let nearest = null;
            let minDist = Infinity;
            
            monsters.forEach(monster => {
                if (monster.currentHp > 0) {
                    const dist = Math.hypot(monster.x - currentPlayer.x, monster.z - currentPlayer.z);
                    if (dist < minDist && dist < maxDistance) {
                        minDist = dist;
                        nearest = monster;
                    }
                }
            });
            
            return nearest;
        }
        
        // Quest System
        function toggleQuestPanel() {
            const panel = document.getElementById('questPanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                renderQuests();
            }
        }
        
        function renderQuests() {
            const availableDiv = document.getElementById('availableQuests');
            const activeDiv = document.getElementById('activeQuestsPanel');
            
            availableDiv.innerHTML = '';
            activeDiv.innerHTML = '';
            
            // Show available quests
            QUESTS.forEach(quest => {
                if (currentPlayer.level >= quest.level && 
                    !currentPlayer.quests.completed.includes(quest.id) &&
                    !currentPlayer.quests.active.some(q => q.id === quest.id)) {
                    
                    const questEl = document.createElement('div');
                    questEl.className = 'quest-item';
                    questEl.innerHTML = `
                        <h4 style="color: #f39c12; margin-bottom: 0.5rem;">${quest.name}</h4>
                        <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">${quest.description}</p>
                        <p style="font-size: 0.8rem; color: #95a5a6;">Rewards: ${quest.reward.xp} XP, ${quest.reward.gold} Gold</p>
                        <button class="action-btn" style="margin-top: 0.5rem; padding: 0.5rem 1rem; font-size: 0.9rem;" onclick="acceptQuest('${quest.id}')">Accept Quest</button>
                    `;
                    availableDiv.appendChild(questEl);
                }
            });
            
            // Show active quests
            currentPlayer.quests.active.forEach(activeQuest => {
                const quest = QUESTS.find(q => q.id === activeQuest.id);
                if (quest) {
                    const questEl = document.createElement('div');
                    questEl.className = 'quest-item';
                    questEl.style.borderColor = '#2ecc71';
                    
                    let progressText = '';
                    if (quest.steps) {
                        const stepIndex = activeQuest.currentStep || 0;
                        const step = quest.steps[stepIndex];
                        if (step) {
                            const stepProgress = activeQuest.stepProgress || 0;
                            const stepRequired = step.count || 1;
                            progressText = `<p style="font-size: 0.8rem; color: #2ecc71;">Step ${stepIndex + 1}/${quest.steps.length}: ${step.text} (${stepProgress}/${stepRequired})</p>`;
                            
                            // Show all steps with checkmarks
                            progressText += '<div style="margin-top: 0.5rem; font-size: 0.75rem;">';
                            quest.steps.forEach((s, i) => {
                                const completed = i < stepIndex;
                                const current = i === stepIndex;
                                const icon = completed ? '✓' : current ? '→' : '○';
                                const color = completed ? '#2ecc71' : current ? '#f39c12' : '#95a5a6';
                                progressText += `<div style="color: ${color};">${icon} ${s.text}</div>`;
                            });
                            progressText += '</div>';
                        }
                    } else if (quest.objective) {
                        progressText = `<p style="font-size: 0.8rem; color: #2ecc71;">Progress: ${activeQuest.progress || 0}/${quest.objective.count || 1}</p>`;
                    }
                    
                    questEl.innerHTML = `
                        <h4 style="color: #2ecc71; margin-bottom: 0.5rem;">${quest.name}</h4>
                        <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">${quest.description}</p>
                        ${progressText}
                    `;
                    activeDiv.appendChild(questEl);
                }
            });
        }
        
        function acceptQuest(questId) {
            const quest = QUESTS.find(q => q.id === questId);
            if (quest) {
                if (quest.steps) {
                    // Multi-step quest
                    currentPlayer.quests.active.push({ id: questId, currentStep: 0, stepProgress: 0 });
                    currentQuestStep[questId] = 0;
                } else {
                    // Legacy single-objective quest
                    currentPlayer.quests.active.push({ id: questId, progress: 0 });
                }
                addChatMessage('Quest', `Accepted quest: ${quest.name}`, 'system');
                if (quest.story) {
                    addChatMessage('Quest', quest.story, 'system');
                }
                renderQuests();
            }
        }
        
        function updateQuestProgress(type, target = null, position = null) {
            currentPlayer.quests.active.forEach(activeQuest => {
                const quest = QUESTS.find(q => q.id === activeQuest.id);
                if (!quest) return;
                
                if (quest.steps) {
                    // Multi-step quest
                    const stepIndex = activeQuest.currentStep || 0;
                    const step = quest.steps[stepIndex];
                    
                    if (!step) return;
                    
                    let matches = false;
                    if (step.type === type) {
                        if (type === 'talk' && step.target === target) {
                            matches = true;
                        } else if (type === 'kill' && (step.target === 'any' || step.target === target)) {
                            matches = true;
                        } else if (type === 'gather' && step.target === target) {
                            matches = true;
                        } else if (type === 'craft' && step.target === target) {
                            matches = true;
                        } else if (type === 'explore' && position) {
                            const dist = Math.hypot(position.x - step.x, position.z - step.z);
                            if (dist < (step.range || 5)) {
                                matches = true;
                            }
                        }
                    }
                    
                    if (matches) {
                        activeQuest.stepProgress = (activeQuest.stepProgress || 0) + 1;
                        const required = step.count || 1;
                        
                        if (activeQuest.stepProgress >= required) {
                            // Step complete - move to next step
                            activeQuest.currentStep++;
                            activeQuest.stepProgress = 0;
                            
                            if (activeQuest.currentStep >= quest.steps.length) {
                                // All steps complete!
                                completeQuest(quest);
                            } else {
                                const nextStep = quest.steps[activeQuest.currentStep];
                                addChatMessage('Quest', `✓ Step complete! Next: ${nextStep.text}`, 'system');
                            }
                        } else {
                            addChatMessage('Quest', `Progress: ${activeQuest.stepProgress}/${required} - ${step.text}`, 'system');
                        }
                        renderQuests();
                    }
                } else {
                    // Legacy single-objective quest
                    if (quest.objective && quest.objective.type === type) {
                        if (!target || quest.objective.target === 'any' || quest.objective.target === target) {
                            activeQuest.progress = (activeQuest.progress || 0) + 1;
                            
                            if (activeQuest.progress >= (quest.objective.count || 1)) {
                                completeQuest(quest);
                            } else {
                                addChatMessage('Quest', `Quest progress: ${activeQuest.progress}/${quest.objective.count}`, 'system');
                            }
                        }
                    }
                }
            });
        }
        
        function completeQuest(quest) {
            currentPlayer.quests.active = currentPlayer.quests.active.filter(q => q.id !== quest.id);
            currentPlayer.quests.completed.push(quest.id);
            delete currentQuestStep[quest.id];
            
            currentPlayer.xp += quest.reward.xp;
            currentPlayer.gold += quest.reward.gold;
            
            if (quest.reward.item) {
                currentPlayer.inventory[quest.reward.item] = (currentPlayer.inventory[quest.reward.item] || 0) + 1;
                // Auto-equip if it's a weapon
                if (EQUIPMENT.weapons[quest.reward.item]) {
                    equipItem(quest.reward.item, 'weapon');
                }
            }
            
            if (quest.reward.pet) {
                currentPlayer.pet = quest.reward.pet;
                createPetMesh();
                addChatMessage('Quest Complete', `🎉 You received a ${quest.reward.pet}!`, 'system');
            }
            
            addChatMessage('Quest Complete', `🎉 ${quest.name} completed! +${quest.reward.xp} XP, +${quest.reward.gold} Gold`, 'system');
            checkLevelUp();
            updateStats();
            renderInventory();
            renderQuests();
        }
        
        // Shop System
        function openShop() {
            document.getElementById('shopPanel').classList.add('active');
            renderShop();
        }
        
        function closeShop() {
            document.getElementById('shopPanel').classList.remove('active');
        }
        
        function openBank() {
            document.getElementById('bankPanel').classList.add('active');
            renderBank();
        }
        
        function closeBank() {
            document.getElementById('bankPanel').classList.remove('active');
        }
        
        function renderBank() {
            renderBankInventory();
            renderBankStorage();
        }
        
        function renderBankInventory() {
            const grid = document.getElementById('bankInventoryGrid');
            if (!grid) return;
            grid.innerHTML = '';
            
            Object.entries(currentPlayer.inventory).forEach(([name, count]) => {
                if (count > 0) {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot has-item';
                    slot.style.cursor = 'pointer';
                    
                    const icon = getItemIcon(name);
                    slot.innerHTML = icon;
                    
                    const countDiv = document.createElement('div');
                    countDiv.className = 'item-count';
                    countDiv.textContent = count;
                    slot.appendChild(countDiv);
                    
                    slot.onclick = () => depositItem(name, count);
                    slot.title = `Click to deposit ${name}`;
                    
                    grid.appendChild(slot);
                }
            });
        }
        
        function renderBankStorage() {
            const grid = document.getElementById('bankStorageGrid');
            if (!grid) return;
            grid.innerHTML = '';
            
            Object.entries(bankStorage).forEach(([name, count]) => {
                if (count > 0) {
                    const slot = document.createElement('div');
                    slot.className = 'inventory-slot has-item';
                    slot.style.cursor = 'pointer';
                    
                    const icon = getItemIcon(name);
                    slot.innerHTML = icon;
                    
                    const countDiv = document.createElement('div');
                    countDiv.className = 'item-count';
                    countDiv.textContent = count;
                    slot.appendChild(countDiv);
                    
                    slot.onclick = () => withdrawItem(name, count);
                    slot.title = `Click to withdraw ${name}`;
                    
                    grid.appendChild(slot);
                }
            });
        }
        
        function depositItem(itemName, maxCount) {
            const amount = prompt(`How many ${itemName} to deposit? (Max: ${maxCount})`);
            const count = parseInt(amount);
            
            if (isNaN(count) || count <= 0 || count > maxCount) {
                addChatMessage('Bank', 'Invalid amount', 'system');
                return;
            }
            
            currentPlayer.inventory[itemName] -= count;
            if (currentPlayer.inventory[itemName] <= 0) {
                delete currentPlayer.inventory[itemName];
            }
            
            bankStorage[itemName] = (bankStorage[itemName] || 0) + count;
            
            addChatMessage('Bank', `Deposited ${count} ${itemName}`, 'system');
            renderBank();
            renderInventory();
        }
        
        function withdrawItem(itemName, maxCount) {
            const amount = prompt(`How many ${itemName} to withdraw? (Max: ${maxCount})`);
            const count = parseInt(amount);
            
            if (isNaN(count) || count <= 0 || count > maxCount) {
                addChatMessage('Bank', 'Invalid amount', 'system');
                return;
            }
            
            bankStorage[itemName] -= count;
            if (bankStorage[itemName] <= 0) {
                delete bankStorage[itemName];
            }
            
            currentPlayer.inventory[itemName] = (currentPlayer.inventory[itemName] || 0) + count;
            
            addChatMessage('Bank', `Withdrew ${count} ${itemName}`, 'system');
            renderBank();
            renderInventory();
        }
        
        function renderShop() {
            const shopDiv = document.getElementById('shopItems');
            document.getElementById('shopGold').textContent = currentPlayer.gold;
            shopDiv.innerHTML = '';
            
            Object.entries(EQUIPMENT).forEach(([category, items]) => {
                const categoryEl = document.createElement('div');
                categoryEl.style.marginBottom = '1.5rem';
                categoryEl.innerHTML = `<h3 style="color: #3498db; margin-bottom: 0.5rem;">${category.charAt(0).toUpperCase() + category.slice(1)}</h3>`;
                
                Object.entries(items).forEach(([name, stats]) => {
                    const itemEl = document.createElement('div');
                    itemEl.style.background = 'rgba(52, 73, 94, 0.5)';
                    itemEl.style.padding = '1rem';
                    itemEl.style.borderRadius = '5px';
                    itemEl.style.marginBottom = '0.5rem';
                    
                    const statsText = Object.entries(stats).filter(([k, v]) => k !== 'value' && k !== 'level').map(([k, v]) => `+${v} ${k}`).join(', ');
                    
                    itemEl.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${name}</strong> (Lv.${stats.level})
                                <div style="font-size: 0.8rem; color: #95a5a6;">${statsText}</div>
                            </div>
                            <button class="action-btn" style="padding: 0.5rem 1rem; font-size: 0.9rem;" onclick="buyItem('${category}', '${name}')">
                                💰 ${stats.value}
                            </button>
                        </div>
                    `;
                    categoryEl.appendChild(itemEl);
                });
                
                shopDiv.appendChild(categoryEl);
            });
        }
        
        function buyItem(category, itemName) {
            const item = EQUIPMENT[category][itemName];
            
            if (currentPlayer.level < item.level) {
                addChatMessage('Shop', `You need to be level ${item.level} to buy this!`, 'system');
                return;
            }
            
            if (currentPlayer.gold < item.value) {
                addChatMessage('Shop', 'Not enough gold!', 'system');
                return;
            }
            
            currentPlayer.gold -= item.value;
            
            const slot = category.slice(0, -1); // Remove 's' from category
            currentPlayer.equipment[slot] = itemName;
            
            // Apply stats
            if (item.damage) currentPlayer.stats.strength += item.damage;
            if (item.defense) currentPlayer.stats.defense += item.defense;
            if (item.magic) currentPlayer.stats.magic += item.magic;
            if (item.speed) currentPlayer.stats.speed += item.speed;
            
            addChatMessage('Shop', `Purchased ${itemName}!`, 'system');
            updateStats();
            renderShop();
        }
        
        // Bank System
        function openBank() {
            document.getElementById('bankPanel').classList.add('active');
            renderBank();
        }
        
        function closeBank() {
            document.getElementById('bankPanel').classList.remove('active');
        }
        
        function renderBank() {
            // Render inventory
            const invGrid = document.getElementById('bankInventoryGrid');
            invGrid.innerHTML = '';
            
            Object.entries(currentPlayer.inventory).forEach(([item, count]) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'inventory-slot has-item';
                itemEl.style.cursor = 'pointer';
                itemEl.onclick = () => depositItem(item);
                
                const icon = getItemIcon(item);
                itemEl.innerHTML = `
                    <div>${icon}</div>
                    <div class="item-count">${count}</div>
                `;
                itemEl.title = `${item} (Click to deposit)`;
                invGrid.appendChild(itemEl);
            });
            
            // Render bank storage
            const bankGrid = document.getElementById('bankStorageGrid');
            bankGrid.innerHTML = '';
            
            Object.entries(bankStorage).forEach(([item, count]) => {
                const itemEl = document.createElement('div');
                itemEl.className = 'inventory-slot has-item';
                itemEl.style.cursor = 'pointer';
                itemEl.onclick = () => withdrawItem(item);
                
                const icon = getItemIcon(item);
                itemEl.innerHTML = `
                    <div>${icon}</div>
                    <div class="item-count">${count}</div>
                `;
                itemEl.title = `${item} (Click to withdraw)`;
                bankGrid.appendChild(itemEl);
            });
        }
        
        function depositItem(item) {
            if (!currentPlayer.inventory[item]) return;
            
            if (!bankStorage[item]) bankStorage[item] = 0;
            bankStorage[item]++;
            currentPlayer.inventory[item]--;
            
            if (currentPlayer.inventory[item] === 0) {
                delete currentPlayer.inventory[item];
            }
            
            addChatMessage('Bank', `Deposited 1x ${item}`, 'system');
            renderBank();
            renderInventory();
        }
        
        function withdrawItem(item) {
            if (!bankStorage[item]) return;
            
            if (!currentPlayer.inventory[item]) currentPlayer.inventory[item] = 0;
            currentPlayer.inventory[item]++;
            bankStorage[item]--;
            
            if (bankStorage[item] === 0) {
                delete bankStorage[item];
            }
            
            addChatMessage('Bank', `Withdrew 1x ${item}`, 'system');
            renderBank();
            renderInventory();
        }
        
        // Equipment System (RuneScape style)
        function toggleStatsPanel() {
            const content = document.getElementById('statsContent');
            const toggle = document.getElementById('statsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }
        
        function toggleSkillsPanel() {
            const content = document.getElementById('skillsContent');
            const toggle = document.getElementById('skillsToggle');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                content.style.display = 'none';
                toggle.textContent = '▶';
            }
        }
        
        function openControlsPanel() {
            document.getElementById('controlsPanel').classList.add('active');
        }
        
        function closeControlsPanel() {
            document.getElementById('controlsPanel').classList.remove('active');
        }
        
        function openEquipment() {
            document.getElementById('equipmentPanel').classList.add('active');
            renderEquipmentPanel();
        }
        
        function closeEquipment() {
            document.getElementById('equipmentPanel').classList.remove('active');
        }
        
        function renderEquipmentPanel() {
            // Update worn equipment display
            ['head', 'weapon', 'body', 'feet'].forEach(slot => {
                const slotEl = document.getElementById(`equipSlot${slot.charAt(0).toUpperCase() + slot.slice(1)}`);
                const equipped = currentPlayer.equipment[slot];
                
                if (equipped) {
                    const itemData = findItemData(equipped);
                    slotEl.innerHTML = `${itemData ? itemData.icon : '❓'}<br><small style="font-size:0.6rem;">${equipped}</small>`;
                    slotEl.style.border = '2px solid #f39c12';
                } else {
                    const defaultIcons = { head: '⛑️', weapon: '🗡️', body: '🛡️', feet: '👢' };
                    slotEl.innerHTML = defaultIcons[slot];
                    slotEl.style.border = '2px solid #555';
                }
            });
            
            // Calculate totals
            let totalDamage = 0;
            let totalDefense = 0;
            
            Object.values(currentPlayer.equipment).forEach(itemName => {
                if (!itemName) return;
                const itemData = findItemData(itemName);
                if (itemData) {
                    totalDamage += itemData.damage || 0;
                    totalDefense += itemData.defense || 0;
                }
            });
            
            document.getElementById('totalDamage').textContent = totalDamage;
            document.getElementById('totalDefense').textContent = totalDefense;
            
            // Render inventory with equippable items
            const invGrid = document.getElementById('equipmentInventoryGrid');
            invGrid.innerHTML = '';
            
            Object.entries(currentPlayer.inventory).forEach(([item, count]) => {
                const itemData = findItemData(item);
                if (!itemData || !itemData.slot) return; // Only show equippable items
                
                const itemEl = document.createElement('div');
                itemEl.className = 'inventory-slot has-item';
                itemEl.style.cursor = 'pointer';
                itemEl.onclick = () => equipItem(item);
                
                itemEl.innerHTML = `
                    <div>${itemData.icon}</div>
                    <div class="item-count">${count}</div>
                `;
                itemEl.title = `${item} (Click to equip)`;
                invGrid.appendChild(itemEl);
            });
        }
        
        function equipItem(itemName) {
            const itemData = findItemData(itemName);
            if (!itemData || !itemData.slot) return;
            
            const slot = itemData.slot === 'body' ? 'body' : 
                        itemData.slot === 'head' ? 'head' : 
                        itemData.slot === 'feet' ? 'feet' : 
                        itemData.slot === 'weapon' ? 'weapon' : null;
            
            if (!slot) return;
            
            // Unequip current item in that slot
            if (currentPlayer.equipment[slot]) {
                const oldItem = currentPlayer.equipment[slot];
                if (!currentPlayer.inventory[oldItem]) currentPlayer.inventory[oldItem] = 0;
                currentPlayer.inventory[oldItem]++;
            }
            
            // Equip new item
            currentPlayer.equipment[slot] = itemName;
            currentPlayer.inventory[itemName]--;
            
            if (currentPlayer.inventory[itemName] === 0) {
                delete currentPlayer.inventory[itemName];
            }
            
            addChatMessage('Equipment', `Equipped ${itemName}`, 'system');
            renderEquipmentPanel();
            renderInventory();
            updateStats();
        }
        
        function unequipItem(slot) {
            if (!currentPlayer.equipment[slot]) return;
            
            const itemName = currentPlayer.equipment[slot];
            
            // Add to inventory
            if (!currentPlayer.inventory[itemName]) currentPlayer.inventory[itemName] = 0;
            currentPlayer.inventory[itemName]++;
            
            // Remove from equipment
            currentPlayer.equipment[slot] = null;
            
            addChatMessage('Equipment', `Unequipped ${itemName}`, 'system');
            renderEquipmentPanel();
            renderInventory();
            updateStats();
        }
        
        function findItemData(itemName) {
            for (const category of Object.values(EQUIPMENT)) {
                if (category[itemName]) {
                    return category[itemName];
                }
            }
            return null;
        }
        
        // PVP System
        function checkPVPArea() {
            const inPVP = 
                currentPlayer.x > PVP_AREA.x - PVP_AREA.width/2 &&
                currentPlayer.x < PVP_AREA.x + PVP_AREA.width/2 &&
                currentPlayer.z > PVP_AREA.z - PVP_AREA.depth/2 &&
                currentPlayer.z < PVP_AREA.z + PVP_AREA.depth/2;
            
            if (inPVP && !pvpEnabled) {
                pvpEnabled = true;
                addChatMessage('PVP', '⚠️ You have entered the Wilderness! PVP is enabled! Death will cause you to drop all items!', 'system');
            } else if (!inPVP && pvpEnabled) {
                pvpEnabled = false;
                targetPlayer = null;
                addChatMessage('PVP', 'You have left the Wilderness. PVP is disabled.', 'system');
            }
            
            // Check if player died in PVP
            if (pvpEnabled && currentPlayer.hp <= 0) {
                handlePVPDeath();
            }
        }
        
        function handlePVPDeath() {
            // Drop all items at death location
            const deathX = currentPlayer.x;
            const deathZ = currentPlayer.z;
            
            addChatMessage('Death', '💀 You have died! All items dropped at death location.', 'system');
            
            // Clear inventory and equipment
            currentPlayer.inventory = {};
            currentPlayer.equipment = {
                weapon: null,
                armor: null,
                helmet: null,
                boots: null,
                gloves: null,
                offhand: null
            };
            
            // Respawn at map center
            currentPlayer.x = 0;
            currentPlayer.z = 0;
            currentPlayer.hp = currentPlayer.maxHp;
            pvpEnabled = false;
            
            // Update UI
            updateStats();
            renderInventory();
            updateEquipmentDisplay();
            
            addChatMessage('Respawn', '🏥 You have respawned at the town center.', 'system');
        }
        
        // Achievement System
        function openAchievements() {
            document.getElementById('achievementsPanel').classList.add('active');
            renderAchievements();
        }
        
        function closeAchievements() {
            document.getElementById('achievementsPanel').classList.remove('active');
        }
        
        function renderAchievements() {
            const list = document.getElementById('achievementsList');
            list.innerHTML = '';
            
            ACHIEVEMENTS.forEach(achievement => {
                const unlocked = currentPlayer.achievements.includes(achievement.id);
                const achEl = document.createElement('div');
                achEl.style.background = unlocked ? 'rgba(46, 204, 113, 0.2)' : 'rgba(52, 73, 94, 0.5)';
                achEl.style.padding = '1rem';
                achEl.style.borderRadius = '10px';
                achEl.style.marginBottom = '0.5rem';
                achEl.style.borderLeft = unlocked ? '4px solid #2ecc71' : '4px solid #34495e';
                
                achEl.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="font-size: 2rem;">${achievement.icon}</div>
                        <div style="flex: 1;">
                            <strong style="color: ${unlocked ? '#2ecc71' : '#95a5a6'};">${achievement.name}</strong>
                            <div style="font-size: 0.9rem; color: #95a5a6;">${achievement.description}</div>
                        </div>
                        ${unlocked ? '<div style="color: #2ecc71; font-size: 1.5rem;">✓</div>' : ''}
                    </div>
                `;
                list.appendChild(achEl);
            });
        }
        
        function checkAchievement(id) {
            if (!currentPlayer.achievements.includes(id)) {
                currentPlayer.achievements.push(id);
                const achievement = ACHIEVEMENTS.find(a => a.id === id);
                if (achievement) {
                    addChatMessage('Achievement', `🏆 Unlocked: ${achievement.name}!`, 'system');
                }
            }
        }
        
        // Particle System
        function createParticle(x, y, z, color, emoji) {
            const particle = {
                mesh: null,
                x, y, z,
                lifetime: 1000,
                created: Date.now()
            };
            
            // Create visual particle
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y + 1, z);
            particle.mesh = mesh;
            scene.add(mesh);
            
            particles.push(particle);
        }
        
        function updateParticles() {
            const now = Date.now();
            particles = particles.filter(particle => {
                const age = now - particle.created;
                if (age > particle.lifetime) {
                    scene.remove(particle.mesh);
                    return false;
                }
                
                // Animate particle
                particle.mesh.position.y += 0.02;
                particle.mesh.material.opacity = 1 - (age / particle.lifetime);
                particle.mesh.material.transparent = true;
                
                return true;
            });
        }
        
        // Day/Night Cycle
        function updateDayNightCycle() {
            timeOfDay += dayNightSpeed;
            if (timeOfDay >= 24) timeOfDay = 0;
            
            // Update lighting based on time
            const hour = Math.floor(timeOfDay);
            let intensity, color;
            
            if (hour >= 6 && hour < 18) {
                // Day
                intensity = 0.8;
                color = 0xffffff;
                scene.background = new THREE.Color(0x87CEEB);
                document.getElementById('timeIcon').textContent = '☀️';
                document.getElementById('timeText').textContent = 'Day';
            } else {
                // Night
                intensity = 0.3;
                color = 0x6666ff;
                scene.background = new THREE.Color(0x001a33);
                document.getElementById('timeIcon').textContent = '🌙';
                document.getElementById('timeText').textContent = 'Night';
            }
            
            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    child.intensity = intensity;
                    child.color.setHex(color);
                }
            });
        }
        
        // Mini-map with rotation
        function updateMiniMap() {
            const miniMapCanvas = document.getElementById('miniMapCanvas');
            if (!miniMapCanvas) return;
            
            const ctx = miniMapCanvas.getContext('2d');
            const size = 200;
            const centerX = size / 2;
            const centerY = size / 2;
            
            ctx.clearRect(0, 0, size, size);
            
            // Save context and rotate based on camera angle
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(cameraAngle);
            ctx.translate(-centerX, -centerY);
            
            // Draw background
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, size, size);
            
            const scale = size / (MAP_SIZE * 2);
            
            // Draw monsters
            monsters.forEach(monster => {
                if (monster.currentHp > 0) {
                    const x = centerX + (monster.x - currentPlayer.x) * scale;
                    const y = centerY + (monster.z - currentPlayer.z) * scale;
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw resources
            resources.forEach(resource => {
                if (resource.available) {
                    const x = centerX + (resource.x - currentPlayer.x) * scale;
                    const y = centerY + (resource.z - currentPlayer.z) * scale;
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
            });
            
            // Draw NPCs with clear symbols
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            NPCS.forEach(npc => {
                const x = centerX + (npc.x - currentPlayer.x) * scale;
                const y = centerY + (npc.z - currentPlayer.z) * scale;
                
                // Draw background circle
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw icon based on NPC type with dedicated symbols
                ctx.font = 'bold 14px Arial';
                if (npc.type === 'bank') {
                    ctx.fillStyle = '#FFD700'; // Gold for bank
                    ctx.fillText('🏦', x, y);  // Bank symbol
                } else if (npc.type === 'shop') {
                    ctx.fillStyle = '#FF8C00'; // Orange for shop
                    ctx.fillText('🏪', x, y);  // Shop symbol
                } else if (npc.type === 'quest') {
                    ctx.fillStyle = '#FFA500'; // Orange for quest
                    ctx.fillText('❗', x, y);  // Quest symbol
                } else if (npc.type === 'pet') {
                    ctx.fillStyle = '#9370DB'; // Purple for pets
                    ctx.fillText('🐾', x, y);  // Pet symbol
                }
            });
            
            // Draw PVP Area
            const pvpX = centerX + (PVP_AREA.x - currentPlayer.x) * scale;
            const pvpY = centerY + (PVP_AREA.z - currentPlayer.z) * scale;
            const pvpWidth = PVP_AREA.width * scale;
            const pvpHeight = PVP_AREA.depth * scale;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.fillRect(pvpX - pvpWidth/2, pvpY - pvpHeight/2, pvpWidth, pvpHeight);
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(pvpX - pvpWidth/2, pvpY - pvpHeight/2, pvpWidth, pvpHeight);
            
            // Draw houses
            HOUSES.forEach(houseData => {
                const x = centerX + (houseData.x - currentPlayer.x) * scale;
                const y = centerY + (houseData.z - currentPlayer.z) * scale;
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - 4, y - 4, 8, 8);
            });
            
            // Bank icon already drawn in NPC loop above
            
            // Draw other players
            Object.values(players).forEach(player => {
                const x = centerX + (player.x - currentPlayer.x) * scale;
                const y = centerY + (player.z - currentPlayer.z) * scale;
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Restore context after rotation
            ctx.restore();
            
            // Draw player (center) - more visible
            ctx.fillStyle = '#f39c12';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw direction arrow
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX, centerY - 12);
            ctx.stroke();
            
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(centerX - 3, centerY - 8);
            ctx.lineTo(centerX, centerY - 12);
            ctx.lineTo(centerX + 3, centerY - 8);
            ctx.stroke();
            
            // Update compass
            updateCompass();
        }
        
        function updateCompass() {
            const compassEl = document.getElementById('compassIndicator');
            if (!compassEl) return;
            
            // Calculate compass direction based on camera angle
            const degrees = (cameraAngle * 180 / Math.PI) % 360;
            let direction = 'N';
            
            if (degrees >= -22.5 && degrees < 22.5) direction = 'N';
            else if (degrees >= 22.5 && degrees < 67.5) direction = 'NE';
            else if (degrees >= 67.5 && degrees < 112.5) direction = 'E';
            else if (degrees >= 112.5 && degrees < 157.5) direction = 'SE';
            else if (degrees >= 157.5 || degrees < -157.5) direction = 'S';
            else if (degrees >= -157.5 && degrees < -112.5) direction = 'SW';
            else if (degrees >= -112.5 && degrees < -67.5) direction = 'W';
            else if (degrees >= -67.5 && degrees < -22.5) direction = 'NW';
            
            compassEl.textContent = direction;
        }
        
        // Loot System
        function handleMonsterDeath(monster) {
            updateQuestProgress('kill', monster.name);
            checkAchievement('first_kill');
            if (monster.name === 'Dragon') checkAchievement('dragon_slayer');
            
            // Drop loot
            const goldDrop = Math.floor(monster.xp * 0.5 + Math.random() * 20);
            currentPlayer.gold += goldDrop;
            addChatMessage('Loot', `+${goldDrop} gold!`, 'system');
            
            // Chance to drop equipment
            if (Math.random() < 0.1) {
                const rareDrop = ['Iron Sword', 'Steel Armor', 'Magic Staff'][Math.floor(Math.random() * 3)];
                currentPlayer.inventory[rareDrop] = (currentPlayer.inventory[rareDrop] || 0) + 1;
                addChatMessage('Loot', `Found ${rareDrop}!`, 'system');
            }
            
            // Buff drops from monsters
            maybeDropBuff();
            
            if (currentPlayer.gold >= 1000) checkAchievement('rich');
        }
        
        function checkLevelUp() {
            const xpNeeded = currentPlayer.level * 100;
            if (currentPlayer.xp >= xpNeeded) {
                currentPlayer.level++;
                currentPlayer.xp = 0;
                currentPlayer.maxHp += 10;
                currentPlayer.maxMp += 10;
                currentPlayer.hp = currentPlayer.maxHp;
                currentPlayer.mp = currentPlayer.maxMp;
                currentPlayer.stats.strength += 2;
                currentPlayer.stats.defense += 2;
                currentPlayer.stats.magic += 2;
                currentPlayer.stats.speed += 1;
                
                addChatMessage('Level Up!', `🎉 You are now level ${currentPlayer.level}!`, 'system');
                createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0xffd700, '🌟');
                
                if (currentPlayer.level >= 10) checkAchievement('level_10');
            }
        }
        
        // Enhanced game loop additions
        setInterval(() => {
            // Update ability cooldowns
            Object.values(currentPlayer.abilities).forEach(ability => {
                if (ability.cooldown > 0) {
                    ability.cooldown = Math.max(0, ability.cooldown - 100);
                }
            });
            
            // Regenerate MP
            currentPlayer.mp = Math.min(currentPlayer.maxMp, currentPlayer.mp + 0.5);
            
            // Update particles
            updateParticles();
            
            // Update day/night
            updateDayNightCycle();
            
            // Update mini-map
            updateMiniMap();
            
            updateStats();
        }, 100);
        
        // Keyboard shortcuts for abilities
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') useAbility('fireball');
            if (e.key === '2') useAbility('heal');
            if (e.key === '3') useAbility('lightning');
            if (e.key === '4') changeWeather(); // Debug: Change weather
        });

        // ========== NEW CREATIVE FEATURES ==========
        
        // PET SYSTEM
        function openPetShop() {
            document.getElementById('petShopPanel').style.display = 'block';
            document.getElementById('petShopGold').textContent = currentPlayer.gold;
            document.getElementById('activePet').textContent = currentPlayer.pet || 'None';
            
            const container = document.getElementById('petShopItems');
            container.innerHTML = '';
            
            Object.entries(PETS).forEach(([name, pet]) => {
                const canBuy = currentPlayer.level >= pet.level && currentPlayer.gold >= pet.cost;
                const owned = currentPlayer.pet === name;
                
                container.innerHTML += `
                    <div class="quest-item" style="opacity: ${canBuy || owned ? 1 : 0.5};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 2rem;">${pet.icon}</div>
                                <strong>${name}</strong>
                                <p style="font-size: 0.85rem; color: #bdc3c7; margin: 0.3rem 0;">${pet.description}</p>
                                <span style="color: #e74c3c;">💥 ${pet.damage} damage</span>
                                ${pet.healing ? `<span style="color: #2ecc71;"> | 💚 ${pet.healing} healing</span>` : ''}
                                <br><span style="color: #95a5a6;">Level ${pet.level} required</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #f39c12; font-size: 1.1rem; margin-bottom: 0.5rem;">💰 ${pet.cost}</div>
                                ${owned ? '<span style="color: #2ecc71;">✓ Active</span>' : 
                                  canBuy ? `<button class="action-btn" style="padding: 0.5rem 1rem;" onclick="buyPet('${name}')">Buy</button>` : 
                                  '<span style="color: #e74c3c;">Locked</span>'}
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        function buyPet(petName) {
            const pet = PETS[petName];
            if (currentPlayer.level < pet.level) {
                addChatMessage('Pet Shop', `You need level ${pet.level} to buy this pet!`, 'system');
                return;
            }
            if (currentPlayer.gold < pet.cost) {
                addChatMessage('Pet Shop', 'Not enough gold!', 'system');
                return;
            }
            
            currentPlayer.gold -= pet.cost;
            currentPlayer.pet = petName;
            addChatMessage('Pet Shop', `🐾 You bought ${petName}!`, 'system');
            createPetMesh();
            openPetShop(); // Refresh display
            saveGame();
        }
        
        function createPetMesh() {
            if (!currentPlayer.pet) return;
            
            // Remove old pet
            if (petMesh) {
                scene.remove(petMesh);
            }
            
            const pet = PETS[currentPlayer.pet];
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshStandardMaterial({ 
                color: pet.icon === '🐺' ? 0x808080 : pet.icon === '🔥' ? 0xff4500 : pet.icon === '🐉' ? 0x4169E1 : 0xff6347,
                emissive: pet.icon === '🔥' ? 0xff4500 : 0x000000,
                emissiveIntensity: 0.3
            });
            petMesh = new THREE.Mesh(geometry, material);
            petMesh.castShadow = true;
            scene.add(petMesh);
        }
        
        function updatePet() {
            if (!petMesh || !currentPlayer.pet) return;
            
            // Pet follows player with offset
            const offsetDistance = 2;
            const offsetAngle = currentPlayer.rotation + Math.PI;
            petMesh.position.x = currentPlayer.x + Math.sin(offsetAngle) * offsetDistance;
            petMesh.position.y = currentPlayer.y + 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
            petMesh.position.z = currentPlayer.z + Math.cos(offsetAngle) * offsetDistance;
            
            // Pet attacks nearby monsters
            if (Math.random() < 0.05) {
                const pet = PETS[currentPlayer.pet];
                const nearbyMonster = findNearestMonster(5);
                if (nearbyMonster) {
                    nearbyMonster.currentHp -= pet.damage;
                    createParticle(nearbyMonster.x, nearbyMonster.y, nearbyMonster.z, 0xff6347, '💥');
                }
            }
        }
        
        function closePetShop() {
            document.getElementById('petShopPanel').style.display = 'none';
        }
        
        function respawnPet() {
            if (!currentPlayer.pet) {
                addChatMessage('Pet System', 'You don\'t own any pets yet! Visit the Pet Shop.', 'system');
                return;
            }
            
            // Remove old pet mesh if exists
            if (petMesh) {
                scene.remove(petMesh);
            }
            
            // Recreate pet mesh
            createPetMesh();
            addChatMessage('Pet System', `🐾 Your ${currentPlayer.pet} has been respawned!`, 'system');
        }
        
        // QUEST SYSTEM FUNCTIONS
        function openQuestsPanel() {
            document.getElementById('questsPanel').style.display = 'block';
            updateQuestsDisplay();
        }
        
        function closeQuestsPanel() {
            document.getElementById('questsPanel').style.display = 'none';
        }
        
        function updateQuestsDisplay() {
            // Active Quests
            const activeContainer = document.getElementById('activeQuestsList');
            activeContainer.innerHTML = '';
            
            if (!currentPlayer.quests) {
                currentPlayer.quests = { active: [], completed: [] };
            }
            
            if (currentPlayer.quests.active.length === 0) {
                activeContainer.innerHTML = '<p style="color: #95a5a6; font-style: italic;">No active quests</p>';
            } else {
                currentPlayer.quests.active.forEach(activeQuest => {
                    const quest = QUESTS.find(q => q.id === activeQuest.id);
                    if (quest) {
                        const progress = activeQuest.currentStep || 0;
                        const totalSteps = quest.steps.length;
                        
                        activeContainer.innerHTML += `
                            <div class="quest-item" onclick="showQuestDetails('${quest.id}')" style="cursor: pointer; border-left: 4px solid #2ecc71;">
                                <div>
                                    <strong style="color: #2ecc71;">${quest.name}</strong>
                                    <p style="font-size: 0.85rem; color: #bdc3c7; margin: 0.3rem 0;">${quest.description}</p>
                                    <div style="margin-top: 0.5rem;">
                                        <div style="background: rgba(0,0,0,0.3); border-radius: 10px; height: 8px; overflow: hidden;">
                                            <div style="background: #2ecc71; height: 100%; width: ${(progress / totalSteps) * 100}%;"></div>
                                        </div>
                                        <span style="font-size: 0.75rem; color: #95a5a6;">Step ${progress + 1}/${totalSteps}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                });
            }
            
            // Available Quests
            const availableContainer = document.getElementById('availableQuestsList');
            availableContainer.innerHTML = '';
            
            const availableQuests = QUESTS.filter(quest => {
                const isCompleted = currentPlayer.quests.completed.includes(quest.id);
                const isActive = currentPlayer.quests.active.find(q => q.id === quest.id);
                const meetsLevel = currentPlayer.level >= (quest.level || 1);
                return !isCompleted && !isActive && meetsLevel;
            });
            
            if (availableQuests.length === 0) {
                availableContainer.innerHTML = '<p style="color: #95a5a6; font-style: italic;">No available quests</p>';
            } else {
                availableQuests.forEach(quest => {
                    const rewards = [];
                    if (quest.reward.xp) rewards.push(`⭐ ${quest.reward.xp} XP`);
                    if (quest.reward.gold) rewards.push(`💰 ${quest.reward.gold} Gold`);
                    if (quest.reward.item) rewards.push(`🎁 ${quest.reward.item}`);
                    
                    availableContainer.innerHTML += `
                        <div class="quest-item" onclick="showQuestDetails('${quest.id}')" style="cursor: pointer;">
                            <div>
                                <strong style="color: #3498db;">${quest.name}</strong>
                                <p style="font-size: 0.85rem; color: #bdc3c7; margin: 0.3rem 0;">${quest.description}</p>
                                <div style="font-size: 0.85rem; color: #f39c12; margin-top: 0.3rem;">
                                    Rewards: ${rewards.join(' | ')}
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            // Completed Quests
            const completedContainer = document.getElementById('completedQuestsList');
            completedContainer.innerHTML = '';
            
            const completedQuests = QUESTS.filter(quest => 
                currentPlayer.quests.completed.includes(quest.id)
            );
            
            if (completedQuests.length === 0) {
                completedContainer.innerHTML = '<p style="color: #95a5a6; font-style: italic;">No completed quests yet</p>';
            } else {
                completedQuests.forEach(quest => {
                    completedContainer.innerHTML += `
                        <div class="quest-item" style="opacity: 0.7;">
                            <div>
                                <strong style="color: #95a5a6;">✅ ${quest.name}</strong>
                            </div>
                        </div>
                    `;
                });
            }
        }
        
        function showQuestDetails(questId) {
            const quest = QUESTS.find(q => q.id === questId);
            if (!quest) return;
            
            const isActive = currentPlayer.quests.active.find(q => q.id === questId);
            const isCompleted = currentPlayer.quests.completed.includes(questId);
            
            const detailsPanel = document.getElementById('questDetailsPanel');
            const titleEl = document.getElementById('questDetailsTitle');
            const contentEl = document.getElementById('questDetailsContent');
            
            titleEl.textContent = quest.name;
            
            let stepsHTML = '<h3 style="color: #3498db; margin-top: 1rem;">Quest Steps:</h3><ul style="margin-left: 1.5rem;">';
            quest.steps.forEach((step, index) => {
                const stepCompleted = isActive && (isActive.currentStep || 0) > index;
                const stepCurrent = isActive && (isActive.currentStep || 0) === index;
                const stepColor = stepCompleted ? '#2ecc71' : stepCurrent ? '#f39c12' : '#95a5a6';
                const stepIcon = stepCompleted ? '✅' : stepCurrent ? '🔸' : '⭕';
                
                stepsHTML += `<li style="color: ${stepColor}; margin: 0.5rem 0;">${stepIcon} ${step.text}</li>`;
            });
            stepsHTML += '</ul>';
            
            const rewards = [];
            if (quest.reward.xp) rewards.push(`⭐ ${quest.reward.xp} XP`);
            if (quest.reward.gold) rewards.push(`💰 ${quest.reward.gold} Gold`);
            if (quest.reward.item) rewards.push(`🎁 ${quest.reward.item}`);
            
            contentEl.innerHTML = `
                <p style="color: #bdc3c7; margin-bottom: 1rem;">${quest.description}</p>
                ${stepsHTML}
                <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(243, 156, 18, 0.2); border-radius: 10px;">
                    <h3 style="color: #f39c12; margin-bottom: 0.5rem;">🎁 Rewards:</h3>
                    <p style="color: #ecf0f1;">${rewards.join(' | ')}</p>
                </div>
                ${!isActive && !isCompleted ? `
                    <button class="action-btn" onclick="acceptQuest('${quest.id}')" style="width: 100%; margin-top: 1rem; padding: 0.8rem;">
                        Accept Quest
                    </button>
                ` : ''}
                ${isCompleted ? `
                    <div style="text-align: center; margin-top: 1rem; color: #2ecc71; font-size: 1.2rem;">
                        ✅ Quest Completed!
                    </div>
                ` : ''}
            `;
            
            detailsPanel.style.display = 'block';
        }
        
        function closeQuestDetails() {
            document.getElementById('questDetailsPanel').style.display = 'none';
        }
        
        function acceptQuest(questId) {
            const quest = QUESTS.find(q => q.id === questId);
            if (!quest) return;
            
            if (currentPlayer.level < (quest.level || 1)) {
                addChatMessage('Quests', `You need level ${quest.level} to accept this quest!`, 'system');
                return;
            }
            
            if (!currentPlayer.quests) {
                currentPlayer.quests = { active: [], completed: [] };
            }
            
            currentPlayer.quests.active.push({ id: questId, currentStep: 0 });
            addChatMessage('Quests', `📜 Quest accepted: ${quest.name}`, 'system');
            
            closeQuestDetails();
            updateQuestsDisplay();
        }
        
        // CRAFTING SYSTEM
        function openCraftingPanel() {
            document.getElementById('craftingPanel').style.display = 'block';
            document.getElementById('craftingLevel').textContent = currentPlayer.skills.crafting;
            
            const container = document.getElementById('craftingRecipes');
            container.innerHTML = '';
            
            Object.entries(CRAFTING_RECIPES).forEach(([itemName, recipe]) => {
                const canCraft = currentPlayer.skills.crafting >= recipe.level && 
                                 Object.entries(recipe.materials).every(([mat, qty]) => 
                                     (currentPlayer.inventory[mat] || 0) >= qty);
                
                const materialsText = Object.entries(recipe.materials)
                    .map(([mat, qty]) => {
                        const has = currentPlayer.inventory[mat] || 0;
                        const color = has >= qty ? '#2ecc71' : '#e74c3c';
                        return `<span style="color: ${color};">${mat} ${has}/${qty}</span>`;
                    }).join(', ');
                
                container.innerHTML += `
                    <div class="quest-item" style="opacity: ${canCraft ? 1 : 0.5};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>Craft ${itemName}</strong>
                                <p style="font-size: 0.85rem; margin: 0.3rem 0;">${materialsText}</p>
                                <span style="color: #3498db;">+${recipe.craftingXP} Crafting XP</span>
                                <span style="color: #95a5a6;"> | Level ${recipe.level}</span>
                            </div>
                            <button class="action-btn craft" style="padding: 0.5rem 1rem;" 
                                    onclick="craftItem('${itemName}')" ${!canCraft ? 'disabled' : ''}>
                                Craft
                            </button>
                        </div>
                    </div>
                `;
            });
        }
        
        function craftItem(itemName) {
            const recipe = CRAFTING_RECIPES[itemName];
            if (!recipe) return;
            
            if (currentPlayer.skills.crafting < recipe.level) {
                addChatMessage('Crafting', `You need crafting level ${recipe.level}!`, 'system');
                return;
            }
            
            // Check materials
            for (let [mat, qty] of Object.entries(recipe.materials)) {
                if ((currentPlayer.inventory[mat] || 0) < qty) {
                    addChatMessage('Crafting', `Not enough ${mat}!`, 'system');
                    return;
                }
            }
            
            // Consume materials
            for (let [mat, qty] of Object.entries(recipe.materials)) {
                currentPlayer.inventory[mat] -= qty;
                if (currentPlayer.inventory[mat] <= 0) delete currentPlayer.inventory[mat];
            }
            
            // Create item
            currentPlayer.inventory[itemName] = (currentPlayer.inventory[itemName] || 0) + 1;
            currentPlayer.skills.crafting += recipe.craftingXP / 100;
            currentPlayer.craftedItems++;
            
            addChatMessage('Crafting', `🔨 Crafted ${itemName}!`, 'system');
            createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0xffa500, '✨');
            updateQuestProgress('craft');
            
            if (isMobile && navigator.vibrate) navigator.vibrate(50);
            
            openCraftingPanel(); // Refresh
            renderInventory();
            saveGame();
        }
        
        function closeCraftingPanel() {
            document.getElementById('craftingPanel').style.display = 'none';
        }
        
        // PARTICLE AND EMOTE SYSTEM
        function createParticle(x, y, z, color, emoji) {
            if (!scene) return;
            
            // Create emoji sprite using canvas
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Draw emoji
            context.font = 'Bold 80px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(emoji, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(x, y, z);
            sprite.scale.set(1, 1, 1);
            scene.add(sprite);
            
            // Animate upward and fade out
            let lifetime = 0;
            const animateParticle = () => {
                lifetime += 0.05;
                sprite.position.y += 0.02;
                sprite.material.opacity = 1 - lifetime;
                
                if (lifetime < 1) {
                    requestAnimationFrame(animateParticle);
                } else {
                    scene.remove(sprite);
                    sprite.material.dispose();
                    texture.dispose();
                }
            };
            animateParticle();
        }
        
        // PET SYSTEM
        function createPetMesh() {
            if (!currentPlayer.pet || !scene || petMesh) return;
            
            const petData = PETS[currentPlayer.pet];
            if (!petData) return;
            
            const petGroup = new THREE.Group();
            
            // Create pet based on type
            if (currentPlayer.pet === 'Wolf Pup') {
                // Wolf body
                const bodyGeometry = new THREE.BoxGeometry(0.6, 0.4, 0.8);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x808080 });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.3;
                body.castShadow = true;
                petGroup.add(body);
                
                // Wolf head
                const headGeometry = new THREE.BoxGeometry(0.4, 0.35, 0.4);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0, 0.4, 0.5);
                head.castShadow = true;
                petGroup.add(head);
                
                // Ears
                const earGeometry = new THREE.ConeGeometry(0.1, 0.2, 4);
                const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
                leftEar.position.set(-0.15, 0.65, 0.5);
                leftEar.castShadow = true;
                petGroup.add(leftEar);
                
                const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
                rightEar.position.set(0.15, 0.65, 0.5);
                rightEar.castShadow = true;
                petGroup.add(rightEar);
                
                // Tail
                const tailGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.4, 8);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(0, 0.4, -0.5);
                tail.rotation.x = Math.PI / 4;
                tail.castShadow = true;
                petGroup.add(tail);
                
            } else if (currentPlayer.pet === 'Fire Spirit') {
                // Fire spirit body (floating flame)
                const bodyGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4500,
                    emissive: 0xff4500,
                    emissiveIntensity: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                petGroup.add(body);
                
                // Flame wisps
                for (let i = 0; i < 5; i++) {
                    const wispGeometry = new THREE.ConeGeometry(0.1, 0.3, 4);
                    const wispMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0xffa500,
                        emissive: 0xff8c00,
                        emissiveIntensity: 0.8
                    });
                    const wisp = new THREE.Mesh(wispGeometry, wispMaterial);
                    const angle = (i / 5) * Math.PI * 2;
                    wisp.position.set(Math.cos(angle) * 0.3, 0.5 + Math.random() * 0.3, Math.sin(angle) * 0.3);
                    wisp.castShadow = true;
                    petGroup.add(wisp);
                }
                
            } else if (currentPlayer.pet === 'Ice Dragon') {
                // Dragon body
                const bodyGeometry = new THREE.BoxGeometry(0.5, 0.4, 0.9);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x87ceeb,
                    metalness: 0.3,
                    roughness: 0.7
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.4;
                body.castShadow = true;
                petGroup.add(body);
                
                // Dragon head
                const headGeometry = new THREE.BoxGeometry(0.35, 0.3, 0.45);
                const head = new THREE.Mesh(headGeometry, bodyMaterial);
                head.position.set(0, 0.5, 0.6);
                head.castShadow = true;
                petGroup.add(head);
                
                // Wings
                const wingGeometry = new THREE.BoxGeometry(0.6, 0.02, 0.5);
                const wingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xb0e0e6,
                    transparent: true,
                    opacity: 0.7
                });
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.5, 0.5, 0);
                leftWing.rotation.z = Math.PI / 6;
                leftWing.castShadow = true;
                petGroup.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.5, 0.5, 0);
                rightWing.rotation.z = -Math.PI / 6;
                rightWing.castShadow = true;
                petGroup.add(rightWing);
                
                // Tail
                const tailGeometry = new THREE.ConeGeometry(0.1, 0.6, 8);
                const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
                tail.position.set(0, 0.3, -0.6);
                tail.rotation.x = Math.PI / 2;
                tail.castShadow = true;
                petGroup.add(tail);
                
            } else if (currentPlayer.pet === 'Phoenix') {
                // Phoenix body
                const bodyGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff6347,
                    emissive: 0xff4500,
                    emissiveIntensity: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5;
                body.castShadow = true;
                petGroup.add(body);
                
                // Wings
                const wingGeometry = new THREE.BoxGeometry(0.8, 0.03, 0.5);
                const wingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffa500,
                    emissive: 0xff8c00,
                    emissiveIntensity: 0.2
                });
                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.6, 0.6, 0);
                leftWing.rotation.z = Math.PI / 4;
                leftWing.castShadow = true;
                petGroup.add(leftWing);
                
                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.6, 0.6, 0);
                rightWing.rotation.z = -Math.PI / 4;
                rightWing.castShadow = true;
                petGroup.add(rightWing);
                
                // Tail feathers
                for (let i = 0; i < 3; i++) {
                    const featherGeometry = new THREE.ConeGeometry(0.05, 0.4, 4);
                    const feather = new THREE.Mesh(featherGeometry, wingMaterial);
                    feather.position.set((i - 1) * 0.1, 0.3, -0.4);
                    feather.rotation.x = -Math.PI / 4;
                    feather.castShadow = true;
                    petGroup.add(feather);
                }
            }
            
            // Position pet next to player
            petGroup.position.set(currentPlayer.x + 1, currentPlayer.y, currentPlayer.z);
            petMesh = petGroup;
            scene.add(petMesh);
        }
        
        function updatePet() {
            if (petMesh && currentPlayer.pet) {
                // Follow player with slight offset and bobbing motion
                const targetX = currentPlayer.x + Math.cos(Date.now() * 0.001) * 1.5;
                const targetZ = currentPlayer.z + Math.sin(Date.now() * 0.001) * 1.5;
                
                petMesh.position.x += (targetX - petMesh.position.x) * 0.05;
                petMesh.position.z += (targetZ - petMesh.position.z) * 0.05;
                petMesh.position.y = currentPlayer.y + Math.sin(Date.now() * 0.003) * 0.2;
                
                // Rotate to face player
                const angle = Math.atan2(currentPlayer.x - petMesh.position.x, currentPlayer.z - petMesh.position.z);
                petMesh.rotation.y = angle;
            }
        }
        
        // WEATHER SYSTEM
        function changeWeather() {
            const newWeather = WEATHER_TYPES[Math.floor(Math.random() * WEATHER_TYPES.length)];
            setWeather(newWeather);
        }
        
        function setWeather(weatherType) {
            currentWeather = weatherType;
            
            // Clear old weather particles
            weatherParticles.forEach(p => scene.remove(p));
            weatherParticles = [];
            
            const weatherIcons = { clear: '☀️', rain: '🌧️', snow: '❄️', fog: '🌫️', storm: '⛈️' };
            document.getElementById('weatherIcon').textContent = weatherIcons[weatherType];
            document.getElementById('weatherText').textContent = weatherType.charAt(0).toUpperCase() + weatherType.slice(1);
            
            // Create weather effects
            if (weatherType === 'rain' || weatherType === 'snow' || weatherType === 'storm') {
                for (let i = 0; i < 100; i++) {
                    const geometry = new THREE.SphereGeometry(weatherType === 'snow' ? 0.05 : 0.03, 4, 4);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: weatherType === 'snow' ? 0xffffff : 0x4169e1,
                        transparent: true,
                        opacity: 0.6
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(
                        (Math.random() - 0.5) * MAP_SIZE,
                        Math.random() * 30 + 10,
                        (Math.random() - 0.5) * MAP_SIZE
                    );
                    particle.userData = { 
                        speed: weatherType === 'snow' ? 0.02 : (weatherType === 'storm' ? 0.3 : 0.1),
                        drift: Math.random() * 0.02 - 0.01
                    };
                    scene.add(particle);
                    weatherParticles.push(particle);
                }
            }
            
            // Fog effect
            if (weatherType === 'fog') {
                scene.fog = new THREE.Fog(0xcccccc, 50, 100);
            } else {
                scene.fog = new THREE.Fog(0x87CEEB, 150, 500);
            }
            
            // Storm darkens sky
            if (weatherType === 'storm') {
                scene.background = new THREE.Color(0x2c3e50);
            }
            
            addChatMessage('Weather', `Weather changed to ${weatherType}!`, 'system');
        }
        
        function updateWeather() {
            weatherParticles.forEach(particle => {
                particle.position.y -= particle.userData.speed;
                particle.position.x += particle.userData.drift;
                
                if (particle.position.y < 0) {
                    particle.position.y = 30;
                    particle.position.x = currentPlayer.x + (Math.random() - 0.5) * 50;
                    particle.position.z = currentPlayer.z + (Math.random() - 0.5) * 50;
                }
            });
            
            // Random weather changes
            if (Math.random() < 0.0005) {
                changeWeather();
            }
        }
        
        // BUFF SYSTEM
        function applyBuff(buffType) {
            const buff = BUFFS[buffType];
            if (!buff) return;
            
            const existingBuff = activeBuffs.find(b => b.type === buffType);
            if (existingBuff) {
                existingBuff.endTime = Date.now() + buff.duration;
            } else {
                activeBuffs.push({
                    type: buffType,
                    ...buff,
                    endTime: Date.now() + buff.duration
                });
                
                // Apply effect
                Object.entries(buff.effect).forEach(([stat, value]) => {
                    if (stat === 'hpRegen') return; // Handled separately
                    currentPlayer.stats[stat] = (currentPlayer.stats[stat] || 0) + value;
                });
                
                addChatMessage('Buff', `${buff.icon} ${buff.name} activated!`, 'system');
                createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0x9b59b6, '✨');
            }
            
            updateBuffDisplay();
        }
        
        function updateBuffs() {
            const now = Date.now();
            activeBuffs = activeBuffs.filter(buff => {
                if (now >= buff.endTime) {
                    // Remove effect
                    Object.entries(buff.effect).forEach(([stat, value]) => {
                        if (stat === 'hpRegen') return;
                        currentPlayer.stats[stat] = (currentPlayer.stats[stat] || 0) - value;
                    });
                    addChatMessage('Buff', `${buff.icon} ${buff.name} wore off`, 'system');
                    return false;
                }
                
                // Apply regen
                if (buff.effect.hpRegen) {
                    currentPlayer.hp = Math.min(currentPlayer.maxHp, currentPlayer.hp + buff.effect.hpRegen * 0.1);
                }
                
                return true;
            });
            
            updateBuffDisplay();
        }
        
        function updateBuffDisplay() {
            const container = document.getElementById('buffsContainer');
            container.innerHTML = '';
            
            activeBuffs.forEach(buff => {
                const timeLeft = Math.ceil((buff.endTime - Date.now()) / 1000);
                container.innerHTML += `
                    <div style="background: rgba(155, 89, 182, 0.9); padding: 0.5rem; border-radius: 10px; text-align: center; min-width: 50px;">
                        <div style="font-size: 1.5rem;">${buff.icon}</div>
                        <div style="font-size: 0.7rem;">${timeLeft}s</div>
                    </div>
                `;
            });
        }
        
        // Random buff drops from monsters
        function maybeDropBuff() {
            if (Math.random() < 0.15) {
                const buffTypes = Object.keys(BUFFS);
                const randomBuff = buffTypes[Math.floor(Math.random() * buffTypes.length)];
                applyBuff(randomBuff);
            }
        }
        
        // EMOTE SYSTEM
        function openEmoteMenu() {
            document.getElementById('emotePanel').style.display = 'block';
            
            const grid = document.getElementById('emoteGrid');
            grid.innerHTML = '';
            
            const emoteIcons = {
                wave: '👋', dance: '💃', cheer: '🎉', laugh: '😂',
                cry: '😢', angry: '😠', sleep: '😴', think: '🤔'
            };
            
            EMOTES.forEach(emote => {
                grid.innerHTML += `
                    <button class="action-btn" style="padding: 1rem; font-size: 2rem;" 
                            onclick="performEmote('${emote}')">
                        ${emoteIcons[emote]}
                    </button>
                `;
            });
        }
        
        function performEmote(emote) {
            currentPlayer.emote = emote;
            
            const emoteMessages = {
                wave: '👋 waves', dance: '💃 dances', cheer: '🎉 cheers',
                laugh: '😂 laughs', cry: '😢 cries', angry: '😠 is angry',
                sleep: '😴 is sleeping', think: '🤔 is thinking'
            };
            
            addChatMessage(currentPlayer.name, emoteMessages[emote], 'emote');
            
            // Show emote above player
            createParticle(currentPlayer.x, currentPlayer.y + 2, currentPlayer.z, 0xffffff, 
                          {wave: '👋', dance: '💃', cheer: '🎉', laugh: '😂', cry: '😢', 
                           angry: '😠', sleep: '😴', think: '🤔'}[emote]);
            
            setTimeout(() => {
                currentPlayer.emote = null;
            }, 3000);
            
            closeEmoteMenu();
        }
        
        function closeEmoteMenu() {
            document.getElementById('emotePanel').style.display = 'none';
        }
        
        // ACHIEVEMENT TRACKING
        function trackDistance() {
            const dist = Math.hypot(currentPlayer.x - lastPlayerPos.x, currentPlayer.z - lastPlayerPos.z);
            totalDistanceTraveled += dist;
            lastPlayerPos = { x: currentPlayer.x, z: currentPlayer.z };
            
            if (totalDistanceTraveled >= 1000) checkAchievement('explorer');
        }
        
        // ENHANCED GAME SAVING
        function saveGame() {
            // Save to localStorage as backup
            localStorage.setItem('fantasyquest_save', JSON.stringify({
                name: currentPlayer.name,
                level: currentPlayer.level,
                xp: currentPlayer.xp,
                gold: currentPlayer.gold,
                hp: currentPlayer.hp,
                mp: currentPlayer.mp,
                skills: currentPlayer.skills,
                stats: currentPlayer.stats,
                equipment: currentPlayer.equipment,
                inventory: currentPlayer.inventory,
                pet: currentPlayer.pet,
                achievements: currentPlayer.achievements,
                quests: currentPlayer.quests,
                craftedItems: currentPlayer.craftedItems,
                distanceTraveled: totalDistanceTraveled,
                chatCount: chatMessageCount
            }));
            
            // Also save to cloud if authenticated
            if (currentUser) {
                saveGameToCloud();
            }
        }
        
        function loadGame() {
            // This is now handled by the auth state listener
            // Keep for backward compatibility with non-auth mode
            const save = localStorage.getItem('fantasyquest_save');
            if (!save) return false;
            
            try {
                const data = JSON.parse(save);
                Object.assign(currentPlayer, data);
                totalDistanceTraveled = data.distanceTraveled || 0;
                chatMessageCount = data.chatCount || 0;
                if (data.pet) createPetMesh();
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Enhanced game loop
        const originalInterval = setInterval(() => {
            updatePet();
            updateWeather();
            updateBuffs();
            trackDistance();
            if (Math.random() < 0.01) saveGame(); // Auto-save (both local and cloud)
        }, 100);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            saveGame(); // Save both local and cloud
            if (currentPlayer.id && playersRef) {
                playersRef.child(currentPlayer.id).remove();
            }
        });
        
        // Initialize weather
        setTimeout(() => {
            if (scene) setWeather('clear');
        }, 2000);
    </script>
</body>
</html>
