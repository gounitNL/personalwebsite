<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>FantasyQuest 3D MMORPG - PlayZone v2.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: #ecf0f1;
            overflow: hidden;
        }

        #loginScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #loginScreen.hidden { display: none; }

        .login-box {
            background: white;
            padding: 3rem;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .login-box h1 {
            color: #667eea;
            margin-bottom: 1rem;
            font-size: 2rem;
        }

        .login-box p {
            color: #666;
            margin-bottom: 2rem;
        }

        .login-box input {
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1rem;
        }

        .login-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .login-box button {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s;
        }

        .login-box button:hover {
            transform: scale(1.05);
        }

        #gameContainer {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        #gameContainer.hidden { display: none; }

        /* Left Sidebar */
        #leftSidebar {
            width: 250px;
            background: rgba(44, 62, 80, 0.95);
            padding: 1rem;
            overflow-y: auto;
            border-right: 2px solid #34495e;
        }

        .character-panel {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .character-name {
            font-size: 1.2rem;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 0.5rem;
        }

        .stat-bar {
            margin-bottom: 0.5rem;
        }

        .stat-label {
            font-size: 0.9rem;
            margin-bottom: 0.2rem;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #34495e;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }

        .hp-bar { background: linear-gradient(90deg, #e74c3c, #c0392b); }
        .xp-bar { background: linear-gradient(90deg, #3498db, #2980b9); }

        .skills-panel {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .skill-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
        }

        .skill-name { font-weight: bold; }
        .skill-level { color: #f39c12; }

        /* Center Game Area */
        #gameArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        #gameHeader {
            background: rgba(44, 62, 80, 0.95);
            padding: 1rem 2rem;
            border-bottom: 2px solid #34495e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #gameTitle {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(90deg, #f39c12, #e67e22);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #onlineCount {
            font-size: 0.9rem;
            color: #2ecc71;
        }

        #renderCanvas {
            flex: 1;
            background: #87CEEB;
            display: block;
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 0.5rem 1rem;
            border-radius: 5px;
            font-size: 0.9rem;
            color: #ecf0f1;
            text-align: center;
        }

        .camera-controls {
            position: absolute;
            top: 70px;
            right: 330px;
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        /* Mini-map */
        .mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
        }

        /* Day/Night Indicator */
        .day-night-indicator {
            position: absolute;
            top: 70px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        /* Quest Panel */
        .quest-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.98);
            padding: 2rem;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1500;
            display: none;
        }

        .quest-panel.active { display: block; }

        .quest-item {
            background: rgba(52, 73, 94, 0.5);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            border-left: 4px solid #f39c12;
        }

        .close-panel-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: #e74c3c;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
        }

        /* Right Sidebar */
        #rightSidebar {
            width: 300px;
            background: rgba(44, 62, 80, 0.95);
            display: flex;
            flex-direction: column;
            border-left: 2px solid #34495e;
        }

        #chatArea {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.2);
        }

        .chat-message {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: rgba(52, 73, 94, 0.5);
            border-radius: 5px;
            font-size: 0.9rem;
        }

        .chat-player {
            color: #3498db;
            font-weight: bold;
        }

        .chat-system {
            color: #f39c12;
            font-style: italic;
        }

        #chatInput {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #34495e;
        }

        #chatInput input {
            flex: 1;
            padding: 0.5rem;
            border: 1px solid #34495e;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
        }

        #chatInput button {
            margin-left: 0.5rem;
            padding: 0.5rem 1rem;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #chatInput button:hover {
            background: #2980b9;
        }

        .action-buttons {
            padding: 1rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            border-top: 1px solid #34495e;
        }

        .action-btn {
            padding: 0.8rem;
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        .action-btn:hover {
            transform: scale(1.05);
        }

        .action-btn.gather {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .action-btn.craft {
            background: linear-gradient(135deg, #8e44ad, #71368a);
        }

        .action-btn.quest {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .inventory-panel {
            background: rgba(52, 73, 94, 0.8);
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
        }

        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .inventory-slot {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #34495e;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            position: relative;
        }

        .inventory-slot.has-item {
            border-color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        .item-count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        /* Mobile Virtual Controls */
        #mobileControls {
            display: none;
            position: absolute;
            bottom: 80px;
            left: 20px;
            z-index: 100;
        }

        .joystick-container {
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
        }

        #mobileActionButtons {
            display: none;
            position: absolute;
            bottom: 80px;
            right: 20px;
            z-index: 100;
            flex-direction: column;
            gap: 10px;
        }

        .mobile-action-btn {
            width: 60px;
            height: 60px;
            background: rgba(231, 76, 60, 0.8);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            touch-action: none;
        }

        .mobile-action-btn.gather {
            background: rgba(39, 174, 96, 0.8);
        }

        .toggle-sidebar-btn {
            display: none;
            position: absolute;
            top: 70px;
            background: rgba(44, 62, 80, 0.9);
            border: 2px solid #34495e;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            z-index: 150;
            font-size: 1.2rem;
        }

        #toggleLeft {
            left: 10px;
        }

        #toggleRight {
            right: 10px;
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 199;
        }

        @media (max-width: 1024px) {
            #leftSidebar { width: 220px; }
            #rightSidebar { width: 280px; }
            .login-box { padding: 2rem; }
        }

        @media (max-width: 768px) {
            #leftSidebar, #rightSidebar {
                position: fixed;
                top: 0;
                height: 100vh;
                z-index: 200;
                transition: transform 0.3s;
            }

            #leftSidebar {
                left: 0;
                transform: translateX(-100%);
                width: 250px;
            }

            #leftSidebar.open {
                transform: translateX(0);
            }

            #rightSidebar {
                right: 0;
                transform: translateX(100%);
                width: 280px;
            }

            #rightSidebar.open {
                transform: translateX(0);
            }

            .sidebar-overlay.active {
                display: block;
            }

            .toggle-sidebar-btn {
                display: block;
            }

            #mobileControls {
                display: block;
            }

            #mobileActionButtons {
                display: flex;
            }

            .controls-hint {
                display: none;
            }

            .camera-controls {
                display: none;
            }

            #gameHeader {
                padding: 0.75rem 1rem;
            }

            .action-buttons {
                display: none;
            }
        }

        @media (max-width: 480px) {
            #gameHeader { 
                padding: 0.5rem; 
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            #gameTitle { 
                font-size: 1rem; 
            }

            #onlineCount {
                font-size: 0.8rem;
            }

            .login-box {
                padding: 1.5rem;
                width: 95%;
            }

            .login-box h1 {
                font-size: 1.5rem;
            }

            #leftSidebar, #rightSidebar {
                width: 90vw;
                max-width: 300px;
            }

            .joystick-container {
                width: 100px;
                height: 100px;
            }

            .joystick-knob {
                width: 40px;
                height: 40px;
            }

            .mobile-action-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }

            #mobileControls {
                bottom: 60px;
                left: 15px;
            }

            #mobileActionButtons {
                bottom: 60px;
                right: 15px;
            }
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.5rem;
            z-index: 3000;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginScreen">
        <div class="login-box">
            <h1>‚öîÔ∏è FantasyQuest 3D MMORPG</h1>
            
            <!-- Tab Navigation -->
            <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                <button id="loginTab" class="auth-tab active" onclick="showLoginTab()" style="flex: 1; padding: 0.75rem; border: none; background: #667eea; color: white; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Login
                </button>
                <button id="signupTab" class="auth-tab" onclick="showSignupTab()" style="flex: 1; padding: 0.75rem; border: none; background: #ddd; color: #666; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Sign Up
                </button>
            </div>
            
            <!-- Login Form -->
            <div id="loginForm">
                <p style="color: #666; margin-bottom: 1rem;">Login to your account</p>
                <input type="email" id="loginEmail" placeholder="Email address" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="password" id="loginPassword" placeholder="Password" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <button onclick="loginWithEmail()" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; margin-bottom: 0.75rem;">
                    Login
                </button>
                <div style="text-align: center; margin: 1rem 0; color: #999;">or</div>
                <button onclick="loginWithGoogle()" style="width: 100%; padding: 1rem; background: white; color: #333; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                </button>
            </div>
            
            <!-- Signup Form -->
            <div id="signupForm" style="display: none;">
                <p style="color: #666; margin-bottom: 1rem;">Create a new account</p>
                <input type="text" id="signupCharacterName" placeholder="Character name" maxlength="20" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="email" id="signupEmail" placeholder="Email address" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="password" id="signupPassword" placeholder="Password (min 6 characters)" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <input type="password" id="signupPasswordConfirm" placeholder="Confirm password" style="width: 100%; padding: 1rem; margin-bottom: 0.75rem; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem;">
                <button onclick="signupWithEmail()" style="width: 100%; padding: 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 10px; font-size: 1.1rem; font-weight: bold; cursor: pointer; margin-bottom: 0.75rem;">
                    Create Account
                </button>
                <div style="text-align: center; margin: 1rem 0; color: #999;">or</div>
                <button onclick="loginWithGoogle()" style="width: 100%; padding: 1rem; background: white; color: #333; border: 2px solid #ddd; border-radius: 10px; font-size: 1rem; font-weight: bold; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                    <svg width="20" height="20" viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Sign up with Google
                </button>
            </div>
            
            <div id="authError" style="margin-top: 1rem; padding: 0.75rem; background: #fee; color: #c00; border-radius: 5px; display: none; font-size: 0.9rem;"></div>
            <div id="authSuccess" style="margin-top: 1rem; padding: 0.75rem; background: #efe; color: #060; border-radius: 5px; display: none; font-size: 0.9rem;"></div>
            
            <p style="margin-top: 1rem; font-size: 0.8rem; color: #999;">Play with other players in real-time 3D!</p>
        </div>
    </div>



    <!-- Game Container -->
    <div id="gameContainer" class="hidden">
        <!-- Sidebar Overlay -->
        <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebars()"></div>

        <!-- Toggle Buttons -->
        <button class="toggle-sidebar-btn" id="toggleLeft" onclick="toggleLeftSidebar()">üìä</button>
        <button class="toggle-sidebar-btn" id="toggleRight" onclick="toggleRightSidebar()">üí¨</button>

        <!-- Left Sidebar -->
        <div id="leftSidebar">
            <div class="character-panel">
                <div class="character-name" id="playerName">Adventurer</div>
                <div class="stat-bar">
                    <div class="stat-label">Level: <span id="combatLevel">1</span> | üí∞ <span id="goldCount">0</span></div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">HP</div>
                    <div class="progress-bar">
                        <div class="progress-fill hp-bar" id="hpBar" style="width: 100%">100/100</div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">MP</div>
                    <div class="progress-bar">
                        <div class="progress-fill" id="mpBar" style="width: 100%; background: linear-gradient(90deg, #3498db, #2980b9)">100/100</div>
                    </div>
                </div>
                <div class="stat-bar">
                    <div class="stat-label">XP</div>
                    <div class="progress-bar">
                        <div class="progress-fill xp-bar" id="xpBar" style="width: 0%">0/100</div>
                    </div>
                </div>
            </div>

            <div class="skills-panel">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">üìä Stats</h3>
                <div class="skill-item">
                    <span class="skill-name">‚öîÔ∏è Strength</span>
                    <span class="skill-level" id="strengthStat">10</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">üõ°Ô∏è Defense</span>
                    <span class="skill-level" id="defenseStat">10</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">‚ú® Magic</span>
                    <span class="skill-level" id="magicStat">10</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">‚ö° Speed</span>
                    <span class="skill-level" id="speedStat">10</span>
                </div>
            </div>

            <div class="skills-panel">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">‚öîÔ∏è Skills</h3>
                <div class="skill-item">
                    <span class="skill-name">Combat</span>
                    <span class="skill-level" id="combatSkill">1</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">Mining</span>
                    <span class="skill-level" id="miningSkill">1</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">Woodcutting</span>
                    <span class="skill-level" id="woodcuttingSkill">1</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">Fishing</span>
                    <span class="skill-level" id="fishingSkill">1</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">Crafting</span>
                    <span class="skill-level" id="craftingSkill">1</span>
                </div>
                <div class="skill-item">
                    <span class="skill-name">Magic</span>
                    <span class="skill-level" id="magicSkill">1</span>
                </div>
            </div>

            <div class="inventory-panel">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">üéí Equipment</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 1rem;">
                    <div style="background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 5px; text-align: center; font-size: 0.8rem;">
                        <div id="weaponSlot">üó°Ô∏è Weapon</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 5px; text-align: center; font-size: 0.8rem;">
                        <div id="armorSlot">üõ°Ô∏è Armor</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 5px; text-align: center; font-size: 0.8rem;">
                        <div id="helmetSlot">‚õëÔ∏è Helmet</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 5px; text-align: center; font-size: 0.8rem;">
                        <div id="bootsSlot">üë¢ Boots</div>
                    </div>
                </div>
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">üéí Inventory</h3>
                <div class="inventory-grid" id="inventoryGrid"></div>
            </div>

            <div class="skills-panel">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12;">üìú Quests (<span id="questCount">0</span>)</h3>
                <div id="questList" style="max-height: 150px; overflow-y: auto;"></div>
            </div>
        </div>

        <!-- Center Game Area -->
        <div id="gameArea">
            <div id="gameHeader">
                <div>
                    <div id="gameTitle">‚öîÔ∏è FantasyQuest 3D Online</div>
                    <a href="index.html" style="color: #95a5a6; text-decoration: none; font-size: 0.9rem;">‚Üê Back to Home</a>
                </div>
                <div style="display: flex; align-items: center; gap: 1rem;">
                    <div id="onlineCount">üü¢ 0 players online</div>
                    <button onclick="logoutUser()" style="padding: 0.5rem 1rem; background: #e74c3c; color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                        üö™ Logout
                    </button>
                </div>
            </div>
            <canvas id="renderCanvas"></canvas>
            <div class="controls-hint">WASD: Move ‚Ä¢ Mouse: Rotate Camera ‚Ä¢ Click: Interact<br>Q/E: Rotate Camera ‚Ä¢ Scroll: Zoom ‚Ä¢ 1/2/3: Abilities</div>
            <div class="camera-controls">
                Camera: Q/E to rotate ‚Ä¢ Mouse drag to look around
            </div>
            <div class="day-night-indicator">
                <span id="timeIcon">‚òÄÔ∏è</span>
                <span id="timeText">Day</span>
            </div>
            <canvas class="mini-map" id="miniMapCanvas" width="150" height="150"></canvas>
            
            <!-- Mobile Virtual Joystick -->
            <div id="mobileControls">
                <div class="joystick-container" id="joystickContainer">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>

            <!-- Mobile Action Buttons -->
            <div id="mobileActionButtons">
                <div class="mobile-action-btn" ontouchstart="attackNearestMonster()">‚öîÔ∏è</div>
                <div class="mobile-action-btn gather" ontouchstart="gatherResource()">‚õèÔ∏è</div>
            </div>
        </div>

        <!-- Right Sidebar -->
        <div id="rightSidebar">
            <div class="action-buttons">
                <button class="action-btn" onclick="attackNearestMonster()">‚öîÔ∏è Attack</button>
                <button class="action-btn gather" onclick="gatherResource()">‚õèÔ∏è Gather</button>
                <button class="action-btn craft" onclick="openCraftingPanel()">üî® Craft</button>
                <button class="action-btn quest" onclick="toggleQuestPanel()">üìú Quests</button>
                <button class="action-btn" onclick="openShop()">üè™ Shop</button>
                <button class="action-btn" onclick="openPetShop()">üêæ Pets</button>
                <button class="action-btn" style="background: linear-gradient(135deg, #e74c3c, #c0392b);" onclick="openEmoteMenu()">üòä Emote</button>
            </div>
            
            <div style="padding: 1rem; border-top: 1px solid #34495e; border-bottom: 1px solid #34495e;">
                <h3 style="margin-bottom: 0.5rem; color: #f39c12; font-size: 0.9rem;">‚ö° Abilities</h3>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                    <button class="action-btn" style="padding: 0.5rem; font-size: 0.8rem;" onclick="useAbility('fireball')" id="fireballBtn">
                        üî• Fireball<br><span style="font-size: 0.7rem;">20 MP</span>
                    </button>
                    <button class="action-btn craft" style="padding: 0.5rem; font-size: 0.8rem;" onclick="useAbility('heal')" id="healBtn">
                        üíö Heal<br><span style="font-size: 0.7rem;">15 MP</span>
                    </button>
                    <button class="action-btn" style="padding: 0.5rem; font-size: 0.8rem; background: linear-gradient(135deg, #9b59b6, #8e44ad);" onclick="useAbility('lightning')" id="lightningBtn">
                        ‚ö° Lightning<br><span style="font-size: 0.7rem;">35 MP</span>
                    </button>
                    <button class="action-btn quest" style="padding: 0.5rem; font-size: 0.8rem;" onclick="openAchievements()">
                        üèÜ Achievements
                    </button>
                </div>
            </div>
            
            <div id="chatArea"></div>
            
            <div id="chatInput">
                <input type="text" id="messageInput" placeholder="Type a message..." maxlength="200">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
    </div>

    <!-- Quest Panel -->
    <div class="quest-panel" id="questPanel">
        <button class="close-panel-btn" onclick="toggleQuestPanel()">√ó</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">üìú Available Quests</h2>
        <div id="availableQuests"></div>
        <h3 style="color: #2ecc71; margin-top: 1.5rem; margin-bottom: 0.5rem;">‚úÖ Active Quests</h3>
        <div id="activeQuestsPanel"></div>
    </div>

    <!-- Shop Panel -->
    <div class="quest-panel" id="shopPanel">
        <button class="close-panel-btn" onclick="closeShop()">√ó</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">üè™ Equipment Shop</h2>
        <div style="text-align: center; margin-bottom: 1rem; font-size: 1.2rem;">
            Your Gold: üí∞ <span id="shopGold">0</span>
        </div>
        <div id="shopItems"></div>
    </div>

    <!-- Achievements Panel -->
    <div class="quest-panel" id="achievementsPanel">
        <button class="close-panel-btn" onclick="closeAchievements()">√ó</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">üèÜ Achievements</h2>
        <div id="achievementsList"></div>
    </div>

    <!-- Crafting Panel -->
    <div class="quest-panel" id="craftingPanel">
        <button class="close-panel-btn" onclick="closeCraftingPanel()">√ó</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">üî® Crafting Station</h2>
        <div style="text-align: center; margin-bottom: 1rem;">
            <span style="color: #3498db;">Crafting Level: <span id="craftingLevel">1</span></span>
        </div>
        <div id="craftingRecipes"></div>
    </div>

    <!-- Pet Shop Panel -->
    <div class="quest-panel" id="petShopPanel">
        <button class="close-panel-btn" onclick="closePetShop()">√ó</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">üêæ Pet Shop</h2>
        <div style="text-align: center; margin-bottom: 1rem; font-size: 1.2rem;">
            Your Gold: üí∞ <span id="petShopGold">0</span>
        </div>
        <div id="currentPet" style="margin-bottom: 1rem; padding: 1rem; background: rgba(46, 204, 113, 0.2); border-radius: 10px; text-align: center;">
            Current Pet: <span id="activePet">None</span>
        </div>
        <div id="petShopItems"></div>
    </div>

    <!-- Emote Menu -->
    <div class="quest-panel" id="emotePanel" style="max-width: 400px;">
        <button class="close-panel-btn" onclick="closeEmoteMenu()">√ó</button>
        <h2 style="color: #f39c12; margin-bottom: 1rem;">üòä Emotes</h2>
        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem;" id="emoteGrid"></div>
    </div>

    <!-- Weather Indicator -->
    <div id="weatherIndicator" style="position: fixed; top: 120px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.5); padding: 0.5rem 1rem; border-radius: 20px; display: flex; align-items: center; gap: 0.5rem; z-index: 100;">
        <span id="weatherIcon">‚òÄÔ∏è</span>
        <span id="weatherText">Clear</span>
    </div>

    <!-- Active Buffs Display -->
    <div id="buffsContainer" style="position: fixed; top: 170px; left: 50%; transform: translateX(-50%); display: flex; gap: 0.5rem; z-index: 100;"></div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
    
    <script>
        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCqMqav_HFKid6XdmbnfhG5llgCMZoYQV0",
            authDomain: "fantasyquest-mmorpg.firebaseapp.com",
            databaseURL: "https://fantasyquest-mmorpg-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "fantasyquest-mmorpg",
            storageBucket: "fantasyquest-mmorpg.firebasestorage.app",
            messagingSenderId: "149888279159",
            appId: "1:149888279159:web:48a53797f0c57f3a671c72"
        };

        // Global variables for Firebase (declared early)
        var database = null;
        var auth = null;

        // Initialize Firebase when ready
        function initFirebase() {
            try {
                if (typeof firebase === 'undefined') {
                    console.error('Firebase SDK not loaded yet!');
                    setTimeout(initFirebase, 100); // Retry after 100ms
                    return;
                }
                
                firebase.initializeApp(firebaseConfig);
                database = firebase.database();
                auth = firebase.auth();
                console.log('Firebase initialized successfully!');
                
                // Setup auth state listener after initialization
                setupAuthListener();
            } catch (error) {
                console.error('Firebase initialization error:', error);
                alert('Failed to connect to Firebase. Please refresh the page.');
            }
        }

        // Call initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initFirebase);
        } else {
            initFirebase();
        }
        
        // ========== FIREBASE AUTHENTICATION SYSTEM ==========
        
        let currentUser = null; // Firebase user object
        let userProfileRef = null; // Database reference for user profile

        // Three.js variables
        let scene, camera, renderer, canvas;
        let playerMesh, playerMeshes = {};
        let monsterMeshes = [];
        let resourceMeshes = [];
        let groundMesh;
        let raycaster, mouse;
        let cameraAngle = Math.PI / 4; // 45 degrees
        let cameraDistance = 25;
        let cameraHeight = 15;
        let isMouseDown = false;
        let mouseStartX = 0;

        // Game State
        let currentPlayer = {
            id: null,
            name: '',
            x: 0,
            y: 0,
            z: 0,
            rotation: 0,
            moving: false,
            hp: 100,
            maxHp: 100,
            mp: 100, // NEW: Magic points
            maxMp: 100,
            xp: 0,
            level: 1,
            gold: 0, // NEW: Currency
            skills: {
                combat: 1,
                mining: 1,
                woodcutting: 1,
                fishing: 1,
                crafting: 1,
                magic: 1 // NEW: Magic skill
            },
            stats: { // NEW: Character stats
                strength: 10,
                defense: 10,
                magic: 10,
                speed: 10
            },
            equipment: { // NEW: Equipment slots
                weapon: null,
                armor: null,
                helmet: null,
                boots: null
            },
            inventory: {},
            quests: { // NEW: Quest tracking
                active: [],
                completed: []
            },
            achievements: [], // NEW: Achievements
            abilities: { // NEW: Combat abilities
                fireball: { cooldown: 0, maxCooldown: 5000, damage: 25, mpCost: 20 },
                heal: { cooldown: 0, maxCooldown: 8000, healing: 30, mpCost: 15 },
                lightning: { cooldown: 0, maxCooldown: 10000, damage: 50, mpCost: 35 }
            },
            pet: null, // NEW: Pet companion
            buffs: [], // NEW: Active buffs
            emote: null, // NEW: Current emote
            craftedItems: 0 // NEW: Crafting counter
        };

        let players = {};
        let monsters = [];
        let resources = [];
        let npcs = []; // NEW: NPCs
        let lootItems = []; // NEW: Dropped loot
        let particles = []; // NEW: Visual effects
        let playersRef, chatRef;
        let keys = {};
        
        // Mobile controls
        let joystickActive = false;
        let joystickDirection = { x: 0, y: 0 };
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // NEW CREATIVE FEATURES
        let playerPet = null; // Pet companion
        let petMesh = null;
        let currentWeather = 'clear'; // Weather system
        let weatherParticles = [];
        let activeBuffs = []; // Buff/debuff system
        let bossMonsters = []; // Special boss spawns
        let chatMessageCount = 0; // For achievements
        let totalDistanceTraveled = 0; // For achievements
        let lastPlayerPos = { x: 0, z: 0 };

        // Constants
        const PLAYER_SPEED = 0.15;
        const MAP_SIZE = 50;
        
        // NEW: Equipment Database
        const EQUIPMENT = {
            weapons: {
                'Wooden Sword': { damage: 5, value: 10, level: 1 },
                'Iron Sword': { damage: 10, value: 50, level: 5 },
                'Steel Sword': { damage: 20, value: 150, level: 10 },
                'Dragon Sword': { damage: 40, value: 500, level: 20 },
                'Magic Staff': { damage: 15, magic: 25, value: 200, level: 10 }
            },
            armor: {
                'Leather Armor': { defense: 5, value: 15, level: 1 },
                'Iron Armor': { defense: 15, value: 80, level: 5 },
                'Steel Armor': { defense: 30, value: 250, level: 10 },
                'Dragon Armor': { defense: 60, value: 800, level: 20 }
            },
            helmets: {
                'Leather Cap': { defense: 2, value: 8, level: 1 },
                'Iron Helmet': { defense: 8, value: 40, level: 5 },
                'Steel Helmet': { defense: 15, value: 120, level: 10 }
            },
            boots: {
                'Leather Boots': { speed: 2, value: 10, level: 1 },
                'Iron Boots': { defense: 5, speed: 3, value: 50, level: 5 },
                'Dragon Boots': { defense: 10, speed: 5, value: 200, level: 10 }
            }
        };
        
        // NEW: Quest Database
        const QUESTS = [
            { 
                id: 'tutorial_combat',
                name: 'First Blood',
                description: 'Defeat 3 monsters',
                objective: { type: 'kill', target: 'any', count: 3 },
                reward: { xp: 100, gold: 50, item: 'Iron Sword' },
                level: 1
            },
            {
                id: 'resource_gather',
                name: 'Resource Collector',
                description: 'Gather 10 resources',
                objective: { type: 'gather', count: 10 },
                reward: { xp: 150, gold: 75 },
                level: 1
            },
            {
                id: 'dragon_slayer',
                name: 'Dragon Slayer',
                description: 'Defeat the mighty Dragon',
                objective: { type: 'kill', target: 'Dragon', count: 1 },
                reward: { xp: 1000, gold: 500, item: 'Dragon Sword' },
                level: 15
            },
            {
                id: 'skill_master',
                name: 'Skill Master',
                description: 'Reach level 10 in any skill',
                objective: { type: 'skill', level: 10 },
                reward: { xp: 500, gold: 250 },
                level: 5
            }
        ];
        
        // NEW: Achievement Database
        const ACHIEVEMENTS = [
            { id: 'first_kill', name: 'First Blood', description: 'Defeat your first monster', icon: '‚öîÔ∏è' },
            { id: 'level_10', name: 'Veteran', description: 'Reach level 10', icon: 'üéñÔ∏è' },
            { id: 'rich', name: 'Wealthy', description: 'Collect 1000 gold', icon: 'üí∞' },
            { id: 'master_gatherer', name: 'Master Gatherer', description: 'Gather 100 resources', icon: 'üå≤' },
            { id: 'dragon_slayer', name: 'Dragon Slayer', description: 'Defeat a Dragon', icon: 'üêâ' },
            { id: 'social', name: 'Social Butterfly', description: 'Chat 50 messages', icon: 'üí¨' },
            { id: 'explorer', name: 'Explorer', description: 'Travel 1000 units', icon: 'üó∫Ô∏è' }
        ];
        
        // NEW: Pet Database
        const PETS = {
            'Wolf Pup': { damage: 5, icon: 'üê∫', cost: 100, level: 1, description: 'A loyal wolf companion' },
            'Fire Spirit': { damage: 10, icon: 'üî•', cost: 300, level: 5, description: 'A magical fire elemental' },
            'Ice Dragon': { damage: 20, icon: 'üêâ', cost: 1000, level: 15, description: 'A powerful dragon ally' },
            'Phoenix': { damage: 15, healing: 5, icon: 'ü¶Ö', cost: 800, level: 12, description: 'Heals you in battle' }
        };
        
        // NEW: Crafting Recipes
        const CRAFTING_RECIPES = {
            'Wooden Sword': { materials: { Wood: 5 }, level: 1, craftingXP: 20 },
            'Leather Armor': { materials: { 'Fish': 10 }, level: 1, craftingXP: 25 },
            'Health Potion': { materials: { 'Fish': 3, 'Wood': 2 }, level: 1, craftingXP: 15 },
            'Mana Potion': { materials: { 'Ore': 3, 'Wood': 2 }, level: 3, craftingXP: 20 },
            'Iron Sword': { materials: { 'Ore': 10, 'Wood': 5 }, level: 5, craftingXP: 50 },
            'Steel Armor': { materials: { 'Ore': 20, 'Wood': 10 }, level: 10, craftingXP: 100 }
        };
        
        // NEW: Buff Database
        const BUFFS = {
            'strength': { name: 'Strength Boost', icon: 'üí™', duration: 30000, effect: { strength: 5 } },
            'defense': { name: 'Iron Skin', icon: 'üõ°Ô∏è', duration: 30000, effect: { defense: 5 } },
            'speed': { name: 'Swift Feet', icon: '‚ö°', duration: 20000, effect: { speed: 5 } },
            'regen': { name: 'Regeneration', icon: 'üíö', duration: 60000, effect: { hpRegen: 1 } },
            'wisdom': { name: 'Arcane Wisdom', icon: 'üîÆ', duration: 30000, effect: { magic: 10 } }
        };
        
        // NEW: Emotes
        const EMOTES = ['wave', 'dance', 'cheer', 'laugh', 'cry', 'angry', 'sleep', 'think'];
        
        // NEW: Weather types
        const WEATHER_TYPES = ['clear', 'rain', 'snow', 'fog', 'storm'];
        
        // NEW: Day/Night cycle
        let timeOfDay = 0; // 0-24 hours
        let dayNightSpeed = 0.01; // How fast time passes

        // Login
        // ========== AUTHENTICATION UI FUNCTIONS ==========
        
        function showLoginTab() {
            document.getElementById('loginTab').classList.add('active');
            document.getElementById('loginTab').style.background = '#667eea';
            document.getElementById('loginTab').style.color = 'white';
            document.getElementById('signupTab').classList.remove('active');
            document.getElementById('signupTab').style.background = '#ddd';
            document.getElementById('signupTab').style.color = '#666';
            document.getElementById('loginForm').style.display = 'block';
            document.getElementById('signupForm').style.display = 'none';
            hideAuthMessages();
        }
        
        function showSignupTab() {
            document.getElementById('signupTab').classList.add('active');
            document.getElementById('signupTab').style.background = '#667eea';
            document.getElementById('signupTab').style.color = 'white';
            document.getElementById('loginTab').classList.remove('active');
            document.getElementById('loginTab').style.background = '#ddd';
            document.getElementById('loginTab').style.color = '#666';
            document.getElementById('loginForm').style.display = 'none';
            document.getElementById('signupForm').style.display = 'block';
            hideAuthMessages();
        }
        
        function showAuthError(message) {
            const errorDiv = document.getElementById('authError');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            document.getElementById('authSuccess').style.display = 'none';
        }
        
        function showAuthSuccess(message) {
            const successDiv = document.getElementById('authSuccess');
            successDiv.textContent = message;
            successDiv.style.display = 'block';
            document.getElementById('authError').style.display = 'none';
        }
        
        function hideAuthMessages() {
            document.getElementById('authError').style.display = 'none';
            document.getElementById('authSuccess').style.display = 'none';
        }
        
        // ========== FIREBASE AUTHENTICATION FUNCTIONS ==========
        
        // Login with Email/Password
        async function loginWithEmail() {
            // Check if Firebase is initialized
            if (!auth || !database) {
                showAuthError('Firebase not initialized yet. Please wait a moment and try again.');
                return;
            }
            
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!email || !password) {
                showAuthError('Please enter both email and password');
                return;
            }
            
            try {
                showAuthSuccess('Logging in...');
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                // Auth state listener will handle the rest
            } catch (error) {
                console.error('Login error:', error);
                let errorMessage = 'Login failed: ';
                switch (error.code) {
                    case 'auth/user-not-found':
                        errorMessage += 'No account found with this email';
                        break;
                    case 'auth/wrong-password':
                        errorMessage += 'Incorrect password';
                        break;
                    case 'auth/invalid-email':
                        errorMessage += 'Invalid email address';
                        break;
                    case 'auth/user-disabled':
                        errorMessage += 'This account has been disabled';
                        break;
                    default:
                        errorMessage += error.message;
                }
                showAuthError(errorMessage);
            }
        }
        
        // Sign up with Email/Password
        async function signupWithEmail() {
            // Check if Firebase is initialized
            if (!auth || !database) {
                showAuthError('Firebase not initialized yet. Please wait a moment and try again.');
                return;
            }
            
            const characterName = document.getElementById('signupCharacterName').value.trim();
            const email = document.getElementById('signupEmail').value.trim();
            const password = document.getElementById('signupPassword').value;
            const passwordConfirm = document.getElementById('signupPasswordConfirm').value;
            
            // Validation
            if (!characterName || characterName.length < 3) {
                showAuthError('Character name must be at least 3 characters');
                return;
            }
            
            if (!email) {
                showAuthError('Please enter your email address');
                return;
            }
            
            if (password.length < 6) {
                showAuthError('Password must be at least 6 characters');
                return;
            }
            
            if (password !== passwordConfirm) {
                showAuthError('Passwords do not match');
                return;
            }
            
            try {
                showAuthSuccess('Creating account...');
                
                // Create Firebase account
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                const user = userCredential.user;
                
                // Create initial profile in database
                await database.ref('user_profiles/' + user.uid).set({
                    name: characterName,
                    email: email,
                    level: 1,
                    gold: 0,
                    xp: 0,
                    hp: 100,
                    maxHp: 100,
                    mp: 100,
                    maxMp: 100,
                    skills: {
                        combat: 1,
                        mining: 1,
                        woodcutting: 1,
                        fishing: 1,
                        crafting: 1,
                        magic: 1
                    },
                    stats: {
                        strength: 10,
                        defense: 10,
                        magic: 10,
                        speed: 10
                    },
                    equipment: {
                        weapon: null,
                        armor: null,
                        helmet: null,
                        boots: null
                    },
                    inventory: {},
                    pet: null,
                    achievements: [],
                    quests: {
                        active: [],
                        completed: []
                    },
                    craftedItems: 0,
                    createdAt: Date.now()
                });
                
                showAuthSuccess('Account created! Logging in...');
                // Auth state listener will handle the rest
                
            } catch (error) {
                console.error('Signup error:', error);
                let errorMessage = 'Signup failed: ';
                switch (error.code) {
                    case 'auth/email-already-in-use':
                        errorMessage += 'This email is already registered';
                        break;
                    case 'auth/invalid-email':
                        errorMessage += 'Invalid email address';
                        break;
                    case 'auth/weak-password':
                        errorMessage += 'Password is too weak';
                        break;
                    default:
                        errorMessage += error.message;
                }
                showAuthError(errorMessage);
            }
        }
        
        // Login with Google
        async function loginWithGoogle() {
            // Check if Firebase is initialized
            if (!auth || !database) {
                showAuthError('Firebase not initialized yet. Please wait a moment and try again.');
                return;
            }
            
            try {
                showAuthSuccess('Opening Google sign-in...');
                const provider = new firebase.auth.GoogleAuthProvider();
                const result = await auth.signInWithPopup(provider);
                
                // Check if this is a new user
                const user = result.user;
                const profileSnapshot = await database.ref('user_profiles/' + user.uid).once('value');
                
                if (!profileSnapshot.exists()) {
                    // New Google user - create profile
                    const characterName = user.displayName || 'Hero';
                    await database.ref('user_profiles/' + user.uid).set({
                        name: characterName,
                        email: user.email,
                        level: 1,
                        gold: 0,
                        xp: 0,
                        hp: 100,
                        maxHp: 100,
                        mp: 100,
                        maxMp: 100,
                        skills: {
                            combat: 1,
                            mining: 1,
                            woodcutting: 1,
                            fishing: 1,
                            crafting: 1,
                            magic: 1
                        },
                        stats: {
                            strength: 10,
                            defense: 10,
                            magic: 10,
                            speed: 10
                        },
                        equipment: {
                            weapon: null,
                            armor: null,
                            helmet: null,
                            boots: null
                        },
                        inventory: {},
                        pet: null,
                        achievements: [],
                        quests: {
                            active: [],
                            completed: []
                        },
                        craftedItems: 0,
                        createdAt: Date.now()
                    });
                }
                
                // Auth state listener will handle the rest
                
            } catch (error) {
                console.error('Google login error:', error);
                if (error.code !== 'auth/popup-closed-by-user') {
                    showAuthError('Google sign-in failed: ' + error.message);
                }
            }
        }
        
        // Logout
        async function logoutUser() {
            try {
                // Save game before logout
                await saveGameToCloud();
                
                // Remove player from online players
                if (currentPlayer.id && playersRef) {
                    await playersRef.child(currentPlayer.id).remove();
                }
                
                // Sign out
                await auth.signOut();
                
                // Reload page
                window.location.reload();
                
            } catch (error) {
                console.error('Logout error:', error);
                addChatMessage('System', 'Logout failed: ' + error.message, 'system');
            }
        }
        
        // ========== AUTH STATE LISTENER ==========
        
        function setupAuthListener() {
            if (!auth) {
                console.error('Auth not initialized yet!');
                return;
            }
            
            auth.onAuthStateChanged(async (user) => {
            if (user) {
                // User is logged in
                currentUser = user;
                console.log('User authenticated:', user.email);
                
                try {
                    // Load user profile from Firebase
                    const profileSnapshot = await database.ref('user_profiles/' + user.uid).once('value');
                    const profileData = profileSnapshot.val();
                    
                    if (profileData) {
                        // Load saved data into currentPlayer
                        currentPlayer.name = profileData.name;
                        currentPlayer.id = user.uid;
                        currentPlayer.level = profileData.level || 1;
                        currentPlayer.gold = profileData.gold || 0;
                        currentPlayer.xp = profileData.xp || 0;
                        currentPlayer.hp = profileData.hp || 100;
                        currentPlayer.maxHp = profileData.maxHp || 100;
                        currentPlayer.mp = profileData.mp || 100;
                        currentPlayer.maxMp = profileData.maxMp || 100;
                        currentPlayer.skills = profileData.skills || currentPlayer.skills;
                        currentPlayer.stats = profileData.stats || currentPlayer.stats;
                        currentPlayer.equipment = profileData.equipment || {};
                        currentPlayer.inventory = profileData.inventory || {};
                        currentPlayer.pet = profileData.pet || null;
                        currentPlayer.achievements = profileData.achievements || [];
                        currentPlayer.quests = profileData.quests || { active: [], completed: [] };
                        currentPlayer.craftedItems = profileData.craftedItems || 0;
                        
                        // Set up profile reference for auto-save
                        userProfileRef = database.ref('user_profiles/' + user.uid);
                        
                        // Hide login screen, show game
                        document.getElementById('loginScreen').classList.add('hidden');
                        document.getElementById('gameContainer').classList.remove('hidden');
                        
                        // Initialize game
                        initGame();
                        
                        // Start auto-save interval
                        setInterval(saveGameToCloud, 30000); // Save every 30 seconds
                        
                        console.log('Profile loaded successfully');
                    }
                    
                } catch (error) {
                    console.error('Error loading profile:', error);
                    showAuthError('Failed to load profile: ' + error.message);
                }
                
            } else {
                // User is logged out
                currentUser = null;
                console.log('No user authenticated');
                
                // Show login screen
                document.getElementById('loginScreen').classList.remove('hidden');
                document.getElementById('gameContainer').classList.add('hidden');
            }
            });
        }
        
        // ========== CLOUD SAVE FUNCTIONS ==========
        
        async function saveGameToCloud() {
            if (!currentUser || !userProfileRef) return;
            
            try {
                await userProfileRef.update({
                    name: currentPlayer.name,
                    level: currentPlayer.level,
                    gold: currentPlayer.gold,
                    xp: currentPlayer.xp,
                    hp: currentPlayer.hp,
                    maxHp: currentPlayer.maxHp,
                    mp: currentPlayer.mp,
                    maxMp: currentPlayer.maxMp,
                    skills: currentPlayer.skills,
                    stats: currentPlayer.stats,
                    equipment: currentPlayer.equipment,
                    inventory: currentPlayer.inventory,
                    pet: currentPlayer.pet,
                    achievements: currentPlayer.achievements,
                    quests: currentPlayer.quests,
                    craftedItems: currentPlayer.craftedItems,
                    lastSaved: Date.now()
                });
                
                console.log('Game saved to cloud');
                
            } catch (error) {
                console.error('Cloud save error:', error);
            }
        }

        // Initialize 3D Game
        function initGame() {
            canvas = document.getElementById('renderCanvas');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 30, 80);

            // Camera setup (isometric-like view)
            camera = new THREE.PerspectiveCamera(60, canvas.offsetWidth / canvas.offsetHeight, 0.1, 1000);
            updateCameraPosition();

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 40, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Create terrain
            createTerrain();

            // Create player
            createPlayer();

            // Raycaster for clicking
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Update UI
            document.getElementById('playerName').textContent = currentPlayer.name;
            updateStats();
            renderInventory();

            // Firebase references
            playersRef = database.ref('players');
            chatRef = database.ref('chat');

            // Add player to database
            const playerRef = playersRef.child(currentPlayer.id);
            playerRef.set({
                name: currentPlayer.name,
                x: currentPlayer.x,
                y: currentPlayer.y,
                z: currentPlayer.z,
                rotation: currentPlayer.rotation,
                level: currentPlayer.level,
                lastActive: Date.now()
            });

            // Remove player on disconnect
            playerRef.onDisconnect().remove();

            // Listen for other players
            playersRef.on('value', (snapshot) => {
                players = {};
                let onlineCount = 0;
                snapshot.forEach((child) => {
                    const player = child.val();
                    if (child.key !== currentPlayer.id) {
                        players[child.key] = player;
                        updatePlayerMesh(child.key, player);
                    }
                    onlineCount++;
                });
                document.getElementById('onlineCount').textContent = `üü¢ ${onlineCount} players online`;
                
                // Remove disconnected players
                Object.keys(playerMeshes).forEach(id => {
                    if (!players[id] && id !== currentPlayer.id) {
                        scene.remove(playerMeshes[id]);
                        delete playerMeshes[id];
                    }
                });
            });

            // Listen for chat messages
            chatRef.limitToLast(20).on('child_added', (snapshot) => {
                const msg = snapshot.val();
                addChatMessage(msg.player, msg.message, msg.type || 'player');
            });

            // Initialize game entities
            initMonsters();
            initResources();

            // Controls
            window.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault();
                }
            });

            window.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            canvas.addEventListener('click', handleCanvasClick);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            
            document.getElementById('messageInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendMessage();
            });

            // Initialize mobile controls
            initMobileControls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);

            // Game loop
            animate();
            setInterval(updatePlayerPosition, 100);

            // Add system message
            addChatMessage('System', `${currentPlayer.name} joined the 3D adventure!`, 'system');
        }

        function createTerrain() {
            // Create ground plane with texture-like appearance
            const groundGeometry = new THREE.PlaneGeometry(MAP_SIZE * 2, MAP_SIZE * 2, MAP_SIZE, MAP_SIZE);
            
            // Add variation to terrain height
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] = Math.random() * 0.5; // Random height variation
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x3a7d44,
                roughness: 0.8,
                metalness: 0.2
            });
            
            groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            scene.add(groundMesh);

            // Add some water patches
            for (let i = 0; i < 5; i++) {
                const waterGeometry = new THREE.CircleGeometry(3 + Math.random() * 2, 32);
                const waterMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x1e90ff,
                    roughness: 0.1,
                    metalness: 0.5
                });
                const water = new THREE.Mesh(waterGeometry, waterMaterial);
                water.rotation.x = -Math.PI / 2;
                water.position.x = (Math.random() - 0.5) * MAP_SIZE;
                water.position.z = (Math.random() - 0.5) * MAP_SIZE;
                water.position.y = 0.05;
                water.receiveShadow = true;
                scene.add(water);
            }

            // Add some dirt paths
            for (let i = 0; i < 8; i++) {
                const pathGeometry = new THREE.PlaneGeometry(2, 5);
                const pathMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.9
                });
                const path = new THREE.Mesh(pathGeometry, pathMaterial);
                path.rotation.x = -Math.PI / 2;
                path.position.x = (Math.random() - 0.5) * MAP_SIZE;
                path.position.z = (Math.random() - 0.5) * MAP_SIZE;
                path.position.y = 0.02;
                path.receiveShadow = true;
                scene.add(path);
            }
        }

        function createPlayer() {
            // Create player character (RuneScape-style blocky)
            const playerGroup = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.8;
            body.castShadow = true;
            playerGroup.add(body);

            // Head
            const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.65;
            head.castShadow = true;
            playerGroup.add(head);

            // Arms
            const armGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x3498db });
            
            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.castShadow = true;
            playerGroup.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.castShadow = true;
            playerGroup.add(rightArm);

            // Legs
            const legGeometry = new THREE.BoxGeometry(0.25, 0.6, 0.3);
            const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            
            const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
            leftLeg.position.set(-0.2, 0.3, 0);
            leftLeg.castShadow = true;
            playerGroup.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
            rightLeg.position.set(0.2, 0.3, 0);
            rightLeg.castShadow = true;
            playerGroup.add(rightLeg);

            playerGroup.position.set(currentPlayer.x, currentPlayer.y, currentPlayer.z);
            playerMesh = playerGroup;
            scene.add(playerMesh);

            // Add name label
            createNameLabel(playerGroup, currentPlayer.name, 0xf39c12);
        }

        function createNameLabel(parentMesh, name, color) {
            // Create canvas for name
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.7)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.font = 'Bold 32px Arial';
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.textAlign = 'center';
            context.fillText(name, 128, 42);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.y = 2.5;
            sprite.scale.set(2, 0.5, 1);
            parentMesh.add(sprite);
        }

        function updatePlayerMesh(playerId, playerData) {
            if (!playerMeshes[playerId]) {
                // Create new player mesh
                const playerGroup = new THREE.Group();

                // Body
                const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.4);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                body.castShadow = true;
                playerGroup.add(body);

                // Head
                const headGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.65;
                head.castShadow = true;
                playerGroup.add(head);

                // Arms
                const armGeometry = new THREE.BoxGeometry(0.3, 0.8, 0.3);
                const armMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c });
                
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.5, 0.8, 0);
                leftArm.castShadow = true;
                playerGroup.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.5, 0.8, 0);
                rightArm.castShadow = true;
                playerGroup.add(rightArm);

                // Legs
                const legGeometry = new THREE.BoxGeometry(0.25, 0.6, 0.3);
                const legMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
                
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.2, 0.3, 0);
                leftLeg.castShadow = true;
                playerGroup.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.2, 0.3, 0);
                rightLeg.castShadow = true;
                playerGroup.add(rightLeg);

                createNameLabel(playerGroup, playerData.name, 0x3498db);
                
                playerMeshes[playerId] = playerGroup;
                scene.add(playerGroup);
            }

            // Update position
            playerMeshes[playerId].position.set(playerData.x, playerData.y, playerData.z);
            playerMeshes[playerId].rotation.y = playerData.rotation || 0;
        }

        function initMonsters() {
            const monsterTypes = [
                { name: 'Goblin', color: 0x8B4513, hp: 30, xp: 20, level: 1, scale: 0.8 },
                { name: 'Skeleton', color: 0xD3D3D3, hp: 50, xp: 35, level: 2, scale: 0.9 },
                { name: 'Orc', color: 0x556B2F, hp: 80, xp: 50, level: 3, scale: 1.0 },
                { name: 'Dragon', color: 0x8B0000, hp: 200, xp: 150, level: 5, scale: 1.5 }
            ];

            for (let i = 0; i < 15; i++) {
                const type = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
                const monster = {
                    id: 'monster_' + i,
                    ...type,
                    x: (Math.random() - 0.5) * MAP_SIZE,
                    y: 0,
                    z: (Math.random() - 0.5) * MAP_SIZE,
                    currentHp: type.hp,
                    maxHp: type.hp,
                    direction: Math.random() * Math.PI * 2,
                    speed: 0.02
                };
                monsters.push(monster);
                
                // Create 3D monster
                const monsterGroup = new THREE.Group();
                
                // Body
                const bodyGeometry = new THREE.BoxGeometry(0.6 * type.scale, 1.0 * type.scale, 0.6 * type.scale);
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: type.color });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.5 * type.scale;
                body.castShadow = true;
                monsterGroup.add(body);

                // Head
                const headGeometry = new THREE.BoxGeometry(0.4 * type.scale, 0.4 * type.scale, 0.4 * type.scale);
                const headMaterial = new THREE.MeshStandardMaterial({ color: type.color });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.2 * type.scale;
                head.castShadow = true;
                monsterGroup.add(head);

                // Eyes (red)
                const eyeGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.05);
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000 });
                
                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1 * type.scale, 1.25 * type.scale, 0.2 * type.scale);
                monsterGroup.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1 * type.scale, 1.25 * type.scale, 0.2 * type.scale);
                monsterGroup.add(rightEye);

                monsterGroup.position.set(monster.x, monster.y, monster.z);
                monsterGroup.userData = monster;
                monsterMeshes.push(monsterGroup);
                scene.add(monsterGroup);

                createNameLabel(monsterGroup, `${type.name} Lv.${type.level}`, 0xff0000);
            }
        }

        function initResources() {
            const resourceTypes = [
                { name: 'Tree', color: 0x228B22, skill: 'woodcutting', item: 'Wood', height: 3 },
                { name: 'Rock', color: 0x696969, skill: 'mining', item: 'Ore', height: 1.5 },
                { name: 'Fish Spot', color: 0x4169E1, skill: 'fishing', item: 'Fish', height: 0.3 }
            ];

            for (let i = 0; i < 25; i++) {
                const type = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                const resource = {
                    id: 'resource_' + i,
                    ...type,
                    x: (Math.random() - 0.5) * MAP_SIZE,
                    y: 0,
                    z: (Math.random() - 0.5) * MAP_SIZE,
                    available: true
                };
                resources.push(resource);

                // Create 3D resource
                let resourceMesh;
                
                if (type.name === 'Tree') {
                    const treeGroup = new THREE.Group();
                    
                    // Trunk
                    const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1.5, 8);
                    const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                    trunk.position.y = 0.75;
                    trunk.castShadow = true;
                    treeGroup.add(trunk);

                    // Leaves
                    const leavesGeometry = new THREE.SphereGeometry(1, 8, 8);
                    const leavesMaterial = new THREE.MeshStandardMaterial({ color: type.color });
                    const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                    leaves.position.y = 2.5;
                    leaves.castShadow = true;
                    treeGroup.add(leaves);

                    resourceMesh = treeGroup;
                } else if (type.name === 'Rock') {
                    const rockGeometry = new THREE.DodecahedronGeometry(0.8, 0);
                    const rockMaterial = new THREE.MeshStandardMaterial({ color: type.color, roughness: 0.9 });
                    resourceMesh = new THREE.Mesh(rockGeometry, rockMaterial);
                    resourceMesh.position.y = 0.5;
                    resourceMesh.castShadow = true;
                } else { // Fish Spot
                    const waterGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.2, 16);
                    const waterMaterial = new THREE.MeshStandardMaterial({ 
                        color: type.color, 
                        transparent: true, 
                        opacity: 0.7,
                        roughness: 0.1
                    });
                    resourceMesh = new THREE.Mesh(waterGeometry, waterMaterial);
                    resourceMesh.position.y = 0.1;
                    resourceMesh.receiveShadow = true;
                }

                resourceMesh.position.x = resource.x;
                resourceMesh.position.z = resource.z;
                resourceMesh.userData = resource;
                resourceMeshes.push(resourceMesh);
                scene.add(resourceMesh);
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // Handle movement
            let moved = false;
            const moveSpeed = PLAYER_SPEED;

            // Keyboard controls
            if (keys['w']) {
                currentPlayer.x += Math.sin(cameraAngle) * moveSpeed;
                currentPlayer.z += Math.cos(cameraAngle) * moveSpeed;
                currentPlayer.rotation = cameraAngle;
                moved = true;
            }
            if (keys['s']) {
                currentPlayer.x -= Math.sin(cameraAngle) * moveSpeed;
                currentPlayer.z -= Math.cos(cameraAngle) * moveSpeed;
                currentPlayer.rotation = cameraAngle + Math.PI;
                moved = true;
            }
            if (keys['a']) {
                currentPlayer.x += Math.sin(cameraAngle + Math.PI/2) * moveSpeed;
                currentPlayer.z += Math.cos(cameraAngle + Math.PI/2) * moveSpeed;
                currentPlayer.rotation = cameraAngle + Math.PI/2;
                moved = true;
            }
            if (keys['d']) {
                currentPlayer.x += Math.sin(cameraAngle - Math.PI/2) * moveSpeed;
                currentPlayer.z += Math.cos(cameraAngle - Math.PI/2) * moveSpeed;
                currentPlayer.rotation = cameraAngle - Math.PI/2;
                moved = true;
            }

            // Camera rotation with Q/E
            if (keys['q']) {
                cameraAngle -= 0.02;
            }
            if (keys['e']) {
                cameraAngle += 0.02;
            }

            // Mobile joystick controls
            if (joystickActive) {
                const threshold = 0.2;
                if (Math.abs(joystickDirection.x) > threshold || Math.abs(joystickDirection.y) > threshold) {
                    const angle = cameraAngle;
                    const dx = joystickDirection.x * Math.cos(angle) - joystickDirection.y * Math.sin(angle);
                    const dz = joystickDirection.x * Math.sin(angle) + joystickDirection.y * Math.cos(angle);
                    
                    currentPlayer.x += dx * moveSpeed;
                    currentPlayer.z += dz * moveSpeed;
                    currentPlayer.rotation = Math.atan2(dx, dz);
                    moved = true;
                }
            }

            // Keep player in bounds
            currentPlayer.x = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, currentPlayer.x));
            currentPlayer.z = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, currentPlayer.z));

            currentPlayer.moving = moved;

            // Update player mesh position
            if (playerMesh) {
                playerMesh.position.set(currentPlayer.x, currentPlayer.y, currentPlayer.z);
                playerMesh.rotation.y = currentPlayer.rotation;
            }

            // Move monsters randomly
            monsters.forEach((monster, index) => {
                if (monster.currentHp > 0 && Math.random() < 0.01) {
                    monster.direction = Math.random() * Math.PI * 2;
                }
                
                if (monster.currentHp > 0) {
                    monster.x += Math.sin(monster.direction) * monster.speed;
                    monster.z += Math.cos(monster.direction) * monster.speed;
                    
                    // Keep in bounds
                    monster.x = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, monster.x));
                    monster.z = Math.max(-MAP_SIZE/2, Math.min(MAP_SIZE/2, monster.z));

                    monsterMeshes[index].position.x = monster.x;
                    monsterMeshes[index].position.z = monster.z;
                    monsterMeshes[index].rotation.y = monster.direction;
                }
            });

            // Animate resources
            resourceMeshes.forEach((mesh, index) => {
                if (resources[index].name === 'Fish Spot' && resources[index].available) {
                    mesh.rotation.y += 0.01;
                }
            });

            // Update camera position
            updateCameraPosition();

            // Render scene
            renderer.render(scene, camera);
        }

        function updateCameraPosition() {
            const offset = {
                x: Math.sin(cameraAngle) * cameraDistance,
                y: cameraHeight,
                z: Math.cos(cameraAngle) * cameraDistance
            };

            camera.position.x = currentPlayer.x - offset.x;
            camera.position.y = currentPlayer.y + offset.y;
            camera.position.z = currentPlayer.z - offset.z;
            camera.lookAt(currentPlayer.x, currentPlayer.y, currentPlayer.z);
        }

        function handleMouseDown(e) {
            isMouseDown = true;
            mouseStartX = e.clientX;
        }

        function handleMouseMove(e) {
            if (isMouseDown) {
                const deltaX = e.clientX - mouseStartX;
                cameraAngle += deltaX * 0.005;
                mouseStartX = e.clientX;
            }
        }

        function handleMouseUp(e) {
            isMouseDown = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(10, Math.min(40, cameraDistance));
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Check monsters
            const monsterIntersects = raycaster.intersectObjects(monsterMeshes, true);
            if (monsterIntersects.length > 0) {
                let monsterGroup = monsterIntersects[0].object;
                while (monsterGroup.parent && !monsterGroup.userData.id) {
                    monsterGroup = monsterGroup.parent;
                }
                const monster = monsterGroup.userData;
                if (monster && monster.currentHp > 0) {
                    const dist = Math.hypot(currentPlayer.x - monster.x, currentPlayer.z - monster.z);
                    if (dist < 5) {
                        attackMonster(monster, monsterGroup);
                        return;
                    }
                }
            }

            // Check resources
            const resourceIntersects = raycaster.intersectObjects(resourceMeshes, true);
            if (resourceIntersects.length > 0) {
                let resourceMesh = resourceIntersects[0].object;
                while (resourceMesh.parent && !resourceMesh.userData.id) {
                    resourceMesh = resourceMesh.parent;
                }
                const resource = resourceMesh.userData;
                if (resource && resource.available) {
                    const dist = Math.hypot(currentPlayer.x - resource.x, currentPlayer.z - resource.z);
                    if (dist < 3) {
                        harvestResource(resource, resourceMesh);
                    }
                }
            }
        }

        function attackMonster(monster, monsterMesh) {
            const damage = 10 + currentPlayer.skills.combat * 2;
            monster.currentHp -= damage;
            addChatMessage('Combat', `You hit ${monster.name} for ${damage} damage!`, 'system');
            
            // Visual feedback
            monsterMesh.position.y += 0.2;
            setTimeout(() => {
                monsterMesh.position.y = monster.y;
            }, 200);

            if (monster.currentHp <= 0) {
                currentPlayer.xp += monster.xp;
                currentPlayer.skills.combat++;
                addChatMessage('Victory', `You defeated ${monster.name}! +${monster.xp} XP`, 'system');
                
                // Hide monster
                monsterMesh.visible = false;
                
                // Check level up
                const xpNeeded = currentPlayer.level * 100;
                if (currentPlayer.xp >= xpNeeded) {
                    currentPlayer.level++;
                    currentPlayer.xp = 0;
                    currentPlayer.maxHp += 10;
                    currentPlayer.hp = currentPlayer.maxHp;
                    addChatMessage('Level Up!', `You are now level ${currentPlayer.level}!`, 'system');
                }
                
                // Respawn monster
                setTimeout(() => {
                    monster.currentHp = monster.maxHp;
                    monster.x = (Math.random() - 0.5) * MAP_SIZE;
                    monster.z = (Math.random() - 0.5) * MAP_SIZE;
                    monsterMesh.position.x = monster.x;
                    monsterMesh.position.z = monster.z;
                    monsterMesh.visible = true;
                }, 5000);
            }
            
            updateStats();
        }

        function harvestResource(resource, resourceMesh) {
            resource.available = false;
            currentPlayer.skills[resource.skill]++;
            
            if (!currentPlayer.inventory[resource.item]) {
                currentPlayer.inventory[resource.item] = 0;
            }
            currentPlayer.inventory[resource.item]++;
            
            addChatMessage('Gathering', `You gathered ${resource.item}! ${resource.skill} +1`, 'system');
            updateQuestProgress('gather');
            
            // Check gathering achievement
            const totalGathered = Object.values(currentPlayer.inventory).reduce((a, b) => a + b, 0);
            if (totalGathered >= 100) checkAchievement('master_gatherer');
            
            // Rare buff drop from gathering
            if (Math.random() < 0.1) {
                applyBuff(['strength', 'speed', 'defense'][Math.floor(Math.random() * 3)]);
            }
            
            // Visual feedback
            resourceMesh.visible = false;
            createParticle(resource.x, resource.y, resource.z, 0x2ecc71, '‚ú®');
            
            renderInventory();
            updateStats();
            
            // Respawn resource
            setTimeout(() => {
                resource.available = true;
                resourceMesh.visible = true;
            }, 10000);
        }

        function updatePlayerPosition() {
            if (currentPlayer.id) {
                playersRef.child(currentPlayer.id).update({
                    x: currentPlayer.x,
                    y: currentPlayer.y,
                    z: currentPlayer.z,
                    rotation: currentPlayer.rotation,
                    lastActive: Date.now()
                });
            }
        }

        function attackNearestMonster() {
            let nearest = null;
            let nearestMesh = null;
            let minDist = Infinity;
            
            monsters.forEach((monster, index) => {
                if (monster.currentHp > 0) {
                    const dist = Math.hypot(monster.x - currentPlayer.x, monster.z - currentPlayer.z);
                    if (dist < minDist && dist < 5) {
                        minDist = dist;
                        nearest = monster;
                        nearestMesh = monsterMeshes[index];
                    }
                }
            });
            
            if (nearest) {
                attackMonster(nearest, nearestMesh);
            } else {
                addChatMessage('Combat', 'No monsters nearby!', 'system');
            }
        }

        function gatherResource() {
            let nearest = null;
            let nearestMesh = null;
            let minDist = Infinity;
            
            resources.forEach((resource, index) => {
                if (resource.available) {
                    const dist = Math.hypot(resource.x - currentPlayer.x, resource.z - currentPlayer.z);
                    if (dist < minDist && dist < 3) {
                        minDist = dist;
                        nearest = resource;
                        nearestMesh = resourceMeshes[index];
                    }
                }
            });
            
            if (nearest) {
                harvestResource(nearest, nearestMesh);
            } else {
                addChatMessage('Gathering', 'No resources nearby!', 'system');
            }
        }

        function openCrafting() {
            addChatMessage('Crafting', 'Crafting system coming soon! Collect resources to craft items.', 'system');
        }

        function openQuests() {
            addChatMessage('Quests', 'Quest system coming soon! Complete quests for rewards and XP.', 'system');
        }

        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            
            if (message) {
                chatRef.push({
                    player: currentPlayer.name,
                    message: message,
                    type: 'player',
                    timestamp: Date.now()
                });
                input.value = '';
                chatMessageCount++;
                if (chatMessageCount >= 50) checkAchievement('social');
            }
        }

        function addChatMessage(player, message, type = 'player') {
            const chatArea = document.getElementById('chatArea');
            const msgDiv = document.createElement('div');
            msgDiv.className = 'chat-message';
            
            if (type === 'system') {
                msgDiv.innerHTML = `<span class="chat-system">[${player}] ${message}</span>`;
            } else {
                msgDiv.innerHTML = `<span class="chat-player">${player}:</span> ${message}`;
            }
            
            chatArea.appendChild(msgDiv);
            chatArea.scrollTop = chatArea.scrollHeight;
            
            // Limit messages
            while (chatArea.children.length > 50) {
                chatArea.removeChild(chatArea.firstChild);
            }
        }

        function updateStats() {
            document.getElementById('combatLevel').textContent = currentPlayer.level;
            document.getElementById('goldCount').textContent = currentPlayer.gold;
            
            document.getElementById('hpBar').style.width = (currentPlayer.hp / currentPlayer.maxHp * 100) + '%';
            document.getElementById('hpBar').textContent = `${Math.floor(currentPlayer.hp)}/${currentPlayer.maxHp}`;
            
            document.getElementById('mpBar').style.width = (currentPlayer.mp / currentPlayer.maxMp * 100) + '%';
            document.getElementById('mpBar').textContent = `${Math.floor(currentPlayer.mp)}/${currentPlayer.maxMp}`;
            
            const xpNeeded = currentPlayer.level * 100;
            document.getElementById('xpBar').style.width = (currentPlayer.xp / xpNeeded * 100) + '%';
            document.getElementById('xpBar').textContent = `${currentPlayer.xp}/${xpNeeded}`;

            // Update stats
            document.getElementById('strengthStat').textContent = currentPlayer.stats.strength;
            document.getElementById('defenseStat').textContent = currentPlayer.stats.defense;
            document.getElementById('magicStat').textContent = currentPlayer.stats.magic;
            document.getElementById('speedStat').textContent = currentPlayer.stats.speed;

            // Update skills
            document.getElementById('combatSkill').textContent = currentPlayer.skills.combat;
            document.getElementById('miningSkill').textContent = currentPlayer.skills.mining;
            document.getElementById('woodcuttingSkill').textContent = currentPlayer.skills.woodcutting;
            document.getElementById('fishingSkill').textContent = currentPlayer.skills.fishing;
            document.getElementById('craftingSkill').textContent = currentPlayer.skills.crafting;
            document.getElementById('magicSkill').textContent = currentPlayer.skills.magic;
            
            // Update equipment slots
            document.getElementById('weaponSlot').textContent = currentPlayer.equipment.weapon || 'üó°Ô∏è Weapon';
            document.getElementById('armorSlot').textContent = currentPlayer.equipment.armor || 'üõ°Ô∏è Armor';
            document.getElementById('helmetSlot').textContent = currentPlayer.equipment.helmet || '‚õëÔ∏è Helmet';
            document.getElementById('bootsSlot').textContent = currentPlayer.equipment.boots || 'üë¢ Boots';
            
            // Update quest count
            document.getElementById('questCount').textContent = currentPlayer.quests.active.length;
            
            // Update ability cooldowns
            updateAbilityButtons();
        }

        function renderInventory() {
            const grid = document.getElementById('inventoryGrid');
            grid.innerHTML = '';
            const items = {
                'Wood': 'ü™µ',
                'Ore': 'ü™®',
                'Fish': 'üêü',
                'Sword': '‚öîÔ∏è',
                'Shield': 'üõ°Ô∏è',
                'Gem': 'üíé'
            };
            
            for (let i = 0; i < 16; i++) {
                const slot = document.createElement('div');
                slot.className = 'inventory-slot';
                
                const itemNames = Object.keys(currentPlayer.inventory);
                const itemName = itemNames[i];
                
                if (itemName && currentPlayer.inventory[itemName]) {
                    slot.classList.add('has-item');
                    slot.innerHTML = items[itemName] || 'üì¶';
                    const count = document.createElement('div');
                    count.className = 'item-count';
                    count.textContent = currentPlayer.inventory[itemName];
                    slot.appendChild(count);
                }
                
                grid.appendChild(slot);
            }
        }

        function onWindowResize() {
            camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
        }

        // Mobile Controls
        function initMobileControls() {
            const joystickContainer = document.getElementById('joystickContainer');
            const joystickKnob = document.getElementById('joystickKnob');

            function handleJoystickStart(e) {
                e.preventDefault();
                joystickActive = true;
                updateJoystick(e);
            }

            function handleJoystickMove(e) {
                e.preventDefault();
                if (joystickActive) {
                    updateJoystick(e);
                }
            }

            function handleJoystickEnd(e) {
                e.preventDefault();
                joystickActive = false;
                joystickDirection = { x: 0, y: 0 };
                joystickKnob.style.transform = 'translate(-50%, -50%)';
            }

            function updateJoystick(e) {
                const touch = e.touches ? e.touches[0] : e;
                const rect = joystickContainer.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;
                
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const maxDistance = rect.width / 2 - 25;
                
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }
                
                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
                
                // Normalize direction
                joystickDirection.x = deltaX / maxDistance;
                joystickDirection.y = deltaY / maxDistance;
            }

            // Touch events
            joystickContainer.addEventListener('touchstart', handleJoystickStart);
            joystickContainer.addEventListener('touchmove', handleJoystickMove);
            joystickContainer.addEventListener('touchend', handleJoystickEnd);
            
            // Mouse events for testing
            joystickContainer.addEventListener('mousedown', handleJoystickStart);
            joystickContainer.addEventListener('mousemove', handleJoystickMove);
            joystickContainer.addEventListener('mouseup', handleJoystickEnd);
            joystickContainer.addEventListener('mouseleave', handleJoystickEnd);
        }

        function toggleLeftSidebar() {
            const sidebar = document.getElementById('leftSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const rightSidebar = document.getElementById('rightSidebar');
            
            rightSidebar.classList.remove('open');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        }

        function toggleRightSidebar() {
            const sidebar = document.getElementById('rightSidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const leftSidebar = document.getElementById('leftSidebar');
            
            leftSidebar.classList.remove('open');
            sidebar.classList.toggle('open');
            overlay.classList.toggle('active');
        }

        function closeSidebars() {
            document.getElementById('leftSidebar').classList.remove('open');
            document.getElementById('rightSidebar').classList.remove('open');
            document.getElementById('sidebarOverlay').classList.remove('active');
        }

        // ========== NEW GAMEPLAY SYSTEMS ==========
        
        // Ability System
        function useAbility(abilityName) {
            const ability = currentPlayer.abilities[abilityName];
            
            if (ability.cooldown > 0) {
                addChatMessage('System', `Ability on cooldown! Wait ${Math.ceil(ability.cooldown/1000)}s`, 'system');
                return;
            }
            
            if (currentPlayer.mp < ability.mpCost) {
                addChatMessage('System', 'Not enough MP!', 'system');
                return;
            }
            
            currentPlayer.mp -= ability.mpCost;
            ability.cooldown = ability.maxCooldown;
            
            if (abilityName === 'fireball') {
                castFireball();
            } else if (abilityName === 'heal') {
                castHeal();
            } else if (abilityName === 'lightning') {
                castLightning();
            }
            
            updateStats();
        }
        
        function castFireball() {
            const nearest = findNearestMonster(10);
            if (nearest) {
                const damage = 25 + currentPlayer.stats.magic * 2;
                nearest.currentHp -= damage;
                createParticle(nearest.x, nearest.y, nearest.z, 0xff4500, 'üî•');
                addChatMessage('Combat', `Fireball hit ${nearest.name} for ${damage} damage!`, 'system');
                if (nearest.currentHp <= 0) handleMonsterDeath(nearest);
            } else {
                addChatMessage('System', 'No targets in range!', 'system');
            }
        }
        
        function castHeal() {
            const healing = 30 + currentPlayer.stats.magic;
            currentPlayer.hp = Math.min(currentPlayer.maxHp, currentPlayer.hp + healing);
            createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0x00ff00, 'üíö');
            addChatMessage('System', `Healed for ${healing} HP!`, 'system');
        }
        
        function castLightning() {
            const monstersInRange = monsters.filter(m => 
                m.currentHp > 0 && Math.hypot(m.x - currentPlayer.x, m.z - currentPlayer.z) < 15
            );
            
            const damage = 50 + currentPlayer.stats.magic * 3;
            monstersInRange.forEach(monster => {
                monster.currentHp -= damage;
                createParticle(monster.x, monster.y, monster.z, 0xffff00, '‚ö°');
                if (monster.currentHp <= 0) handleMonsterDeath(monster);
            });
            
            addChatMessage('Combat', `Lightning struck ${monstersInRange.length} enemies for ${damage} damage each!`, 'system');
        }
        
        function updateAbilityButtons() {
            Object.keys(currentPlayer.abilities).forEach(name => {
                const ability = currentPlayer.abilities[name];
                const btn = document.getElementById(name + 'Btn');
                if (btn) {
                    if (ability.cooldown > 0) {
                        btn.style.opacity = '0.5';
                        btn.style.pointerEvents = 'none';
                    } else {
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                    }
                }
            });
        }
        
        function findNearestMonster(maxDistance) {
            let nearest = null;
            let minDist = Infinity;
            
            monsters.forEach(monster => {
                if (monster.currentHp > 0) {
                    const dist = Math.hypot(monster.x - currentPlayer.x, monster.z - currentPlayer.z);
                    if (dist < minDist && dist < maxDistance) {
                        minDist = dist;
                        nearest = monster;
                    }
                }
            });
            
            return nearest;
        }
        
        // Quest System
        function toggleQuestPanel() {
            const panel = document.getElementById('questPanel');
            panel.classList.toggle('active');
            if (panel.classList.contains('active')) {
                renderQuests();
            }
        }
        
        function renderQuests() {
            const availableDiv = document.getElementById('availableQuests');
            const activeDiv = document.getElementById('activeQuestsPanel');
            
            availableDiv.innerHTML = '';
            activeDiv.innerHTML = '';
            
            // Show available quests
            QUESTS.forEach(quest => {
                if (currentPlayer.level >= quest.level && 
                    !currentPlayer.quests.completed.includes(quest.id) &&
                    !currentPlayer.quests.active.some(q => q.id === quest.id)) {
                    
                    const questEl = document.createElement('div');
                    questEl.className = 'quest-item';
                    questEl.innerHTML = `
                        <h4 style="color: #f39c12; margin-bottom: 0.5rem;">${quest.name}</h4>
                        <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">${quest.description}</p>
                        <p style="font-size: 0.8rem; color: #95a5a6;">Rewards: ${quest.reward.xp} XP, ${quest.reward.gold} Gold</p>
                        <button class="action-btn" style="margin-top: 0.5rem; padding: 0.5rem 1rem; font-size: 0.9rem;" onclick="acceptQuest('${quest.id}')">Accept Quest</button>
                    `;
                    availableDiv.appendChild(questEl);
                }
            });
            
            // Show active quests
            currentPlayer.quests.active.forEach(activeQuest => {
                const quest = QUESTS.find(q => q.id === activeQuest.id);
                if (quest) {
                    const questEl = document.createElement('div');
                    questEl.className = 'quest-item';
                    questEl.style.borderColor = '#2ecc71';
                    questEl.innerHTML = `
                        <h4 style="color: #2ecc71; margin-bottom: 0.5rem;">${quest.name}</h4>
                        <p style="font-size: 0.9rem; margin-bottom: 0.5rem;">${quest.description}</p>
                        <p style="font-size: 0.8rem; color: #2ecc71;">Progress: ${activeQuest.progress || 0}/${quest.objective.count || 1}</p>
                    `;
                    activeDiv.appendChild(questEl);
                }
            });
        }
        
        function acceptQuest(questId) {
            const quest = QUESTS.find(q => q.id === questId);
            if (quest) {
                currentPlayer.quests.active.push({ id: questId, progress: 0 });
                addChatMessage('Quest', `Accepted quest: ${quest.name}`, 'system');
                renderQuests();
            }
        }
        
        function updateQuestProgress(type, target = null) {
            currentPlayer.quests.active.forEach(activeQuest => {
                const quest = QUESTS.find(q => q.id === activeQuest.id);
                if (quest && quest.objective.type === type) {
                    if (!target || quest.objective.target === 'any' || quest.objective.target === target) {
                        activeQuest.progress = (activeQuest.progress || 0) + 1;
                        
                        if (activeQuest.progress >= (quest.objective.count || 1)) {
                            completeQuest(quest);
                        } else {
                            addChatMessage('Quest', `Quest progress: ${activeQuest.progress}/${quest.objective.count}`, 'system');
                        }
                    }
                }
            });
        }
        
        function completeQuest(quest) {
            currentPlayer.quests.active = currentPlayer.quests.active.filter(q => q.id !== quest.id);
            currentPlayer.quests.completed.push(quest.id);
            
            currentPlayer.xp += quest.reward.xp;
            currentPlayer.gold += quest.reward.gold;
            
            if (quest.reward.item) {
                currentPlayer.inventory[quest.reward.item] = (currentPlayer.inventory[quest.reward.item] || 0) + 1;
            }
            
            addChatMessage('Quest Complete', `üéâ ${quest.name} completed! +${quest.reward.xp} XP, +${quest.reward.gold} Gold`, 'system');
            checkLevelUp();
            updateStats();
            renderInventory();
        }
        
        // Shop System
        function openShop() {
            document.getElementById('shopPanel').classList.add('active');
            renderShop();
        }
        
        function closeShop() {
            document.getElementById('shopPanel').classList.remove('active');
        }
        
        function renderShop() {
            const shopDiv = document.getElementById('shopItems');
            document.getElementById('shopGold').textContent = currentPlayer.gold;
            shopDiv.innerHTML = '';
            
            Object.entries(EQUIPMENT).forEach(([category, items]) => {
                const categoryEl = document.createElement('div');
                categoryEl.style.marginBottom = '1.5rem';
                categoryEl.innerHTML = `<h3 style="color: #3498db; margin-bottom: 0.5rem;">${category.charAt(0).toUpperCase() + category.slice(1)}</h3>`;
                
                Object.entries(items).forEach(([name, stats]) => {
                    const itemEl = document.createElement('div');
                    itemEl.style.background = 'rgba(52, 73, 94, 0.5)';
                    itemEl.style.padding = '1rem';
                    itemEl.style.borderRadius = '5px';
                    itemEl.style.marginBottom = '0.5rem';
                    
                    const statsText = Object.entries(stats).filter(([k, v]) => k !== 'value' && k !== 'level').map(([k, v]) => `+${v} ${k}`).join(', ');
                    
                    itemEl.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${name}</strong> (Lv.${stats.level})
                                <div style="font-size: 0.8rem; color: #95a5a6;">${statsText}</div>
                            </div>
                            <button class="action-btn" style="padding: 0.5rem 1rem; font-size: 0.9rem;" onclick="buyItem('${category}', '${name}')">
                                üí∞ ${stats.value}
                            </button>
                        </div>
                    `;
                    categoryEl.appendChild(itemEl);
                });
                
                shopDiv.appendChild(categoryEl);
            });
        }
        
        function buyItem(category, itemName) {
            const item = EQUIPMENT[category][itemName];
            
            if (currentPlayer.level < item.level) {
                addChatMessage('Shop', `You need to be level ${item.level} to buy this!`, 'system');
                return;
            }
            
            if (currentPlayer.gold < item.value) {
                addChatMessage('Shop', 'Not enough gold!', 'system');
                return;
            }
            
            currentPlayer.gold -= item.value;
            
            const slot = category.slice(0, -1); // Remove 's' from category
            currentPlayer.equipment[slot] = itemName;
            
            // Apply stats
            if (item.damage) currentPlayer.stats.strength += item.damage;
            if (item.defense) currentPlayer.stats.defense += item.defense;
            if (item.magic) currentPlayer.stats.magic += item.magic;
            if (item.speed) currentPlayer.stats.speed += item.speed;
            
            addChatMessage('Shop', `Purchased ${itemName}!`, 'system');
            updateStats();
            renderShop();
        }
        
        // Achievement System
        function openAchievements() {
            document.getElementById('achievementsPanel').classList.add('active');
            renderAchievements();
        }
        
        function closeAchievements() {
            document.getElementById('achievementsPanel').classList.remove('active');
        }
        
        function renderAchievements() {
            const list = document.getElementById('achievementsList');
            list.innerHTML = '';
            
            ACHIEVEMENTS.forEach(achievement => {
                const unlocked = currentPlayer.achievements.includes(achievement.id);
                const achEl = document.createElement('div');
                achEl.style.background = unlocked ? 'rgba(46, 204, 113, 0.2)' : 'rgba(52, 73, 94, 0.5)';
                achEl.style.padding = '1rem';
                achEl.style.borderRadius = '10px';
                achEl.style.marginBottom = '0.5rem';
                achEl.style.borderLeft = unlocked ? '4px solid #2ecc71' : '4px solid #34495e';
                
                achEl.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 1rem;">
                        <div style="font-size: 2rem;">${achievement.icon}</div>
                        <div style="flex: 1;">
                            <strong style="color: ${unlocked ? '#2ecc71' : '#95a5a6'};">${achievement.name}</strong>
                            <div style="font-size: 0.9rem; color: #95a5a6;">${achievement.description}</div>
                        </div>
                        ${unlocked ? '<div style="color: #2ecc71; font-size: 1.5rem;">‚úì</div>' : ''}
                    </div>
                `;
                list.appendChild(achEl);
            });
        }
        
        function checkAchievement(id) {
            if (!currentPlayer.achievements.includes(id)) {
                currentPlayer.achievements.push(id);
                const achievement = ACHIEVEMENTS.find(a => a.id === id);
                if (achievement) {
                    addChatMessage('Achievement', `üèÜ Unlocked: ${achievement.name}!`, 'system');
                }
            }
        }
        
        // Particle System
        function createParticle(x, y, z, color, emoji) {
            const particle = {
                mesh: null,
                x, y, z,
                lifetime: 1000,
                created: Date.now()
            };
            
            // Create visual particle
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y + 1, z);
            particle.mesh = mesh;
            scene.add(mesh);
            
            particles.push(particle);
        }
        
        function updateParticles() {
            const now = Date.now();
            particles = particles.filter(particle => {
                const age = now - particle.created;
                if (age > particle.lifetime) {
                    scene.remove(particle.mesh);
                    return false;
                }
                
                // Animate particle
                particle.mesh.position.y += 0.02;
                particle.mesh.material.opacity = 1 - (age / particle.lifetime);
                particle.mesh.material.transparent = true;
                
                return true;
            });
        }
        
        // Day/Night Cycle
        function updateDayNightCycle() {
            timeOfDay += dayNightSpeed;
            if (timeOfDay >= 24) timeOfDay = 0;
            
            // Update lighting based on time
            const hour = Math.floor(timeOfDay);
            let intensity, color;
            
            if (hour >= 6 && hour < 18) {
                // Day
                intensity = 0.8;
                color = 0xffffff;
                scene.background = new THREE.Color(0x87CEEB);
                document.getElementById('timeIcon').textContent = '‚òÄÔ∏è';
                document.getElementById('timeText').textContent = 'Day';
            } else {
                // Night
                intensity = 0.3;
                color = 0x6666ff;
                scene.background = new THREE.Color(0x001a33);
                document.getElementById('timeIcon').textContent = 'üåô';
                document.getElementById('timeText').textContent = 'Night';
            }
            
            scene.children.forEach(child => {
                if (child instanceof THREE.DirectionalLight) {
                    child.intensity = intensity;
                    child.color.setHex(color);
                }
            });
        }
        
        // Mini-map
        function updateMiniMap() {
            const miniMapCanvas = document.getElementById('miniMapCanvas');
            if (!miniMapCanvas) return;
            
            const ctx = miniMapCanvas.getContext('2d');
            ctx.clearRect(0, 0, 150, 150);
            
            // Draw background
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, 150, 150);
            
            const scale = 150 / (MAP_SIZE * 2);
            const centerX = 75;
            const centerY = 75;
            
            // Draw monsters
            monsters.forEach(monster => {
                if (monster.currentHp > 0) {
                    const x = centerX + (monster.x - currentPlayer.x) * scale;
                    const y = centerY + (monster.z - currentPlayer.z) * scale;
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Draw resources
            resources.forEach(resource => {
                if (resource.available) {
                    const x = centerX + (resource.x - currentPlayer.x) * scale;
                    const y = centerY + (resource.z - currentPlayer.z) * scale;
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(x - 2, y - 2, 4, 4);
                }
            });
            
            // Draw other players
            Object.values(players).forEach(player => {
                const x = centerX + (player.x - currentPlayer.x) * scale;
                const y = centerY + (player.z - currentPlayer.z) * scale;
                ctx.fillStyle = '#3498db';
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw player (center)
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw direction
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.sin(currentPlayer.rotation) * 10, centerY + Math.cos(currentPlayer.rotation) * 10);
            ctx.stroke();
        }
        
        // Loot System
        function handleMonsterDeath(monster) {
            updateQuestProgress('kill', monster.name);
            checkAchievement('first_kill');
            if (monster.name === 'Dragon') checkAchievement('dragon_slayer');
            
            // Drop loot
            const goldDrop = Math.floor(monster.xp * 0.5 + Math.random() * 20);
            currentPlayer.gold += goldDrop;
            addChatMessage('Loot', `+${goldDrop} gold!`, 'system');
            
            // Chance to drop equipment
            if (Math.random() < 0.1) {
                const rareDrop = ['Iron Sword', 'Steel Armor', 'Magic Staff'][Math.floor(Math.random() * 3)];
                currentPlayer.inventory[rareDrop] = (currentPlayer.inventory[rareDrop] || 0) + 1;
                addChatMessage('Loot', `Found ${rareDrop}!`, 'system');
            }
            
            // Buff drops from monsters
            maybeDropBuff();
            
            if (currentPlayer.gold >= 1000) checkAchievement('rich');
        }
        
        function checkLevelUp() {
            const xpNeeded = currentPlayer.level * 100;
            if (currentPlayer.xp >= xpNeeded) {
                currentPlayer.level++;
                currentPlayer.xp = 0;
                currentPlayer.maxHp += 10;
                currentPlayer.maxMp += 10;
                currentPlayer.hp = currentPlayer.maxHp;
                currentPlayer.mp = currentPlayer.maxMp;
                currentPlayer.stats.strength += 2;
                currentPlayer.stats.defense += 2;
                currentPlayer.stats.magic += 2;
                currentPlayer.stats.speed += 1;
                
                addChatMessage('Level Up!', `üéâ You are now level ${currentPlayer.level}!`, 'system');
                createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0xffd700, 'üåü');
                
                if (currentPlayer.level >= 10) checkAchievement('level_10');
            }
        }
        
        // Enhanced game loop additions
        setInterval(() => {
            // Update ability cooldowns
            Object.values(currentPlayer.abilities).forEach(ability => {
                if (ability.cooldown > 0) {
                    ability.cooldown = Math.max(0, ability.cooldown - 100);
                }
            });
            
            // Regenerate MP
            currentPlayer.mp = Math.min(currentPlayer.maxMp, currentPlayer.mp + 0.5);
            
            // Update particles
            updateParticles();
            
            // Update day/night
            updateDayNightCycle();
            
            // Update mini-map
            updateMiniMap();
            
            updateStats();
        }, 100);
        
        // Keyboard shortcuts for abilities
        window.addEventListener('keydown', (e) => {
            if (e.key === '1') useAbility('fireball');
            if (e.key === '2') useAbility('heal');
            if (e.key === '3') useAbility('lightning');
            if (e.key === '4') changeWeather(); // Debug: Change weather
        });

        // ========== NEW CREATIVE FEATURES ==========
        
        // PET SYSTEM
        function openPetShop() {
            document.getElementById('petShopPanel').style.display = 'block';
            document.getElementById('petShopGold').textContent = currentPlayer.gold;
            document.getElementById('activePet').textContent = currentPlayer.pet || 'None';
            
            const container = document.getElementById('petShopItems');
            container.innerHTML = '';
            
            Object.entries(PETS).forEach(([name, pet]) => {
                const canBuy = currentPlayer.level >= pet.level && currentPlayer.gold >= pet.cost;
                const owned = currentPlayer.pet === name;
                
                container.innerHTML += `
                    <div class="quest-item" style="opacity: ${canBuy || owned ? 1 : 0.5};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-size: 2rem;">${pet.icon}</div>
                                <strong>${name}</strong>
                                <p style="font-size: 0.85rem; color: #bdc3c7; margin: 0.3rem 0;">${pet.description}</p>
                                <span style="color: #e74c3c;">üí• ${pet.damage} damage</span>
                                ${pet.healing ? `<span style="color: #2ecc71;"> | üíö ${pet.healing} healing</span>` : ''}
                                <br><span style="color: #95a5a6;">Level ${pet.level} required</span>
                            </div>
                            <div style="text-align: right;">
                                <div style="color: #f39c12; font-size: 1.1rem; margin-bottom: 0.5rem;">üí∞ ${pet.cost}</div>
                                ${owned ? '<span style="color: #2ecc71;">‚úì Active</span>' : 
                                  canBuy ? `<button class="action-btn" style="padding: 0.5rem 1rem;" onclick="buyPet('${name}')">Buy</button>` : 
                                  '<span style="color: #e74c3c;">Locked</span>'}
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        function buyPet(petName) {
            const pet = PETS[petName];
            if (currentPlayer.level < pet.level) {
                addChatMessage('Pet Shop', `You need level ${pet.level} to buy this pet!`, 'system');
                return;
            }
            if (currentPlayer.gold < pet.cost) {
                addChatMessage('Pet Shop', 'Not enough gold!', 'system');
                return;
            }
            
            currentPlayer.gold -= pet.cost;
            currentPlayer.pet = petName;
            addChatMessage('Pet Shop', `üêæ You bought ${petName}!`, 'system');
            createPetMesh();
            openPetShop(); // Refresh display
            saveGame();
        }
        
        function createPetMesh() {
            if (!currentPlayer.pet) return;
            
            // Remove old pet
            if (petMesh) {
                scene.remove(petMesh);
            }
            
            const pet = PETS[currentPlayer.pet];
            const geometry = new THREE.SphereGeometry(0.3, 8, 8);
            const material = new THREE.MeshStandardMaterial({ 
                color: pet.icon === 'üê∫' ? 0x808080 : pet.icon === 'üî•' ? 0xff4500 : pet.icon === 'üêâ' ? 0x4169E1 : 0xff6347,
                emissive: pet.icon === 'üî•' ? 0xff4500 : 0x000000,
                emissiveIntensity: 0.3
            });
            petMesh = new THREE.Mesh(geometry, material);
            petMesh.castShadow = true;
            scene.add(petMesh);
        }
        
        function updatePet() {
            if (!petMesh || !currentPlayer.pet) return;
            
            // Pet follows player with offset
            const offsetDistance = 2;
            const offsetAngle = currentPlayer.rotation + Math.PI;
            petMesh.position.x = currentPlayer.x + Math.sin(offsetAngle) * offsetDistance;
            petMesh.position.y = currentPlayer.y + 0.5 + Math.sin(Date.now() * 0.003) * 0.2;
            petMesh.position.z = currentPlayer.z + Math.cos(offsetAngle) * offsetDistance;
            
            // Pet attacks nearby monsters
            if (Math.random() < 0.05) {
                const pet = PETS[currentPlayer.pet];
                const nearbyMonster = findNearestMonster(5);
                if (nearbyMonster) {
                    nearbyMonster.currentHp -= pet.damage;
                    createParticle(nearbyMonster.x, nearbyMonster.y, nearbyMonster.z, 0xff6347, 'üí•');
                }
            }
        }
        
        function closePetShop() {
            document.getElementById('petShopPanel').style.display = 'none';
        }
        
        // CRAFTING SYSTEM
        function openCraftingPanel() {
            document.getElementById('craftingPanel').style.display = 'block';
            document.getElementById('craftingLevel').textContent = currentPlayer.skills.crafting;
            
            const container = document.getElementById('craftingRecipes');
            container.innerHTML = '';
            
            Object.entries(CRAFTING_RECIPES).forEach(([itemName, recipe]) => {
                const canCraft = currentPlayer.skills.crafting >= recipe.level && 
                                 Object.entries(recipe.materials).every(([mat, qty]) => 
                                     (currentPlayer.inventory[mat] || 0) >= qty);
                
                const materialsText = Object.entries(recipe.materials)
                    .map(([mat, qty]) => {
                        const has = currentPlayer.inventory[mat] || 0;
                        const color = has >= qty ? '#2ecc71' : '#e74c3c';
                        return `<span style="color: ${color};">${mat} ${has}/${qty}</span>`;
                    }).join(', ');
                
                container.innerHTML += `
                    <div class="quest-item" style="opacity: ${canCraft ? 1 : 0.5};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>Craft ${itemName}</strong>
                                <p style="font-size: 0.85rem; margin: 0.3rem 0;">${materialsText}</p>
                                <span style="color: #3498db;">+${recipe.craftingXP} Crafting XP</span>
                                <span style="color: #95a5a6;"> | Level ${recipe.level}</span>
                            </div>
                            <button class="action-btn craft" style="padding: 0.5rem 1rem;" 
                                    onclick="craftItem('${itemName}')" ${!canCraft ? 'disabled' : ''}>
                                Craft
                            </button>
                        </div>
                    </div>
                `;
            });
        }
        
        function craftItem(itemName) {
            const recipe = CRAFTING_RECIPES[itemName];
            if (!recipe) return;
            
            if (currentPlayer.skills.crafting < recipe.level) {
                addChatMessage('Crafting', `You need crafting level ${recipe.level}!`, 'system');
                return;
            }
            
            // Check materials
            for (let [mat, qty] of Object.entries(recipe.materials)) {
                if ((currentPlayer.inventory[mat] || 0) < qty) {
                    addChatMessage('Crafting', `Not enough ${mat}!`, 'system');
                    return;
                }
            }
            
            // Consume materials
            for (let [mat, qty] of Object.entries(recipe.materials)) {
                currentPlayer.inventory[mat] -= qty;
                if (currentPlayer.inventory[mat] <= 0) delete currentPlayer.inventory[mat];
            }
            
            // Create item
            currentPlayer.inventory[itemName] = (currentPlayer.inventory[itemName] || 0) + 1;
            currentPlayer.skills.crafting += recipe.craftingXP / 100;
            currentPlayer.craftedItems++;
            
            addChatMessage('Crafting', `üî® Crafted ${itemName}!`, 'system');
            createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0xffa500, '‚ú®');
            updateQuestProgress('craft');
            
            if (isMobile && navigator.vibrate) navigator.vibrate(50);
            
            openCraftingPanel(); // Refresh
            renderInventory();
            saveGame();
        }
        
        function closeCraftingPanel() {
            document.getElementById('craftingPanel').style.display = 'none';
        }
        
        // WEATHER SYSTEM
        function changeWeather() {
            const newWeather = WEATHER_TYPES[Math.floor(Math.random() * WEATHER_TYPES.length)];
            setWeather(newWeather);
        }
        
        function setWeather(weatherType) {
            currentWeather = weatherType;
            
            // Clear old weather particles
            weatherParticles.forEach(p => scene.remove(p));
            weatherParticles = [];
            
            const weatherIcons = { clear: '‚òÄÔ∏è', rain: 'üåßÔ∏è', snow: '‚ùÑÔ∏è', fog: 'üå´Ô∏è', storm: '‚õàÔ∏è' };
            document.getElementById('weatherIcon').textContent = weatherIcons[weatherType];
            document.getElementById('weatherText').textContent = weatherType.charAt(0).toUpperCase() + weatherType.slice(1);
            
            // Create weather effects
            if (weatherType === 'rain' || weatherType === 'snow' || weatherType === 'storm') {
                for (let i = 0; i < 100; i++) {
                    const geometry = new THREE.SphereGeometry(weatherType === 'snow' ? 0.05 : 0.03, 4, 4);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: weatherType === 'snow' ? 0xffffff : 0x4169e1,
                        transparent: true,
                        opacity: 0.6
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.set(
                        (Math.random() - 0.5) * MAP_SIZE,
                        Math.random() * 30 + 10,
                        (Math.random() - 0.5) * MAP_SIZE
                    );
                    particle.userData = { 
                        speed: weatherType === 'snow' ? 0.02 : (weatherType === 'storm' ? 0.3 : 0.1),
                        drift: Math.random() * 0.02 - 0.01
                    };
                    scene.add(particle);
                    weatherParticles.push(particle);
                }
            }
            
            // Fog effect
            if (weatherType === 'fog') {
                scene.fog = new THREE.Fog(0xcccccc, 10, 30);
            } else {
                scene.fog = null;
            }
            
            // Storm darkens sky
            if (weatherType === 'storm') {
                scene.background = new THREE.Color(0x2c3e50);
            }
            
            addChatMessage('Weather', `Weather changed to ${weatherType}!`, 'system');
        }
        
        function updateWeather() {
            weatherParticles.forEach(particle => {
                particle.position.y -= particle.userData.speed;
                particle.position.x += particle.userData.drift;
                
                if (particle.position.y < 0) {
                    particle.position.y = 30;
                    particle.position.x = currentPlayer.x + (Math.random() - 0.5) * 50;
                    particle.position.z = currentPlayer.z + (Math.random() - 0.5) * 50;
                }
            });
            
            // Random weather changes
            if (Math.random() < 0.0005) {
                changeWeather();
            }
        }
        
        // BUFF SYSTEM
        function applyBuff(buffType) {
            const buff = BUFFS[buffType];
            if (!buff) return;
            
            const existingBuff = activeBuffs.find(b => b.type === buffType);
            if (existingBuff) {
                existingBuff.endTime = Date.now() + buff.duration;
            } else {
                activeBuffs.push({
                    type: buffType,
                    ...buff,
                    endTime: Date.now() + buff.duration
                });
                
                // Apply effect
                Object.entries(buff.effect).forEach(([stat, value]) => {
                    if (stat === 'hpRegen') return; // Handled separately
                    currentPlayer.stats[stat] = (currentPlayer.stats[stat] || 0) + value;
                });
                
                addChatMessage('Buff', `${buff.icon} ${buff.name} activated!`, 'system');
                createParticle(currentPlayer.x, currentPlayer.y, currentPlayer.z, 0x9b59b6, '‚ú®');
            }
            
            updateBuffDisplay();
        }
        
        function updateBuffs() {
            const now = Date.now();
            activeBuffs = activeBuffs.filter(buff => {
                if (now >= buff.endTime) {
                    // Remove effect
                    Object.entries(buff.effect).forEach(([stat, value]) => {
                        if (stat === 'hpRegen') return;
                        currentPlayer.stats[stat] = (currentPlayer.stats[stat] || 0) - value;
                    });
                    addChatMessage('Buff', `${buff.icon} ${buff.name} wore off`, 'system');
                    return false;
                }
                
                // Apply regen
                if (buff.effect.hpRegen) {
                    currentPlayer.hp = Math.min(currentPlayer.maxHp, currentPlayer.hp + buff.effect.hpRegen * 0.1);
                }
                
                return true;
            });
            
            updateBuffDisplay();
        }
        
        function updateBuffDisplay() {
            const container = document.getElementById('buffsContainer');
            container.innerHTML = '';
            
            activeBuffs.forEach(buff => {
                const timeLeft = Math.ceil((buff.endTime - Date.now()) / 1000);
                container.innerHTML += `
                    <div style="background: rgba(155, 89, 182, 0.9); padding: 0.5rem; border-radius: 10px; text-align: center; min-width: 50px;">
                        <div style="font-size: 1.5rem;">${buff.icon}</div>
                        <div style="font-size: 0.7rem;">${timeLeft}s</div>
                    </div>
                `;
            });
        }
        
        // Random buff drops from monsters
        function maybeDropBuff() {
            if (Math.random() < 0.15) {
                const buffTypes = Object.keys(BUFFS);
                const randomBuff = buffTypes[Math.floor(Math.random() * buffTypes.length)];
                applyBuff(randomBuff);
            }
        }
        
        // EMOTE SYSTEM
        function openEmoteMenu() {
            document.getElementById('emotePanel').style.display = 'block';
            
            const grid = document.getElementById('emoteGrid');
            grid.innerHTML = '';
            
            const emoteIcons = {
                wave: 'üëã', dance: 'üíÉ', cheer: 'üéâ', laugh: 'üòÇ',
                cry: 'üò¢', angry: 'üò†', sleep: 'üò¥', think: 'ü§î'
            };
            
            EMOTES.forEach(emote => {
                grid.innerHTML += `
                    <button class="action-btn" style="padding: 1rem; font-size: 2rem;" 
                            onclick="performEmote('${emote}')">
                        ${emoteIcons[emote]}
                    </button>
                `;
            });
        }
        
        function performEmote(emote) {
            currentPlayer.emote = emote;
            
            const emoteMessages = {
                wave: 'üëã waves', dance: 'üíÉ dances', cheer: 'üéâ cheers',
                laugh: 'üòÇ laughs', cry: 'üò¢ cries', angry: 'üò† is angry',
                sleep: 'üò¥ is sleeping', think: 'ü§î is thinking'
            };
            
            addChatMessage(currentPlayer.name, emoteMessages[emote], 'emote');
            
            // Show emote above player
            createParticle(currentPlayer.x, currentPlayer.y + 2, currentPlayer.z, 0xffffff, 
                          {wave: 'üëã', dance: 'üíÉ', cheer: 'üéâ', laugh: 'üòÇ', cry: 'üò¢', 
                           angry: 'üò†', sleep: 'üò¥', think: 'ü§î'}[emote]);
            
            setTimeout(() => {
                currentPlayer.emote = null;
            }, 3000);
            
            closeEmoteMenu();
        }
        
        function closeEmoteMenu() {
            document.getElementById('emotePanel').style.display = 'none';
        }
        
        // ACHIEVEMENT TRACKING
        function trackDistance() {
            const dist = Math.hypot(currentPlayer.x - lastPlayerPos.x, currentPlayer.z - lastPlayerPos.z);
            totalDistanceTraveled += dist;
            lastPlayerPos = { x: currentPlayer.x, z: currentPlayer.z };
            
            if (totalDistanceTraveled >= 1000) checkAchievement('explorer');
        }
        
        // ENHANCED GAME SAVING
        function saveGame() {
            // Save to localStorage as backup
            localStorage.setItem('fantasyquest_save', JSON.stringify({
                name: currentPlayer.name,
                level: currentPlayer.level,
                xp: currentPlayer.xp,
                gold: currentPlayer.gold,
                hp: currentPlayer.hp,
                mp: currentPlayer.mp,
                skills: currentPlayer.skills,
                stats: currentPlayer.stats,
                equipment: currentPlayer.equipment,
                inventory: currentPlayer.inventory,
                pet: currentPlayer.pet,
                achievements: currentPlayer.achievements,
                quests: currentPlayer.quests,
                craftedItems: currentPlayer.craftedItems,
                distanceTraveled: totalDistanceTraveled,
                chatCount: chatMessageCount
            }));
            
            // Also save to cloud if authenticated
            if (currentUser) {
                saveGameToCloud();
            }
        }
        
        function loadGame() {
            // This is now handled by the auth state listener
            // Keep for backward compatibility with non-auth mode
            const save = localStorage.getItem('fantasyquest_save');
            if (!save) return false;
            
            try {
                const data = JSON.parse(save);
                Object.assign(currentPlayer, data);
                totalDistanceTraveled = data.distanceTraveled || 0;
                chatMessageCount = data.chatCount || 0;
                if (data.pet) createPetMesh();
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Enhanced game loop
        const originalInterval = setInterval(() => {
            updatePet();
            updateWeather();
            updateBuffs();
            trackDistance();
            if (Math.random() < 0.01) saveGame(); // Auto-save (both local and cloud)
        }, 100);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            saveGame(); // Save both local and cloud
            if (currentPlayer.id && playersRef) {
                playersRef.child(currentPlayer.id).remove();
            }
        });
        
        // Initialize weather
        setTimeout(() => {
            if (scene) setWeather('clear');
        }, 2000);
    </script>
</body>
</html>
